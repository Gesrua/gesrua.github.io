{"pages":[{"title":"","text":"¶ 我？ OI 退役，ZJ 高三现役，选考物化技 喜欢精巧的结构","link":"/about/"},{"title":"","text":"","link":"/categories/"},{"title":"","text":"","link":"/tags/"}],"posts":[{"title":"NOI 2020 退役记","text":"这个家伙很菜，什么也没有留下 ZJ 老年高二卑微弱校 D 类选手 ZJOI 2020 各种暴毙 虽然说我从来没有期望过进省队，但是 rk89 也是远低于预期 当时连退役记都没心情写，教练问我 WC 和 APIO 要不要去，我全拒了，报了暑假各种文化课培训班 万万没想到被续了 D 类 ¶ Day -inf 文化课补习班ing 学会了杜教筛 补了前几年的题，学习了模拟费用流，学习了后缀数组 ¶ Day -1 在高铁上学习了二次剩余，学习了 CRT 和镇海神仙队同车厢，瞥了一眼全在打游戏，瑟瑟发抖.jpg 接站时，“效实中学 2 个人是吧。绍兴中学 1 个人是吧。”“是 10 个” 志愿者好评，提供了各种帮助，发了狗牌和两本书还有几件衣服和一个书包（书包比较神奇，不难发现表面有一个 USB 口，其内部又有一根 USB 线，具体用途不明（ 食堂是自助餐，供应果汁+豆浆，好评 感谢 ouuan 的 Despised ¶ Day 0 上午开幕式 忽然明白 3M 原则是什么梗 dzd：“我要强调几条纪律:1：…2：…3：在食堂剩饭总分扣一分。” 掌声雷动（雾 下午笔试+试机 坐在风口下面，冻成冰沙雕（考场能不能带小被子 恭喜 UOJ 猜到笔试题 打了几个板子发现啥都不会，KDT 不会，Splay 忘了，DP 全推不出，自闭ing ¶ Day 1 忽然发现男生和女生是在同一层楼隔着屏风（滑稽.jpg 寝室空调开太冷了，小被子无法温暖我，睡得很晚，睡眠质量也差 没分在风口位置，万幸，温度舒适 目标分数 150pts 看了一下 T1，暴力和 UNR#4 D1T3 的暴力差不多，设 fi,jf_{i, j}fi,j​，表示 111 走到 iii 走了 jjj 的长度的最大收益，O(mT)O(mT)O(mT)，只有40pts 感觉没法优化。 冷静一下看 T2 感觉会 O(n⋅2m)O(n\\cdot2^m)O(n⋅2m) DP，不是很好写，没多少分。 看 T3 感觉是数据结构，并不是很会。 先打了 T1 暴力，忽然看到 w≤5w \\le 5w≤5 感觉可以矩阵，先考虑一下 5×n5\\times n5×n 的矩阵发现不行，用了 1×5n1\\times 5n1×5n 的矩阵，2503log⁡109250^3\\log 10^92503log109 感觉很虚，但还是写了。存了矩阵 2 的幂次，写乘法用了几个 register，忽然发现 1×5n1\\times 5n1×5n 矩阵乘 5n×5n5n\\times 5n5n×5n 矩阵是 n2n^2n2，非常感动。复杂度大概是 O(n3log⁡T+n2klog⁡T)O(n^3\\log T + n^2 k \\log T)O(n3logT+n2klogT)。 随了几组，可以跑过。忽然忘记对拍脚本写法，用 Python os.system() 瞎搞。2.5h A 了 T1。 上个厕所平复一下激动之情，写了一下 T2 O(n∗2n)O(n*2^n)O(n∗2n)。看了一下 T3，当时觉得 T3 A性质可以用树套树水过 40pts 美滋滋（然而并不能 忽然忘记树套树怎么写，乱搞了一通，单点修改和区间查询正常了，过了 O(mnlog⁡n)O(mn\\log n)O(mnlogn)（但实际上只要扫描线即可）。发现区间修改不会做，然后乱搞了一下 tag，并没有写过去。 比赛结束 T2 T3 全写了普及组暴力 估分 140140140 同寝神仙 252，听他怒斥傻逼题，深深感到了自己的弱小 感觉 T2 顺着想是不难发现 n2n^2n2 DPDPDP 的可惜去搞 T3 复测的时候发现 T3 O(nmlog⁡n)O(nm\\log n)O(nmlogn) 的暴力没删调试，GG 140-&gt;128 旁边有个兄弟文件夹建错了，默哀（考完 Day 2 回看，只考 Day 1 Ag-&gt;Ag，只考 Day 2 Au-&gt;Ag 听说 zx 和 zyy 阿克了 %%% 晚上讲题，从来没听说过所谓区间逆序的说法，分块只做过模板（也处于我对分块的偏见，认为它是不优美的数据结构），我才是时代的眼泪。 感觉别人 T2+T3 都 70pts 以上，非常难受 讲题以后就各种颓废，完全没心思，看了看 2016 年集训队论文第二篇网络流相关。 ¶ Day 2 没睡好，有点晕 开考前去操场上小声唱歌（「不可道」真的好听，安利 心情平静 翻了一下题，感觉 T1 是网络流，T2 题面暗示是一个智商题，T3 是个看不懂的图论。 想了想 T1 的网络流，建了一个 naive 的图，想起我校大佬教育了我的 ZJOI 2020 D1T3 序列的 naive 网络流做法是错的，感觉不可以做。 然后不难观察如果你要使用两个原材料（一个 ≤k\\le k≤k，一个 ≥k\\ge k≥k），肯定会把小的用完。 然后就 dfs，眼睛看了一下小样例过了，大样例跑得飞快，试图手写 checker ，发现好像困难，随便调了点参数造了几组，又跑得飞快，不知道正确性怎么样。 去看 T2 T3，T2 反复在会了和假了之间横跳，想了一个三缩一立刻被自己 hack。 T3 题面看了好久才懂那个环是在限制原图，先打了一个 Tarjan 割边，想不到 n2n^2n2 做法，画了一下，感觉性质 A 就是最短路，写了，过了 A 的样例。 还剩 2h 看 T3，把发的东西（士力架x2+菠萝包）全吃了，乱想了一个 n2mn2^mn2m 被自己批判了，看了一下关于树高的限制，感觉可以枚举所有树判一下。 忽然发现不会如何枚举所有高度 ≤h\\le h≤h 的二叉树，自己乱搞了一个，总复杂度是 O(2h×22h)O(2^h\\times 2^{2^h})O(2h×22h) 理应 h 越大越正确，但是只有 h=4h=4h=4 能跑样例，没时间了。 GG Day 2 翻盘-&gt;翻车 成绩咕了 1h 多，不知道什么原因 45+8+2045+8+2045+8+20 非常感动， T2 好像后面一个点是用脚造的，T1 能把 dfs 卡成 45，我那个 Tarjan 判无解不如不写。 听说 PKU 要 480， 深深感到自己的弱小。 讲题全程掉线，感觉全是 observation， 出题人说 T2 输出样例有 12pts，我是傻逼。 由于对自己智商的不自信（实际也应该不自信 qwq），没有去思考 T2 正解，几乎时间全投入打暴力。 如果我是正式选手的话是 rk175，勉强 Ag 对于这次 NOI 2020 的题目，非常感动，因为颓废+学习文化课的原因，我多项式（指 FFT、NTT、以及所有多项式算法）和高级数据结构（LCT）还有高端字符串科技（例如 SAM、后缀树、ZJOI 2020 的 runs），是完全不会，这次考察的知识点并没有涉及。此次还是重在思维的考察（虽然我思维没有，但其他人也没有（暴论 ¶ Day 3 高铁站茶颜悦色，因为各种原因并没有点 k 站长强烈推荐的幽兰拿铁 高铁上感慨了一下没做过的暑假作业，23 号开学。 短暂逃避文化课，拿了一张废纸 ¶ 退役感想 写这篇文章时，看了看 working 文件夹许多没写完的题，看了看 _post 文件夹许多没补的题解，决定全删了 从上面这篇游记不难看出这名选手很菜，他很菜的原因是他很颓废。 长期处在退役/续命的叠加态，没有认真学习 OI（文化课还是认真学了 时间最长的停课也许是 CSP 前的两周停课。对于 ZJOI 2020 也只有一周的停课颓废。 但是显然，一周时间是无法补完所有知识点的。 于是他理所当然的炸了，并没有什么可抱怨的。 NOI 2020 D 类也完全是机缘巧合。 在一个并不怎么大力支持竞赛的学校，也许命运就是这样（其实主因还是自己颓废，网课的时候明明可以却没有学 OI 感谢我小学时的启蒙老师。 感谢我高中时的教练。 感谢我文化课老师的理解和支持。 感谢我的学长。 感谢我的同学们。 我给 OI 只贡献了 OI-wiki 的矩阵页面的一小部分 + 自己的一些 naive 课件 + 一些题解和题目翻译 我的 OI 生涯全程矩阵相关，我的最满意课件是「矩阵初步」，ZJOI 和 NOI 全靠矩阵 A 题，这就是缘分吧 233 ¶ 人生经验 事实证明，学习完递归，单靠互联网资源学习，完全可以达到 NOIP 400+，加上必要的省选级别算法、数据结构 + NOI 原题训练，完全可以 NOI Ag 的（因为 Ag 多了）。 比如我初中基本上是自己一个人（颓废），高中做题方面基本没有别人帮助（但教练会安排比赛，后期有学长教育），刷的是洛谷试炼场（历史的眼泪）提升水平，考前打了几场牛客模拟赛熟悉节奏，就 400+ 了，我做题数可以说是非常少，我 OI-Code 基本上是我全部的练习代码（533 题，其中很多是我在混普及组的时候写的），加上 35 场 NOIP 模拟赛和 39 场 Codeforces，这就是我的 OI 生涯全部代码（当然还有一些摸鱼项目代码和杂七杂八的练习代码没有统计 对于所谓弱校没有资源的情况，我认为在 NOIP 阶段是不合适的，这一阶段已经有很好的纸质教材（安利 lyd 的「算法竞赛进阶指南」） + 丰富的模拟赛资源。 OI 的资源主要在于其有优秀同学 + 学长指导 + 学校支持，但我认为这在省选及以上更明显，因为 NOIP 算法少，但是省选缺少纸质教材，如果没有同学交流学习效率是难以上升的，不在于个人颓废之类的原因，而在于省选算法确实更加困难，有同学可以互相教育提升水平。（虽然感觉我这段话是在为自己找借口 也许夹杂了一些暴论（","link":"/archives/NOI2020"},{"title":"OI模板","text":"flag: 我有一天我会写出两个头文件 advanced_data_structure.h algorithm++.h 数据结构 ¶ 前缀和 si=∑k=1iai s_i = \\sum_{k=1}^{i} a_i si​=k=1∑i​ai​1234int s[1000];for (int i = 1; i &lt;= n; ++i){ s[i] = s[i-1] + a[i];} ¶ 差分 令 a0=0a_0 = 0a0​=0 ci=ai−ai−1 c_i = a_i - a_{i-1} ci​=ai​−ai−1​¶ 线段树 ¶ 树状数组 ¶ 基本版 12345678910111213141516struct BIT{ int c[N]; int lowbit(int x){return x&amp;-x;} void add(int pos, int x){ for (int i = pos; i &lt;= n; i += lowbit(i)) c[i] += x; } int sum(int n){ int ret = 0; for (int i = n; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; } int query(int l, int r){ return sum(r) - sum(l-1);}; ¶ 加强版 1234567891011121314151617181920struct EXBIT{ BIT t, s; void init(int pos, int add){ s.add(pos, add); t.add(pos, (pos-1)*add); } void add(int l, int r, int x){ s.add(l, x); s.add(r+1, -x); t.add(l, (l-1)*x); t.add(r+1, -r*x); } int _ask(int r){ if (r &lt;= 0) return 0; return r*s.sum(r) - t.sum(r); } int ask(int l, int r){ return _ask(r) - _ask(l-1); }}; 图论 ¶ 最短路 ¶ Floyd 12rep(k, 1, n) rep(u, 1, n) rep(v, 1, n) g[u][v] = min(g[u][v], g[u][k] + g[k][v]) ¶ Dijkstra ¶ 网络流 1234567891011struct Edge { int v, cap; Edge *nxt, *rev;} e[M];Edge* p[N]; int cnt = 0;void addedge(int u, int v, int cap) { e[cnt] = (Edge){v, cap, p[u], &amp;e[cnt + 1]}; p[u] = &amp;e[cnt++]; e[cnt] = (Edge){u, 0, p[v], &amp;e[cnt - 1]}; p[v] = &amp;e[cnt++];} ¶ 最大流 ¶ Edmonds-Karp 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct node { edge* e; int v;} pre[N];bool bfs() { std::memset(flag, 0, sizeof(flag)); flag[s] = 1; q.clear(); q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); travese(i, u) { if (i-&gt;v == t &amp;&amp; i-&gt;cap &gt; 0) { pre[i-&gt;v].v = u; pre[i-&gt;v].e = i; return 1; } if (flag[i-&gt;v]) continue; if (i-&gt;cap &gt; 0) { pre[i-&gt;v].v = u; pre[i-&gt;v].e = i; q.push(i-&gt;v); flag[i-&gt;v] = 1; } } } return 0;}int maxflow = 0;while (bfs()) { int delta = INF; for (int i = t; i != s; i = pre[i].v) { delta = std::min(delta, pre[i].e-&gt;cap); } for (int i = t; i != s; i = pre[i].v) { pre[i].e-&gt;cap -= delta; pre[i].e-&gt;rev-&gt;cap += delta; } maxflow += delta;}cout &lt;&lt; maxflow; ¶ Dinic 12345678910111213141516171819202122232425262728293031323334353637383940Edge *cur[N]; int dep[N];bool bfs() { rep(i, 0, cnt) cur[i] = p[i]; std::memset(dep, 0, sizeof(dep)); dep[s] = 1; std::queue&lt;int&gt; q; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (auto i = p[u]; i; i = i-&gt;nxt) { if (i-&gt;cap &gt; 0 &amp;&amp; !dep[i-&gt;v]) dep[i-&gt;v] = dep[u] + 1, q.push(i-&gt;v); } } return dep[t];}int dfs(int u, int pre) { int flow = 0, delta; if (u == t || pre &lt;= 0) return pre; for (auto i = cur[u]; i; cur[u] = i = i-&gt;nxt) { if (i-&gt;cap &lt;= 0 || dep[i-&gt;v] != dep[u] + 1) continue; delta = dfs(i-&gt;v, std::min(pre, i-&gt;cap)); i-&gt;cap -= delta; i-&gt;rev-&gt;cap += delta; flow += delta; pre -= delta; if (pre == 0) break; } return flow;}int maxflow() { int flow = 0; while (bfs()) { flow += dfs(s, inf); } return flow;} 数学 ¶ 快速幂 卡速米 123456789101112ll ksm(ll a, ll n, ll p) { ll ret = 1; a %= p; while (n) { if (n &amp; 1) { (ret *= a) %= p; } n &gt;&gt;= 1; (a *= a) %= p; } return ret;} ¶ 矩阵 1234567891011121314151617181920212223242526272829303132333435363738struct matrix { int MOD = 1000000007, a[110][110], m, n; // edit void init(const int &amp;nM, const int &amp;nN){ std::memset(this-&gt;a, 0, sizeof(this-&gt;a)); this-&gt;m = nM; this-&gt;n = nN; } matrix operator=(const matrix &amp;s){ this-&gt;init(s.m, s.n); for (int i = 0; i &lt;= s.m; ++i) for (int j = 0; j &lt;= s.n; ++j) this-&gt;a[i][j] = s.a[i][j]; return *this; } matrix operator*(const matrix &amp;s){ matrix ans; ans.init(this-&gt;m, s.n); for (int i = 1; i &lt;= this-&gt;m; ++i){ for (int j = 1; j &lt;= s.n; ++j){ for (int k = 1; k &lt;= this-&gt;n; ++k){ ans.a[i][j] += (long long)this-&gt;a[i][k]%MOD*((long long)s.a[k][j]%MOD)%MOD; } } } return ans; }};std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const matrix &amp;s){ for (int i = 1; i &lt;= s.m; ++i){ out &lt;&lt; '['; for (int j = 1; j &lt;= s.n-1; ++j){ out &lt;&lt; s.a[i][j] &lt;&lt; ' '; } out &lt;&lt; s.a[i][s.n]; out &lt;&lt; &quot;]\\n&quot;; } return out;} ¶ FFT 快速傅里叶变换 ¶ NTT 数论变换 ¶ 扩展欧几里得 ax+by=gcd⁡(a,b)=gcd⁡(b,a%b)=bx′+(a%b)y′=bx′+(a−⌊ab⌋∗b)y′ ax + by = \\gcd(a,b) = \\gcd(b, a\\% b) = bx'+(a\\%b)y' = bx' +(a-\\lfloor \\frac{a}{b}\\rfloor*b)y' ax+by=gcd(a,b)=gcd(b,a%b)=bx′+(a%b)y′=bx′+(a−⌊ba​⌋∗b)y′整理 a(x−y′)+b(y−x′+⌊ab⌋)=0 a(x-y')+b(y-x'+\\lfloor\\frac{a}{b}\\rfloor) = 0 a(x−y′)+b(y−x′+⌊ba​⌋)=0一组显然的解是 {x=y′y=x′−⌊ab⌋y′ \\left\\{ \\begin{aligned} x &amp;= y'\\\\ y &amp;= x'-\\lfloor\\frac{a}{b}\\rfloor y' \\end{aligned} \\right. ⎩⎪⎨⎪⎧​xy​=y′=x′−⌊ba​⌋y′​b=0b = 0b=0 时，解为 $\\left{ \\begin{aligned} x &amp;= a’\\ y &amp;= 0 \\end{aligned} \\right.$ 递归处理即可 ¶ 乘法逆元 ppp 为质数，有 ap−2×a=1mod pa^{p-2} \\times a = 1 \\mod{p}ap−2×a=1modp 故可用快速幂处理","link":"/archives/OI%E6%A8%A1%E6%9D%BF"},{"title":"再见，2018  你好，2019","text":"¶ 总结 在这一年还是发生了许许多多值得纪念的事 发现效实没有那么好（其实食堂差了好多 竞赛也走上了正轨，认识了很多 dalao 认识了许多有趣的人 发现周围的同学都好强 发现我最弱 发现我真的不擅长文科 发现我理科也不好 ¶ 期望 我能早日脱离蒟蒻的名号 好好背文科 理科多刷题 感受数学之美 多读书 以上。","link":"/archives/bye2018"},{"title":"抢占式调度与分抢占式调度的区别","text":"¶ 底层原理 CPU 定期接受定时器中断，调用由操作系统指定的中断处理函数，操作系统根据策略调度运行进程。 ¶ 区别 ¶ 抢占式调度 抢占式调度是一种调度方法，在该方法中，每个任务都分配有优先级。 一种简单的调度策略是完全按照优先级调度，高优先级任务会抢占低优先级任务的 CPU 时间。 即使较低优先级的任务仍在运行，若有等待中的任务比正在运行的任务优先级高，操作系统会中断低优先级任务，让高优先级任务运行。 ¶ 什么是非抢占式调度 在这种调度方法中，操作系统不会主动打断进程运行。只有在当前进程终止或者主动让出 CPU 时间，操作系统才会进行任务调度。 这是可用于各种硬件平台的唯一方法。这是因为它不需要抢先式调度之类的专用硬件（例如计时器）。 ¶ 总结 抢占式调度有一个由定时器中断周期性调用的调度器。它强制当前进程暂停并切换到最高优先级的进程执行。 非抢占式调度并不强迫进程切换。进程必须自愿放弃对内核的控制，以允许其他进程执行。 ¶ 例子 在非抢占式SJF调度中，一旦将CPU周期分配给进程，进程便将其保持到达到等待状态或终止为止。 考虑以下五个过程，每个过程都有自己独特的突发时间和到达时间。 处理队列 爆发时间 到达时间 P1 6 2 P2 2 5 P3 8 1 P4 3 0 P5 4 4 步骤0）在时间=0时，P4到达并开始执行。 步骤1）在时间=1，过程P3到达。但是，P4仍需要2个执行单元才能完成。它将继续执行。 步骤2）在时间=2，过程P1到达并添加到等待队列中。P4将继续执行。 步骤3）在时间=3，过程P4将完成其执行。比较P3和P1的突发时间。执行过程P1是因为其突发时间比P3少。 步骤4）在时间=4，过程P5到达并添加到等待队列中。P1将继续执行。 步骤5）在时间=5，过程P2到达并添加到等待队列中。P1将继续执行。 步骤6）在时间=9，进程P1将完成其执行。比较P3，P5和P2的突发时间。执行过程P2是因为其突发时间最短。 步骤7）在时间=10，P2正在执行，P3和P5在等待队列中。 步骤8）在时间=11，过程P2将完成其执行。比较P3和P5的突发时间。执行处理P5是因为其突发时间较短。 步骤9）在时间=15，过程P5将完成其执行。 步骤10）在时间=23，过程P3将完成其执行。 ¶ 优缺点 ¶ 抢占式调度 优势 抢占式调度方法更加健壮，可以使一个进程无法独占 CPU 每次中断后都重新考虑运行任务的选择 每个事件都会导致正在运行的任务中断 操作系统确保所有正在运行的进程的 CPU 使用率相同。 在这种情况下，CPU 的使用是相同的，即所有正在运行的进程将平均使用 CPU 改善了平均响应时间 将其用于并行环境时，抢占式调度将非常有用 缺陷 有调度开销 调度程序需要更长的时间来挂起正在运行的任务，切换上下文并调度新的传入任务 如果某些高优先级进程连续到达，则低优先级进程需要等待更长的时间 ¶ 非抢占式调度的优势 优势 提供低调度成本 倾向于提供高吞吐量 概念非常简单 调度所需的计算资源更少 缺陷 错误可能导致机器冻结 实时和优先级调度困难","link":"/archives/preemptive-scheduling"},{"title":"初赛复习","text":"¶ 知识点 P Problem: 对于任意的输入规模n，问题都可以在n的多项式时间内得到解决； NP(Non-deterministic Polynomial) Problem: 可以在多项式的时间里验证一个解的问题； NPC(Non-deterministic Polynomial Complete) Problem: 满足两个条件 (1)是一个NP问题 (2)所有的NP问题都可以约化到它 NP-Hard Problem: 满足NPC问题的第二条，但不一定要满足第一条 （ AB ）属于 NP 类问题。 存在一个 P 类问题 任何一个 P 类问题 任何一个不属于 P 类的问题 任何一个在（输入规模的）指数时间内能够解决的问题 主定理 T(n)=aT(n/b)+f(n) T(n)=aT(n/b)+f(n) T(n)=aT(n/b)+f(n)考虑 A(n)=nlog⁡baA(n)=n^{\\log_b a}A(n)=nlogb​a 和 f(n)f(n)f(n) 的大小 f(n)&lt;A(n)f(n)&lt;A(n)f(n)&lt;A(n) ， O(A(n))O(A(n))O(A(n)) f(n)=A(n)log⁡knf(n)=A(n)\\log^k nf(n)=A(n)logkn ， O(A(n)log⁡k+1n)O(A(n)\\log^{k+1}n)O(A(n)logk+1n) f(n)&gt;A(n),∃ c&lt;1,af(n/b)&lt;cf(n)f(n)&gt;A(n),\\exist\\;c&lt;1, af(n/b)&lt;cf(n)f(n)&gt;A(n),∃c&lt;1,af(n/b)&lt;cf(n) ， O(f(n))O(f(n))O(f(n)) 原反补 补=反+1 原地排序、稳定排序、复杂度 特殊二叉树定义 满二叉树(Full Binary Tree)： 要么是叶子结点(结点的度为0)，要么结点同时具有左右子树(结点的度为2) 完全二叉树(Complete Binary Tree)： 每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点。 完美二叉树(Perfect Binary Tree) 所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。 完全二叉树共有2*N-1个结点，则它的叶节点数是（ C ）。 A. N-1 B. 2*N C. N D. 2N-1 E. N/2 排列组合 书架上有21本书，编号从1到21，从其中选4本，其中每两本的编号都不相邻的选法一共有___3060___种。 ∑i=15ai=21−4=17a1,a5≥0,a2,a3,a4&gt;0(17+2−15−1)=3060 \\begin{aligned} \\sum_{i=1}^5 a_i = 21-4=17\\\\ a_1,a_5\\ge 0, a_2,a_3,a_4&gt;0\\\\ \\binom{17+2-1}{5-1}=3060 \\end{aligned} i=1∑5​ai​=21−4=17a1​,a5​≥0,a2​,a3​,a4​&gt;0(5−117+2−1​)=3060​1,1,2,4,8,8 组成的不同四位数个数：102 错排 Dn=(n−1)(Dn−2+Dn−1)D_n = (n-1)(D_{n-2}+D_{n-1})Dn​=(n−1)(Dn−2​+Dn−1​) 特征根 f0=0,f1=1,fn+1=(fn+fn−1)/2f_0=0, f_1=1,f_{n+1}=(f_n+f_{n-1})/2f0​=0,f1​=1,fn+1​=(fn​+fn−1​)/2 lim⁡n→∞fn=?\\lim_{n\\rightarrow\\infin} f_n=?limn→∞​fn​=? 欧拉图/欧拉路 欧拉路：不重不漏经过每一条边 恰好有两个点度数为奇 欧拉回路：存在欧拉路起点重点相同 欧拉图 G 是指可以构成一个闭回路的图 每个点度数为偶 ，且图G的每一条边恰好在这个闭回路上出现一次（即一笔画成）。在以下各个描述中, 不一定是欧拉图的是：（ D ）。 图G中没有度为奇数的顶点 包括欧拉环游的图(欧拉环游是指通过图中每边恰好一次的闭路径) 包括欧拉闭迹的图(欧拉迹是指通过途中每边恰好一次的路径) 存在一条回路, 通过每个顶点恰好一次 本身为闭迹的图 图灵停机 一个无法靠自身的控制终止的循环称为“死循环”，例如在C语言程序中，语句“while(1)printf(&quot;&quot;)；”就是一个死循环，运行它将无休止地打印号。下面关于死循环的说法中, 只有（ A ）是正确的。 不存在一种算法, 对任何一个程序及相应的输入数据, 都可以判断是否会出现死循环, 因而, 任何编译系统都不做死循环检查 有些编译系统可以检测出死循环 死循环属于语法错误， 既然编译系统能检查各种语法错误， 当然也能检查出死循环 死循环与多进程中出现的“死锁”差不多，而死锁是可以检测的，因而，死循环也是可以检测的 对于死循环，只能等到发生时做现场处理, 没有什么更积极的手段 杂项 面向对象程序设计（Object-Oriented Programming）是一种程序设计的方法论，它将对象作为程序的基本单元，将数据和程序封装在对象中，以提高软件的重用性、灵活性和扩展性。下面关于面向对象程序设计的说法中，正确的是（ BCD ）。 面向对象程序设计通常采用自顶向下设计方法进行设计。 面向对象程序设计方法具有继承性（inheritance）、封装性（encapsulation）、多态性（polymorphism）等几大特点。 支持面向对象特性的语言称为面向对象的编程语言，目前较为流行的有C++、JAVA、C#等。 面向对象的程序设计的雏形来自于Simula语言，后来在SmallTalk语言的完善和标准化的过程中得到更多的扩展和对以前思想的重新注解。至今，SmallTalk语言仍然被视为面向对象语言的基础。 在关系数据库中, 存放在数据库中的数据的逻辑结构以( E )为主。 A. 二叉树 B. 多叉树 C. 哈希表 D. B+树 E. 二维表 命题“P→Q”可读做P蕴含Q， 其中P、Q是两个独立的命题. 只有当命题P成立而命题Q不成立时， 命题&quot;P→Q&quot;的值为false， 其它情况均为true. 与命题&quot;P→Q&quot;等价的逻辑关系式是（ AD ）。 A. ﹁ P∨Q B. P∧Q C. ﹁ (P∨Q) D. ﹁(﹁Q∧P ) 堆排序实现 前缀/后缀表达式 前缀表达式 “+ 3 * 2 + 5 12” = 37 表达式a*(b+c)-d的后缀表达式是：B A. abcd*± B. abc+d- C. abc+d- D. -+*abcd ¶ 错题本 （矩阵中的数字）有一个 n*n(1&lt;=n&lt;=5000) 的矩阵 aaa ， 对于 1 &lt;= i &lt; n , 1&lt;=j&lt;=n, a[i,j] &lt; a[i + 1,j] a[j,i] &lt; a[j,i+1]。即矩阵中左右相邻的两个元素，右边的元素一定比左边的大。上下相邻的两个元素，下面的元素一定比上面的大。给定矩阵a中的一个数字k，找出k所在的行列（注意：输入数据保证矩阵中的数各不相同）。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int n,k,answerx,answery;int a[5001][5001];void FindKPosition(){ int i = n,j = n; while (j &gt; 0) { if (a[n][j] &lt; k) break; j --; } ① while (a[i][j] != k) { while ( ② &amp;&amp; i &gt; 1) i --; while ( ③ &amp;&amp; j &lt;= n) j ++; } ④ ⑤ }int main(){ int i,j; cin &gt;&gt; n; for (i = 1;i &lt;= n;i ++) for (j = 1;j &lt;= n;j ++) cin &gt;&gt; a[i][j]; cin &gt;&gt; k; FindKPosition(); cout &lt;&lt; answerx &lt;&lt; &quot; &quot; &lt;&lt; answery &lt;&lt; endl; return 0;}① j++; (或者 j+=1;或者j=j+1;)② a[i][j] &gt; k③ a[i][j] &lt; k④ answerx = i;⑤ answery = j; 第 K 大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;int a[1000001],n,ans = -1;void swap(int &amp;a,int &amp;b){ int c; c = a; a = b; b = c;}int FindKth(int left, int right, int n){ int tmp,value,i,j; if (left == right) return left; tmp = rand()% (right - left) + left; swap(a[tmp],a[left]); value = ① i = left; j = right; while (i &lt; j) { while (i &lt; j &amp;&amp; ② ) j --; if (i &lt; j) {a[i] = a[j]; i ++;} else break; while (i &lt; j &amp;&amp; ③ ) i ++; if (i &lt; j) {a[j] = a[i]; j --;} else break; } ④ if (i &lt; n) return FindKth( ⑤ ); if (i &gt; n) return ⑥ return i;}int main(){ int i; int m = 1000000; for (i = 1;i &lt;= m;i ++) cin &gt;&gt; a[i]; cin &gt;&gt; n; ans = FindKth(1,m,n); cout &lt;&lt; a[ans]; return 0;}① a[left];② a[j] &lt; value (或a[j] &lt;= value)③ a[i] &gt; value （或a[i] &gt;= value）④ a[i] = value;⑤ i + 1,right,n⑥ FindKth(left, i – 1, n); N个人在操场里围成一圈，将这N个人按顺时针方向从1到N编号，然后从第一个人起，每隔一个人让下一个人离开操场，显然，第一轮过后，具有偶数编号的人都离开了操场。依次做下去，直到操场只剩下一个人，记这个人的编号为J(N)，例如，J(5)=3，J(10)=5，等等。 J(400) = 289 （提示：对N=2m+r进行分析，其中0≤r&lt;2m）。 同时查找 2n2n2n 个数中的最大值和最小值，最小比较次数 3n−23n-23n−2 1 到 2015 不能被 4,5,6 中任意一个数整除的数个数：1075 a,b∈[0,31] a×b=(aor⁡b)×(aand⁡b)a,b\\in[0,31]\\; a\\times b=(a\\operatorname{or}b)\\times (a\\operatorname{and} b)a,b∈[0,31]a×b=(aorb)×(aandb) 解的个数 454 一只小猪要买 N 件物品（N 不超过 1000）。 它要买的所有物品在两家商店里都有卖。第 i 件物品在第一家商店的价格是 a[i] ，在第二家商店的价格是 b[i] ，两个价格都不小于 0 且不超过 10000。如果在第一家商店买的物品的总额不少于 50000，那么在第一家店买的物品都可以打 95 折(价格变为原来的 0.95 倍)。 求小猪买齐所有物品所需最少的总额。 输入：第一行一个数 N。接下来N 行，每行两个数。第 i 行的两个数分别代表 a[i]，b[i]。 输出：输出一行一个数，表示最少需要的总额，保留两位小数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int Inf = 1000000000;const int threshold = 50000;const int maxn = 1000;int n, a[maxn], b[maxn];bool put_a[maxn];int total_a, total_b;double ans;int f[threshold];int main() { scanf(&quot;%d&quot;, &amp;n); total_a = total_b = 0; for (int i = 0; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, a + i, b + i); if (a[i] &lt;= b[i]) total_a += a[i]; else total_b += b[i]; } ans = total_a + total_b; total_a = total_b = 0; for (int i = 0; i &lt; n; ++i) { if ( ① ) { put_a[i] = true; total_a += a[i]; } else { put_a[i] = false; total_b += b[i]; } } if ( ② ) { printf(&quot;%.2f&quot;, total_a * 0.95 + total_b); return 0; } f[0] = 0; for (int i = 1; i &lt; threshold; ++i) f[i] = Inf; int total_b_prefix = 0; for (int i = 0; i &lt; n; ++i) if (!put_a[i]) { total_b_prefix += b[i]; for (int j = threshold - 1; j &gt;= 0; --j) { if ( ③ &gt;= threshold &amp;&amp; f[j] != Inf) ans = min(ans, (total_a + j + a[i]) * 0.95 + ④ ); f[j] = min(f[j] + b[i], j &gt;= a[i] ? ⑤ : Inf); } } printf(&quot;%.2f&quot;, ans); return 0;}a[i]*0.95 &lt;= b[i]total_a &gt;= 50000total_a + j + a[i]f[j] + total_b - total_b_prefixf[j - a[i]] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;string s;long long magic(int l, int r) { long long ans = 0; for (int i = l; i &lt;= r; ++i) { ans = ans * 4 + s[i] - ‘a’ + 1; }return ans;}int main() { cin &gt;&gt; s; int len = s.length(); int ans = 0; for (int l1 = 0; l1 &lt; len; ++l1) { for (int r1 = l1; r1 &lt; len; ++r1) { bool bo = true; for (int l2 = 0; l2 &lt; len; ++l2) { for (int r2 = l2; r2 &lt; len; ++r2) { if (magic(l1, r1) == magic(l2, r2) &amp;&amp; (l1 != l2 || r1 != r2)) bo = false; } } if (bo) { ans += 1; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}input: abacabaouput: 16 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int lps(string seq, int i, int j){ int len1, len2; if (i == j) return 1; if (i &gt; j) return 0; if (seq[i] == seq[j]) return lps(seq, i + 1, j - 1) + 2; len1 = lps(seq, i, j - 1); len2 = lps(seq, i + 1, j); if (len1 &gt; len2) return len1; return len2;}int main(){ string seq = &quot;acmerandacm&quot;; int n = seq.size(); cout &lt;&lt; lps(seq, 0, n - 1) &lt;&lt; endl; return 0;}output: 5 对下图使用Dijkstra算法计算S点到其余各点的最短路径长度时，到B点的距离d[B]初始时赋为8，在算法的执行过程中还会出现的值有（ BCD ）。 A. 3 B. 7 C. 6 D. 5 关于计算机内存下面的说法哪些是正确的：BD 随机存储器（RAM）的意思是当程序运行时，每次具体分配给程序的内存位置是随机而不确定的。 一般的个人计算机在同一时刻只能存/取一个特定的内存单元。 计算机内存严格说来包括主存（memory）、高速缓存（cache）和寄存器（register）三个部分。 1MB内存通常是指1024*1024字节大小的内存。","link":"/archives/%E5%88%9D%E8%B5%9B%E5%A4%8D%E4%B9%A0"},{"title":"新的旅程","text":"初中结束了。 保送了效实东部 CRV新风系统，中央空调我来啦","link":"/archives/%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B"},{"title":"acejudge 教程","text":"A simple terminal OI/ACM answer checker on Linux/UNIX acejudge 是一个命令行的 judger 因为没有文档，所以写了一个指南 安装 12git clone git@github.com:laekov/acejudge.git &amp;&amp; cd acejudgemake &amp;&amp; sudo make install 使用 ¶ 配置文件 假定配置文件名为 w.cfg 1234一个 printf 式的格式化字符串作为输入文件一个 printf 式的格式化字符串作为答案文件第一个数据编号 最后一个数据编号 时间(ms) 内存(MB)源程序名 当输入文件为 1.in 2.in ... 10.in 答案文件为 1.out 2.out ... 10.out 1234%d.in%d.out1 10 2000 512a.cpp 当数据放在 /tmp 文件夹，输入文件为 dat1.in dat2.in ... dat20.in 答案文件为 dat1.out dat2.out ... dat20.out 1234/tmp/dat%d.in/tmp/dat%d.out1 20 2000 512a.cpp acejudge -fast w.cfg 来运行 ¶ 例子 acejudge 也提供交互实现配置 ╭─chaigidel@chaigidel-pc /tmp/rec ╰─$ ls 10.in 10.out 1.in 1.out 2.in 2.out 3.in 3.out 4.in 4.out 5.in 5.out 6.in 6.out 7.in 7.out 8.in 8.out 9.in 9.out a.cpp ╭─chaigidel@chaigidel-pc /tmp/rec ╰─$ acejudge Ace Judge V3.0 Beta3 (Released 01/04 2015) by CDQZ_laekov C - Configure R - Run Q - Quit c C - Config problem L - Show cfg now E - Load existing cfg file W - Save cfg file c IO data format %d Input data sufix .in Output data sufix .out Begin - End 1 10 Time limit(ms) 2000 Memory limit(MB) 512 Ace Judge V3.0 Beta3 (Released 01/04 2015) by CDQZ_laekov C - Configure R - Run Q - Quit c C - Config problem L - Show cfg now E - Load existing cfg file W - Save cfg file w Cfg file name: w.cfg Ace Judge V3.0 Beta3 (Released 01/04 2015) by CDQZ_laekov C - Configure R - Run Q - Quit r Program name a.cpp Testing program: a.cpp Compile ok Test case 1 Accepted time: 1213 MS memory: 65116 KB Test case 2 Accepted time: 206 MS memory: 9488 KB Test case 3 Accepted time: 325 MS memory: 9492 KB Test case 4 Accepted time: 15 MS memory: 9280 KB Test case 5 Accepted time: 1428 MS memory: 60760 KB Test case 6 Accepted time: 1832 MS memory: 60308 KB Test case 7 Accepted time: 19 MS memory: 9224 KB Test case 8 Accepted time: 1918 MS memory: 60328 KB Test case 9 Accepted time: 1352 MS memory: 60348 KB Test case 10 Accepted time: 1337 MS memory: 60132 KB Score ratio: 100.00% Valid time used: 9645 ms Max memory used: 65116 KB Press any key to continue Ace Judge V3.0 Beta3 (Released 01/04 2015) by CDQZ_laekov C - Configure R - Run Q - Quit q ╭─chaigidel@chaigidel-pc /tmp/rec ╰─$ cat w.cfg %d.in %d.out 1 10 2000 512 a.cpp ╭─chaigidel@chaigidel-pc /tmp/rec ╰─$ acejudge -fast w.cfg Testing program: a.cpp Compile ok Test case 1 Accepted time: 1230 MS memory: 65120 KB Test case 2 Accepted time: 266 MS memory: 9524 KB Test case 3 Accepted time: 313 MS memory: 9392 KB Test case 4 Accepted time: 17 MS memory: 9312 KB Test case 5 Accepted time: 1450 MS memory: 60720 KB Test case 6 Accepted time: 1924 MS memory: 60372 KB Test case 7 Accepted time: 24 MS memory: 9248 KB Test case 8 Time limit exceeded Test case 9 Accepted time: 1487 MS memory: 60320 KB Test case 10 Accepted time: 1507 MS memory: 60164 KB Score ratio: 90.00% Valid time used: 8218 ms Max memory used: 65120 KB Press any key to continue","link":"/archives/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/acejudge%E6%95%99%E7%A8%8B"},{"title":"用 GitHub Actions 自动部署 Hexo","text":"忽然发现 GitHub Actions beta 的资格下来了，就想着折腾一下 顺便改了一下 Repo 的结构和部署脚本 12345原来chaigidel.github.io:hexo --&gt; Traivs CI --&gt; chaigidel.github.io:master现在blog_source:master --&gt; GitHub Actions --&gt; chaigidel.github.io:master GH_PAT 是 GitHub Presonal Access Token 勾上 Repo 权限就行 Page_repo 是 Chaigidel/chaigidel.github.io publish-to-gh-pages.sh123456789101112131415#!/bin/bashset -evremote_repo=&quot;https://${GH_PAT}@github.com/${Page_repo}.git&quot;remote_branch=&quot;master&quot;cd publicgit initgit config user.name &quot;GitHub Actions&quot;git config user.email &quot;github-actions-bot@users.noreply.github.com&quot;git add .git commit -m &quot;Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;` from ${GITHUB_REPOSITORY}&quot;git push --force &quot;${remote_repo}&quot; master:${remote_branch}echo &quot;Deploy complete&quot; 关于 secrets 的文档，在项目 settings-&gt;Secrets 里设置 .github/workflows/main.yml123456789101112131415161718192021222324252627282930name: CIon: push: branches: - masterjobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@master - uses: actions/setup-node@master with: node-version: 10.x - name: Install Dependencies run: | git submodule init git submodule update npm install -g hexo npm install - name: Clean run: hexo clean - name: Generate run: hexo generate - name: Checkdir run: ls ./public - name: Deploy env: GH_PAT: ${{ secrets.GH_PAT }} Page_repo: &quot;Chaigidel/chaigidel.github.io&quot; run: sh publish-to-gh-pages.sh","link":"/archives/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/githubactions_hexo"},{"title":"云服务器上乱七八糟的应用","text":"&nbsp;&nbsp;昼寝覚めたら夜になった by catzz 域名备案批下来了，服务器是阿里云的 9.5r/mon 用这个搭了一些小服务，全程使用 docker。所有 password/key/secret 用 QAQ 替代 用 nginx 进行反向代理 ¶ SSL 使用 acme.sh 管理 直接申请泛域名，详见 Wiki ¶ RSS 配合 RSSHub 使用 具体参见一站式解决方案 Awesome-TTRSS 安卓客户端是 Readably（求推荐其他 123456789101112131415161718192021222324252627282930313233343536373839404142434445version: &quot;3&quot;services: database.postgres: image: sameersbn/postgresql:latest container_name: postgres environment: - PG_PASSWORD=QAQ # please change the password - DB_EXTENSION=pg_trgm volumes: - ~/postgres/data/:/var/lib/postgresql/ # persist postgres data to ~/postgres/data/ on the host restart: always service.rss: image: wangqiru/ttrss:latest container_name: ttrss ports: - 181:80 environment: - SELF_URL_PATH=https://rss.chaigidel.ink/ # please change to your own domain - DB_HOST=database.postgres - DB_PORT=5432 - DB_NAME=ttrss - DB_USER=postgres - DB_PASS=QAQ # please change the password - ENABLE_PLUGINS=auth_internal,fever # auth_internal is required. Plugins enabled here will be enabled for all users as system plugins stdin_open: true tty: true restart: always command: sh -c 'sh /wait-for.sh database.postgres:5432 -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/' service.mercury: # set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page image: wangqiru/mercury-parser-api:latest container_name: mercury expose: - 3000 restart: always service.opencc: # set OpenCC API endpoint to `service.opencc:3000` on TTRSS plugin setting page image: wangqiru/opencc-api-server:latest container_name: opencc environment: NODE_ENV: production expose: - 3000 restart: always ¶ Aria2 这个要配合 nginx 和 nextcloud 使用 nginx 是为了保证 SSL 连接。nextcloud 是为了挂载外部存储 1234567891011121314151617181920212223242526272829303132333435map $http_upgrade $connection_upgrade { default upgrade; '' close;}server { listen 80; server_name aria2.chaigidel.ink; return 301 https://$server_name$request_uri;}server { listen 443 ssl; gzip on; server_name aria2.chaigidel.ink; ssl on; ssl_certificate /etc/nginx/ssl/chaigidel.ink.fullchain.cer; ssl_certificate_key /etc/nginx/ssl/chaigidel.ink.key; location / { proxy_pass http://localhost:6880; } location /jsonrpc { proxy_pass http://localhost:6800/jsonrpc; proxy_read_timeout 300s; proxy_send_timeout 300s; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; }} 12345678910111213141516version: &quot;3&quot;services: aria2: container_name: aria2 image: xujinkai/aria2-with-webui ports: - &quot;127.0.0.1:6800:6800&quot; - &quot;127.0.0.1:6880:80&quot; - &quot;6890-6999:6890-6999&quot; volumes: - &quot;/download:/data&quot; - &quot;/var/aria2/conf:/conf&quot; environment: SECRET: &quot;QAQ&quot; restart: always ¶ Nextcloud 注意连接时 host 填 db，详见 nextcloud/docker 12345678910111213141516171819202122232425262728293031version: '2'volumes: nextcloud: db:services: db: image: mariadb command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW restart: always volumes: - db:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=QAQ - MYSQL_PASSWORD=QAQ - MYSQL_DATABASE=nextcloud - MYSQL_USER=nextcloud app: image: nextcloud ports: - 127.0.0.1:8372:80 links: - db volumes: - nextcloud:/var/www/html - /download:/aria2 depends_on: - db restart: always 12345678910111213141516171819202122232425262728293031323334upstream nextcloud { server 127.0.0.1:8372;}server { listen 80; server_name cloud.chaigidel.ink; return 301 https://$server_name$request_uri;}server { listen 443 ssl; gzip on; server_name cloud.chaigidel.ink; ssl on; ssl_certificate /etc/nginx/ssl/chaigidel.ink.fullchain.cer; ssl_certificate_key /etc/nginx/ssl/chaigidel.ink.key; location / { proxy_pass_header Authorization; proxy_pass http://nextcloud; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_buffering off; client_max_body_size 0; proxy_read_timeout 36000s; proxy_redirect off; proxy_ssl_session_reuse off; }} ¶ code-server 在线的 VS Code 123456789101112131415version: &quot;3&quot;services: code-server: container_name: code-server image: codercom/code-server:v2 ports: - &quot;8445:8080&quot; volumes: - &quot;${HOME}/project:/home/coder/project&quot; - &quot;${HOME}/.local/share/code-server:/home/coder/.local/share/code-server&quot; environment: PASSWORD: &quot;QAQ&quot; restart: always entrypoint: [&quot;dumb-init&quot;, &quot;code-server&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--cert&quot;] ¶ Gitea 参见 Docs ¶ Drone CI 不是很懂为什么叫 drone-agent 具体参见 Drone Docs 和 这里 12345678910111213141516171819202122232425262728293031323334353637version: '3'services: drone-server: image: drone/drone:1 ports: - 127.0.0.1:3243:443 - 127.0.0.1:3280:80 volumes: - drone-data:/data:rw restart: always environment: - DRONE_AGENTS_ENABLED=true - DRONE_GITEA_SERVER=https://git.chaigidel.ink - DRONE_GITEA_CLIENT_ID=QAQ - DRONE_GITEA_CLIENT_SECRET=QWQ - DRONE_RPC_SECRET=QAQ - DRONE_SERVER_HOST=drone.chaigidel.ink - DRONE_SERVER_PROTO=https drone-agent: image: drone/drone-runner-docker:1 restart: always depends_on: - drone-server volumes: - /var/run/docker.sock:/var/run/docker.sock:rw environment: - DRONE_RPC_PROTO=http - DRONE_RPC_HOST=drone-server - DRONE_RPC_SECRET=QAQ - DRONE_RUNNER_NAME=runner1 - DRONE_RUNNER_CAPACITY=2volumes: drone-data:","link":"/archives/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/server"},{"title":"矩阵","text":"http://www.matrix67.com/blog/archives/276 https://wenku.baidu.com/view/3a9d780feff9aef8941e06b6.html","link":"/archives/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5"},{"title":"行列式","text":"¶ 定义 SnS_nSn​ 表示 {1,2,⋯ ,n}\\{1,2,\\cdots,n\\}{1,2,⋯,n} 上所有排列的集合 定义函数 N(σ)N(\\sigma)N(σ) 表示 σ\\sigmaσ 这个序列中逆序对的个数 定义函数 sgn(σ)=(−1)N(σ)\\mathrm{sgn}(\\sigma) = (-1)^{N(\\sigma)}sgn(σ)=(−1)N(σ) 具体来说 S3={(123),(132),(213),(231),(312),(321)} \\begin{aligned} S_3 = \\{ &amp;\\left(\\begin{array}{cccc} 1 &amp; 2 &amp;3 \\end{array}\\right), \\\\ &amp;\\left(\\begin{array}{cccc} 1 &amp; 3 &amp;2 \\end{array}\\right), \\\\ &amp;\\left(\\begin{array}{cccc} 2 &amp; 1 &amp;3 \\end{array}\\right), \\\\ &amp;\\left(\\begin{array}{cccc} 2 &amp; 3 &amp; 1 \\end{array}\\right), \\\\ &amp;\\left(\\begin{array}{cccc} 3 &amp; 1 &amp;2 \\end{array}\\right), \\\\ &amp;\\left(\\begin{array}{cccc} 3 &amp; 2 &amp; 1 \\end{array}\\right)\\} \\end{aligned} S3​={​(1​2​3​),(1​3​2​),(2​1​3​),(2​3​1​),(3​1​2​),(3​2​1​)}​假如 σ=(312)∈S4 \\sigma=\\left(\\begin{array}{cccc} 3 &amp; 1 &amp;2 \\end{array}\\right)\\in S_4 σ=(3​1​2​)∈S4​则 sgn(σ)=2\\mathrm{sgn}(\\sigma)=2sgn(σ)=2 ¶ 一般的 ∣a1,1⋯a1,n⋮⋱⋮an,1⋯an,n∣=∑σ∈Sn(sgn(σ)∏i=1nai,σ(i)) \\begin{vmatrix} a_{1,1} &amp; \\cdots &amp; a_{1,n} \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n,1} &amp; \\cdots &amp; a_{n,n} \\end{vmatrix} = \\sum_{\\sigma\\in S_n} (\\mathrm{sgn}(\\sigma) \\prod_{i=1}^n a_{i,\\sigma(i)}) ∣∣∣∣∣∣∣∣​a1,1​⋮an,1​​⋯⋱⋯​a1,n​⋮an,n​​∣∣∣∣∣∣∣∣​=σ∈Sn​∑​(sgn(σ)i=1∏n​ai,σ(i)​)¶ 转置行列式 行列式 D=∣a1,1⋯a1,n⋮⋱⋮an,1⋯an,n∣=(ai,j) D=\\begin{vmatrix} a_{1,1} &amp; \\cdots &amp; a_{1,n} \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n,1} &amp; \\cdots &amp; a_{n,n} \\end{vmatrix}=(a_{i,j}) D=∣∣∣∣∣∣∣∣​a1,1​⋮an,1​​⋯⋱⋯​a1,n​⋮an,n​​∣∣∣∣∣∣∣∣​=(ai,j​)定义其转置行列式 DT=∣a1,1⋯an,1⋮⋱⋮a1,n⋯an,n∣=(bi,j)ai,j=bj,i D^T=\\begin{vmatrix} a_{1,1} &amp; \\cdots &amp; a_{n,1} \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{1,n} &amp; \\cdots &amp; a_{n,n} \\end{vmatrix}=(b_{i,j})\\\\ a_{i,j}=b_{j,i} DT=∣∣∣∣∣∣∣∣​a1,1​⋮a1,n​​⋯⋱⋯​an,1​⋮an,n​​∣∣∣∣∣∣∣∣​=(bi,j​)ai,j​=bj,i​¶ 二阶行列式 ∣a1,1a1,2a2,1a2,2∣=a1,1a2,2−a1,2a2,1 \\begin{vmatrix} a_{1,1} &amp; a_{1,2} \\\\ a_{2,1} &amp; a_{2,2} \\end{vmatrix} = a_{1,1} a_{2,2} - a_{1,2}a_{2,1} ∣∣∣∣∣​a1,1​a2,1​​a1,2​a2,2​​∣∣∣∣∣​=a1,1​a2,2​−a1,2​a2,1​¶ 三阶行列式 ∣a1,1a1,2a1,3a2,1a2,2a2,3a3,1a3,2a3,3∣=a1,1a2,2a3,3+a1,2a2,3a3,1+a1,3a2,1a3,2−a1,3a2,2a3,1−a1,1a2,3a3,2−a1,2a2,1a3,3 \\begin{vmatrix} a_{1,1} &amp; a_{1,2} &amp; a_{1,3} \\\\ a_{2,1} &amp; a_{2,2} &amp; a_{2,3} \\\\ a_{3,1} &amp; a_{3,2} &amp; a_{3,3} \\end{vmatrix} = a_{1,1}a_{2,2}a_{3,3} + a_{1,2}a_{2,3}a_{3,1}+ a_{1,3}a_{2,1}a_{3,2} - a_{1,3}a_{2,2}a_{3,1} - a_{1,1}a_{2,3}a_{3,2} - a_{1,2}a_{2,1}a_{3,3} ∣∣∣∣∣∣∣​a1,1​a2,1​a3,1​​a1,2​a2,2​a3,2​​a1,3​a2,3​a3,3​​∣∣∣∣∣∣∣​=a1,1​a2,2​a3,3​+a1,2​a2,3​a3,1​+a1,3​a2,1​a3,2​−a1,3​a2,2​a3,1​−a1,1​a2,3​a3,2​−a1,2​a2,1​a3,3​¶ 性质 对于行列式 DDD D=DTD=D^TD=DT 一行有公因子 kkk ，可以提取 kkk ∣⋮⋮⋮⋮kai,1kai,2…kai,n⋮⋮⋮⋮∣=k∣⋮⋮⋮⋮ai,1ai,2…ai,n⋮⋮⋮⋮∣ \\begin{vmatrix} \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ {\\color{blue}k}a_{i,1} &amp; {\\color{blue}k}a_{i,2} &amp; \\dots &amp; {\\color{blue}k}a_{i,n} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\end{vmatrix}= {\\color{blue}k}\\begin{vmatrix} \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ a_{i,1} &amp; a_{i,2} &amp; \\dots &amp; a_{i,n} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\end{vmatrix} ∣∣∣∣∣∣∣∣∣​⋮kai,1​⋮​⋮kai,2​⋮​⋮…⋮​⋮kai,n​⋮​∣∣∣∣∣∣∣∣∣​=k∣∣∣∣∣∣∣∣∣​⋮ai,1​⋮​⋮ai,2​⋮​⋮…⋮​⋮ai,n​⋮​∣∣∣∣∣∣∣∣∣​ 有一行或一列都为 000 ，则 D=0D=0D=0 ∣⋮⋮⋮⋮00…0⋮⋮⋮⋮∣=∣0⋮⋮⋮⋮⋮⋮⋮0⋮⋮⋮∣=0 \\begin{vmatrix} \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ {\\color{blue}0} &amp; {\\color{blue}0} &amp; \\dots &amp; {\\color{blue}0} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\end{vmatrix} =\\begin{vmatrix} {\\color{blue}0} &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ {\\color{blue}0} &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\end{vmatrix}=0 ∣∣∣∣∣∣∣∣∣​⋮0⋮​⋮0⋮​⋮…⋮​⋮0⋮​∣∣∣∣∣∣∣∣∣​=∣∣∣∣∣∣∣∣∣∣​0⋮0​⋮⋮⋮​⋮⋮⋮​⋮⋮⋮​∣∣∣∣∣∣∣∣∣∣​=0","link":"/archives/%E6%95%B0%E5%AD%A6/%E8%A1%8C%E5%88%97%E5%BC%8F"},{"title":"神奇的无旋 Treap ── FHQ-Treap","text":"本文将介绍一种平衡树 复杂度我不会证 实现非常简单 每个节点的定义如下，和普通 Treap 相同，比二叉搜索树多了 pri 优先级 1234567struct Node { int key, cnt, siz, pri; Node *ls, *rs; void upd() { siz = (ls ? ls-&gt;siz : 0) + (rs ? rs-&gt;siz : 0) + cnt; } int rank() { return (ls ? ls-&gt;siz : 0) + 1; }} T[N];typedef std::pair&lt;Node *, Node *&gt; pnn; ¶ 基本操作 ¶ 开点 pri 随机赋值 123456Node *gen(int x) { static int cnt = 0; T[cnt].cnt = 1, T[cnt].key = x, T[cnt].ls = T[cnt].rs = nullptr, T[cnt].siz = 1, T[cnt].pri = rnd(); return &amp;T[cnt++];} ¶ 分裂 ¶ 按权值分裂 将一棵根节点为 uuu 的树，分裂为两棵，一棵权值都 ≤k\\le k≤k，另一棵都 &gt;k&gt; k&gt;k 1234567891011121314pnn split(Node *u, int key) { if (u == nullptr) return {nullptr, nullptr}; if (u-&gt;key &gt; key) { pnn o = split(u-&gt;ls, key); u-&gt;ls = o.second; u-&gt;upd(); return {o.first, u}; } else { pnn o = split(u-&gt;rs, key); u-&gt;rs = o.first; u-&gt;upd(); return {u, o.second}; }} ¶ 按排名分裂 将一棵根节点为 uuu 的树，分裂为两棵，一棵排名都 ≤k\\le k≤k，另一棵都 &gt;k&gt; k&gt;k 删除第 kkk 小的时候比较有用 1234567891011121314pnn split_rank(Node *u, int k) { if (u == nullptr) return {nullptr, nullptr}; if (u-&gt;rank() &lt;= k) { pnn o = split_rank(u-&gt;rs, k - (u-&gt;rank() + u-&gt;r - u-&gt;l)); u-&gt;rs = o.first; u-&gt;upd(); return {u, o.second}; } else { pnn o = split_rank(u-&gt;ls, k); u-&gt;ls = o.second; u-&gt;upd(); return {o.first, u}; }} ¶ 合并 树 uuu 的权值均小于等于 vvv 12345678910111213Node *merge(Node *u, Node *v) { if (u == nullptr) return v; if (v == nullptr) return u; if (u-&gt;pri &gt; v-&gt;pri) { u-&gt;rs = merge(u-&gt;rs, v); u-&gt;upd(); return u; } else { v-&gt;ls = merge(u, v-&gt;ls); v-&gt;upd(); return v; }} ¶ 查询第 k 小 这个是普通搜索树的操作 当然如果用按排名分裂也是可以的 123456789int kth(Node *u, int k) { while (u-&gt;rank() != k) { if (u-&gt;rank() &lt; k) k -= u-&gt;rank(), u = u-&gt;rs; else u = u-&gt;ls; } return u-&gt;key;} ¶ 衍生操作 ¶ 插入 x 12o = split(rt, x);rt = merge(merge(o.first, gen(x)), o.second); ¶ 删除 x 1234o = split(rt, x);t = split(o.first, x - 1);t.second = merge(t.second-&gt;ls, t.second-&gt;rs);rt = merge(merge(t.first, t.second), o.second); ¶ x 的排名 注意 o.first 可能为空 123o = split(rt, x - 1);io.write((o.first ? o.first-&gt;siz : 0) + 1);merge(o.first, o.second); ¶ x 前驱 123o = split(rt, x - 1);io.write(kth(o.first, o.first-&gt;siz));merge(o.first, o.second); ¶ x 后继 123o = split(rt, x);io.write(kth(o.second, 1));merge(o.first, o.second); ¶ 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#define NDEBUG#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), pp(pbuf) { p2 = buf + fread(buf, 1, MAXSIZE, stdin); } ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;inline int rnd() { static int seed = 703; return seed = int(seed * 48271LL % 2147483647);}const int N = 150000;struct Node { int key, cnt, siz, pri; Node *ls, *rs; void upd() { siz = (ls ? ls-&gt;siz : 0) + (rs ? rs-&gt;siz : 0) + cnt; } int rank() { return (ls ? ls-&gt;siz : 0) + 1; }} T[N];typedef std::pair&lt;Node *, Node *&gt; pnn;Node *gen(int x) { static int cnt = 0; T[cnt].cnt = 1, T[cnt].key = x, T[cnt].ls = T[cnt].rs = nullptr, T[cnt].siz = 1, T[cnt].pri = rnd(); return &amp;T[cnt++];}pnn split(Node *u, int key) { if (u == nullptr) return {nullptr, nullptr}; if (u-&gt;key &gt; key) { pnn o = split(u-&gt;ls, key); u-&gt;ls = o.second; u-&gt;upd(); return {o.first, u}; } else { pnn o = split(u-&gt;rs, key); u-&gt;rs = o.first; u-&gt;upd(); return {u, o.second}; }}Node *merge(Node *u, Node *v) { if (u == nullptr) return v; if (v == nullptr) return u; if (u-&gt;pri &gt; v-&gt;pri) { u-&gt;rs = merge(u-&gt;rs, v); u-&gt;upd(); return u; } else { v-&gt;ls = merge(u, v-&gt;ls); v-&gt;upd(); return v; }}int kth(Node *u, int k) { assert(u != nullptr); while (u-&gt;rank() != k) { if (u-&gt;rank() &lt; k) k -= u-&gt;rank(), u = u-&gt;rs; else u = u-&gt;ls; assert(u != nullptr); } assert(u != nullptr); return u-&gt;key;}void print(Node *u) { if (u == nullptr) return; print(u-&gt;ls); cerr &lt;&lt; u-&gt;key &lt;&lt; ' '; print(u-&gt;rs);}const int inf = 1e8;int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n; io.read(n); Node *rt = nullptr; // int itm = 0; while (n--) { int opt, x; io.read(opt), io.read(x); pnn o, t; // cerr &lt;&lt; (++itm) &lt;&lt; endl; switch (opt) { case 1: // insert o = split(rt, x); rt = merge(merge(o.first, gen(x)), o.second); break; case 2: // del o = split(rt, x); t = split(o.first, x - 1); t.second = merge(t.second-&gt;ls, t.second-&gt;rs); rt = merge(merge(t.first, t.second), o.second); break; case 3: // x's rank o = split(rt, x - 1); io.write((o.first ? o.first-&gt;siz : 0) + 1, '\\n'); merge(o.first, o.second); break; case 4: // whose rank is x io.write(kth(rt, x), '\\n'); break; case 5: // pre o = split(rt, x - 1); io.write(kth(o.first, o.first-&gt;siz), '\\n'); merge(o.first, o.second); break; case 6: // nxt o = split(rt, x); io.write(kth(o.second, 1), '\\n'); merge(o.first, o.second); break; } // print(rt); // cerr &lt;&lt; endl; } return 0;}","link":"/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/fhq-treap"},{"title":"更优雅的线段树","text":"线段树原理非常简单，但如何优雅的实现却是一个问题 ¶ 线段树简介 线段树就是把一个序列原有 nnn 个点扩充为 nlog⁡nn\\log nnlogn 个点，保持一定结构进行加速 每个点有 自己管辖的区域 两个拼起来是自己的子节点（ self=lson∪rsonself = lson \\cup rsonself=lson∪rson ） 子节点不交（ lson∩rson=∅lson \\cap rson = \\varnothinglson∩rson=∅ ） 可以快速的区间合并 ¶ 实现 个人喜欢写结构体和指针 自定义一个 null 可能是避免代码冗长的一个办法（否则到处判 == NULL ） 但是这样的话好像有些函数得分开写 查询区间 [L,R][L,R][L,R] 用全局变量存可以减少参数传递 P3372 【模板】线段树 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;typedef long long ll;const int N = 100000;struct Node { ll sum, tag; int l, r; Node *ls, *rs; inline int len(); void maintain(); void pushdown(); ll query(); void add(); Node *build(int, int); void print();};Node T[N * 4];Node *null;int cnt = 1, L, R, X;int Node::len() { return r - l + 1; }void Node::maintain() { sum = ls-&gt;sum + rs-&gt;sum; }void Node::pushdown() { ls-&gt;tag += tag, rs-&gt;tag += tag; ls-&gt;sum += ls-&gt;len() * tag, rs-&gt;sum += rs-&gt;len() * tag; tag = 0; null-&gt;sum = null-&gt;tag = 0;}ll Node::query() { if (L &lt;= l &amp;&amp; r &lt;= R) return sum; if (r &lt; L || R &lt; l) return 0; pushdown(); return ls-&gt;query() + rs-&gt;query();}void Node::add() { if (r &lt; L || R &lt; l) return; if (L &lt;= l &amp;&amp; r &lt;= R) tag += X, sum += len() * X; else pushdown(), ls-&gt;add(), rs-&gt;add(), maintain();}Node *Node::build(int l, int r) { Node *ret = &amp;T[cnt++]; ret-&gt;l = l, ret-&gt;r = r, ret-&gt;ls = ret-&gt;rs = null; if (l == r) cin &gt;&gt; ret-&gt;sum; else { int mid = (l + r) / 2; ret-&gt;ls = build(l, mid), ret-&gt;rs = build(mid + 1, r); ret-&gt;maintain(); } return ret;}void Node::print() { if (this == null) return; cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; tag &lt;&lt; endl; ls-&gt;print(), rs-&gt;print();}int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n, m; null = T; null-&gt;ls = null-&gt;rs = null; cin &gt;&gt; n &gt;&gt; m; Node *rt = null-&gt;build(1, n); L = 1, R = n; while (m--) { int opt; cin &gt;&gt; opt &gt;&gt; L &gt;&gt; R; if (opt == 1) { cin &gt;&gt; X; rt-&gt;add(); } else cout &lt;&lt; rt-&gt;query() &lt;&lt; '\\n'; } return 0;}","link":"/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91"},{"title":"一种用化齐次解决圆锥曲线定点定值问题的方法","text":"感谢我的老师。 基本思想是把 y=kx+by=kx+by=kx+b 变换成 y−kxb=1\\frac{y-kx}{b}=1by−kx​=1 来代换。 ¶ 引例 抛物线 C:y2=xC:y^2=xC:y2=x 上有点 A(1,1)A(1,1)A(1,1)，过 P(3,−1)P(3,-1)P(3,−1) 直线交 CCC 于 M,NM,NM,N 两点，令 k1=kAM,k2=kANk_1=k_{AM},k_2=k_{AN}k1​=kAM​,k2​=kAN​。 试证：k1⋅k2k_1\\cdot k_2k1​⋅k2​ 为定值。 浙江 2017 年 4 月学考 作为一个简单学考题，想必大家都是会做的。 k1k2=y1−1x1−1y2−1x2−1=1y1y2+y1+y2+1=−12 k_1k_2=\\frac{y_1-1}{x_1-1}\\frac{y_2-1}{x_2-1}=\\frac{1}{y_1y_2+y_1+y_2+1}=-\\frac{1}{2} k1​k2​=x1​−1y1​−1​x2​−1y2​−1​=y1​y2​+y1​+y2​+11​=−21​讨论另一种方法 我们观察 y2=xy^2=xy2=x，发现可以在右侧将 111 化为直线方程，使等式齐次，然后除 x2x^2x2，通过韦达定理得到 k1k2,k1+k2k_1k_2,k_1+k_2k1​k2​,k1​+k2​ 但在此题中，不难发现直接除 x2x^2x2 会构造出 yx\\frac{y}{x}xy​，并不是想要的 k1,k2k_1,k_2k1​,k2​ 故需进行换元（或者说把一部分看成整体） 考虑到 k1=y1−1x1−1,k2=y2−1x2−1k_1=\\frac{y_1-1}{x_1-1},k_2=\\frac{y_2-1}{x_2-1}k1​=x1​−1y1​−1​,k2​=x2​−1y2​−1​ 令 u=x−1v=y−1 \\begin{aligned} u &amp;= x-1\\\\ v &amp;= y-1 \\end{aligned} uv​=x−1=y−1​设直线 MN:u=mv+nMN:u=mv+nMN:u=mv+n 即 u−mvn=1\\frac{u-mv}{n}=1nu−mv​=1 对 y2=xy^2=xy2=x 换元，得 (v+1)2=u+1(v+1)^2=u+1(v+1)2=u+1 进行代换 (v+1)2=u+1v2+2v=uv2=(u−2v)=(u−2v)u−mvn \\begin{aligned} (v+1)^2 &amp;= u+1\\\\ v^2+2v&amp;=u\\\\ v^2=(u-2v)&amp;=(u-2v)\\frac{u-mv}{n}\\\\ \\end{aligned} (v+1)2v2+2vv2=(u−2v)​=u+1=u=(u−2v)nu−mv​​整理得 (2m−n)v2−(m+2)uv+u2=0 (2m-n)v^2-(m+2)uv+u^2=0 (2m−n)v2−(m+2)uv+u2=0同除 u2u^2u2 (2m−n)(uv)2−(m+2)(uv)+1=0 (2m-n)\\left(\\frac{u}{v}\\right)^2-(m+2)\\left(\\frac{u}{v}\\right)+1=0 (2m−n)(vu​)2−(m+2)(vu​)+1=0即 (2m−n)k2−(m+2)k+1=0 (2m-n)k^2-(m+2)k+1=0 (2m−n)k2−(m+2)k+1=0根据韦达定理，得 k1+k2=−m+22m−nk1k2=12m−n \\begin{aligned} k_1+k_2&amp;=-\\frac{m+2}{2m-n}\\\\ k_1k_2&amp;=\\frac{1}{2m-n}\\\\ \\end{aligned} k1​+k2​k1​k2​​=−2m−nm+2​=2m−n1​​将 P(3,1)P(3,1)P(3,1) 带入直线方程，得 2=−2m+n2=-2m+n2=−2m+n 所以 k1k2=−1/2k_1k_2=-1/2k1​k2​=−1/2 ¶ 另一个例子 E:x29+y2=1E:\\frac{x^2}{9}+y^2=1E:9x2​+y2=1，左右顶点为 A,BA,BA,B。PPP 为直线 x=6x=6x=6 上的动点。PAPAPA 与 EEE 的另一交点为 CCC, PBPBPB 与 EEE 的另一交点为 DDD。 试证：CDCDCD 过定点 2020 全国一卷 我们发现题目中没有显然的 k1+k2,k1k2k_1+k_2,k_1k_2k1​+k2​,k1​k2​ 需要自己构造。 令 kAP=kk_{AP}=kkAP​=k，不难发现 kBP=3kk_{BP}=3kkBP​=3k 根据椭圆的性质 kAC⋅kBC=e2−1k_{AC}\\cdot k_{BC}=e^2-1kAC​⋅kBC​=e2−1，可得到 kBC=−19kk_{BC}=-\\frac{1}{9k}kBC​=−9k1​ 则 kBC⋅kBD=−1/3k_{BC}\\cdot k_{BD} = -1/3kBC​⋅kBD​=−1/3 成功构造出了引例中的结构 接下来就是换元，设直线，根据韦达定理得到直线方程参数的关系，得到定点 (32,0)(\\frac{3}{2},0)(23​,0)。","link":"/archives/%E6%96%87%E5%8C%96%E8%AF%BE/conic-const-value-method"},{"title":"高中化学归纳","text":"反应条件 光照 HClO\\ce{HClO}HClO AgX+\\ce{Ag+}AgX+ （除 AgF\\ce{AgF}AgF） HNOX3\\ce{HNO3}HNOX3​ HX2,ClX2\\ce{H2, Cl2}HX2​,ClX2​ 放电 高温 催化剂，加热 HX2OX2\\ce{H2O2}HX2​OX2​ NX2+HX2\\ce{N2 + H2}NX2​+HX2​ SOX2+OX2\\ce{SO2 +O2}SOX2​+OX2​ MnOX2+KClOX3\\ce{MnO2 + KClO3}MnOX2​+KClOX3​ NHX3+OX2\\ce{NH3 + O2}NHX3​+OX2​ 无机物性质 NHX3, HCl, HNOX3\\ce{NH3,HCl,HNO3}NHX3​,HCl,HNOX3​ 易挥发 MgX3NX2\\ce{Mg3N2}MgX3​NX2​ 灰绿，M=100M=100M=100 实验 KMnOX4\\ce{KMnO4}KMnOX4​ 腐蚀橡胶 NaOH\\ce{NaOH}NaOH 腐蚀玻璃 控制流速（气泡数），控制反应气比例（掌握仪器）","link":"/archives/%E6%96%87%E5%8C%96%E8%AF%BE/%E5%BD%92%E7%BA%B3"},{"title":"椭圆","text":"¶ 定义 ¶ 定义一 ∣F1P∣+∣F2P∣=2a∣F1F2∣=2c |F_{1} P|+\\left|F_{2} P\\right|=2 a\\\\ \\left|F_{1} F_{2}\\right|=2 c\\\\ ∣F1​P∣+∣F2​P∣=2a∣F1​F2​∣=2cx2a2+y2b2=1(a&gt;b&gt;0) \\frac{x^{2}}{a^{2}}+\\frac{y^{2}}{b^{2}}=1 \\quad(a&gt;b&gt;0) a2x2​+b2y2​=1(a&gt;b&gt;0)∣PF1∣=a+ex∣PF2∣=a−ex \\begin{array}{l}{\\left|P F_{1}\\right|=a+e x} \\\\ {\\left|P F_{2}\\right|=a-e x}\\end{array}\\\\ ∣PF1​∣=a+ex∣PF2​∣=a−ex​¶ 定义二 ¶ 定义三 d=∣AA1∣∣F2P∣d=e&lt;1 d=|AA_1|\\\\ \\frac{|F_2P|}{d}=e&lt;1 d=∣AA1​∣d∣F2​P∣​=e&lt;1通径∣CD∣=2b2a 通径 |CD|=2\\frac{b^2}{a} 通径∣CD∣=2ab2​∣F2M∣=p=a2c−c=b2c |F_2M|=p=\\frac{a^2}{c}-c=\\frac{b^2}{c} ∣F2​M∣=p=ca2​−c=cb2​∣AF2∣=ep1+ecos⁡θ \\left|A F_{2}\\right|=\\frac{e p}{1+e \\cos \\theta}\\\\ ∣AF2​∣=1+ecosθep​∣BF2∣=ep1−ecos⁡θ \\left|B F_{2}\\right|=\\frac{e p}{1-e \\cos \\theta}\\\\ ∣BF2​∣=1−ecosθep​∣AB∣=2ep1−e2cos⁡2θ \\left|AB\\right|=\\frac{2 e p}{1-e^2 \\cos^2 \\theta}\\\\ ∣AB∣=1−e2cos2θ2ep​∣AF2∣∣BF2∣=1−ecos⁡θ1+ecos⁡θ \\frac{|AF_2|}{|BF_2|}=\\frac{1-e\\cos \\theta}{1+e\\cos \\theta} ∣BF2​∣∣AF2​∣​=1+ecosθ1−ecosθ​注意，通过控制 θ\\thetaθ 可以得出 ∣AB∣min=2b2a|AB|_{min}=2\\frac{b^2}{a}∣AB∣min​=2ab2​ ¶ 乱七八糟 ¶ 三角换元 x2a2+y2b2=1(xa)2+(yb)2=1 \\begin{aligned} \\frac{x^{2}}{a^{2}}+\\frac{y^{2}}{b^{2}} &amp;= 1 \\\\ \\left(\\frac{x}{a}\\right)^{2}+\\left(\\frac{y}{b}\\right)^{2} &amp;= 1 \\end{aligned}\\\\ a2x2​+b2y2​(ax​)2+(by​)2​=1=1​{x=a⋅cos⁡αy=b⋅sin⁡α {\\left\\{\\begin{aligned} {x=a \\cdot \\cos \\alpha} \\\\ {y=b \\cdot \\sin \\alpha} \\end{aligned}\\right.} {x=a⋅cosαy=b⋅sinα​¶ 点差法 {x12a2+y12b2=1x22a2+y22b2=1 \\left\\{\\begin{aligned}{\\frac{x_{1}^{2}}{a^{2}}+\\frac{y_{1}^{2}}{b^{2}}=1} \\\\ {\\frac{x_{2}^{2}}{a^{2}}+\\frac{y_{2}^{2}}{b^{2}}=1}\\end{aligned}\\right.\\\\ ⎩⎪⎪⎪⎨⎪⎪⎪⎧​a2x12​​+b2y12​​=1a2x22​​+b2y22​​=1​x12−x22a2=−y12−y02b2y1−y2x1−x2⋅y1+y2x1+x2=−b2a2y1−y2x1−x2⋅y0x0=−b2a2kAB⋅kOP=−b2a2 \\begin{aligned} \\frac{x_{1}^{2}-x_{2}^{2}}{a^{2}}&amp;=-\\frac{y_{1}^{2}-y_{0}^{2}}{b^{2}} \\\\ \\frac{y_{1}-y_{2}}{x_{1}-x_{2}} \\cdot \\frac{y_{1}+y_{2}}{x_{1}+x_{2}}&amp;=-\\frac{b^{2}}{a^{2}}\\\\ \\frac{y_{1}-y_{2}}{x_{1}-x_{2}} \\cdot \\frac{y_0}{x_0}&amp;=-\\frac{b^{2}}{a^{2}}\\\\ k_{A B} \\cdot k_{OP}&amp;=-\\frac{b^{2}}{a^{2}} \\end{aligned}\\\\ a2x12​−x22​​x1​−x2​y1​−y2​​⋅x1​+x2​y1​+y2​​x1​−x2​y1​−y2​​⋅x0​y0​​kAB​⋅kOP​​=−b2y12​−y02​​=−a2b2​=−a2b2​=−a2b2​​¶ 切线 Ax2+By2+Cx+Dy+E=0Ax0x+By0y+Cx0+x2+Dy0+y2+E=0 \\begin{gathered} A x^{2}+B y^{2}+C x+D y+E=0\\\\ A x_{0} x+B y_{0} y+C \\frac{x_{0}+x}{2}+D \\frac{y_{0}+y}{2}+E=0 \\end{gathered} Ax2+By2+Cx+Dy+E=0Ax0​x+By0​y+C2x0​+x​+D2y0​+y​+E=0​¶ 整体思想 x1+kx2=0x1x2=−kx2x1=−1kx1x2+x2x1=x12+x22x1x2=(x1+x2)2x1x2−2(x1+x2)2x1x2=−k−1k+2 \\begin{gathered} x_1 + kx_2 = 0\\\\ \\frac{x_1}{x_2} = -k\\\\ \\frac{x_2}{x_1} = -\\frac{1}{k}\\\\ \\frac{x_1}{x_2} + \\frac{x_2}{x_1} = \\frac{x_1^2 + x_2^2}{x_1x_2} = \\frac{(x_1+x_2)^2}{x_1x_2}-2\\\\ \\frac{(x_1+x_2)^2}{x_1x_2}=-k-\\frac{1}{k}+2 \\end{gathered} x1​+kx2​=0x2​x1​​=−kx1​x2​​=−k1​x2​x1​​+x1​x2​​=x1​x2​x12​+x22​​=x1​x2​(x1​+x2​)2​−2x1​x2​(x1​+x2​)2​=−k−k1​+2​¶ 焦点三角形 ¶ 仿射变换","link":"/archives/%E6%96%87%E5%8C%96%E8%AF%BE/%E6%A4%AD%E5%9C%86"},{"title":"氮","text":"NHX3⇌NX2⇌NO⇌NOX2(红棕)⇌HNOX3NHX3→NO←HNOX3 \\ce{ NH3&lt;=&gt;N2&lt;=&gt;NO&lt;=&gt;NO2(红棕)&lt;=&gt;HNO3\\\\ NH3 -&gt; NO &lt;-HNO3 } NHX3​​NX2​​NO​NOX2​(红棕)​HNOX3​NHX3​​NO​HNOX3​类比 S\\ce{S}S，注意不可一步变成 NO\\ce{NO}NO NX2+OX2=2 NO{2 NO+OX2=2 NOX23 NOX2+HX2O=2 HNOX3+NO→{4 NO+3 OX2+HX2O=4 HNOX34 NOX2+OX2+2 HX2O=4 HNOX3 \\ce{N2 + O2 = 2NO}\\\\ \\left\\{ \\begin{aligned} \\ce{2NO + O2 &amp;= 2NO2}\\\\ \\ce{3NO2 + H2O &amp;= 2HNO3 + NO}\\\\ \\end{aligned} \\right. \\rightarrow \\left\\{ \\begin{aligned} \\ce{4NO + 3O2 + H2O &amp;= 4HNO3}\\\\ \\ce{4NO2 + O2 + 2H2O &amp;= 4HNO3}\\\\ \\end{aligned} \\right. NX2​+OX2​=2NO{2NO+OX2​3NOX2​+HX2​O​=2NOX2​=2HNOX3​+NO​→{4NO+3OX2​+HX2​O4NOX2​+OX2​+2HX2​O​=4HNOX3​=4HNOX3​​NHX3, HCl, HNOX3\\ce{NH3,HCl,HNO3}NHX3​,HCl,HNOX3​ 易挥发，空中反应，形成白烟 MgX3NX2\\ce{Mg3N2}MgX3​NX2​ 灰绿，M=100M=100M=100，双水解 注意 NX2+3 HX2⇌2 NHX3\\ce{N2 + 3H2&lt;=&gt;2NH3}NX2​+3HX2​​2NHX3​ 转化率低，不会倒吸 尾气处理只要 NOX2 &gt;NO\\ce{NO2 &gt;NO}NOX2​ &gt;NO 皆可除净（所以不行就通空气（OX2\\ce{O2}OX2​）） 2 NOX2+2 NaOH→NaNOX3+NaNOX2+HX2O \\ce{2NO2 + 2NaOH-&gt;NaNO3 + NaNO2 + H2O} 2NOX2​+2NaOH​NaNOX3​+NaNOX2​+HX2​ONOX2+NO+2 NaOH→2 NaNOX2+HX2O \\ce{NO2 + NO + 2NaOH-&gt;2NaNO2 + H2O} NOX2​+NO+2NaOH​2NaNOX2​+HX2​O¶ 氨 氢键形式 HX3N⋅⋅⋅H−O−H\\ce{H3N\\bond{...}H\\bond{1}O\\bond{1}H}HX3​N⋅⋅⋅H−O−H 氧化性 2 Na+2 NHX3=2 NaNHX2+HX2\\ce{2Na + 2NH3 = 2NaNH2 + H2}2Na+2NHX3​=2NaNHX2​+HX2​ 强还原 4 NHX3+5 OX2→ΔPt4 NO+6 HX2O \\ce{4NH3 + 5O2-&gt;[Pt][\\Delta]4NO + 6H2O}\\\\ 4NHX3​+5OX2​PtΔ​4NO+6HX2​ONHX3+3 OX2(纯)→点燃2 NX2+6 HX2O \\ce{NH3 + 3O2(纯)-&gt;[点燃]2N2 + 6H2O}\\\\ NHX3​+3OX2​(纯)点燃​2NX2​+6HX2​O{2 NHX3+3 ClX2=NX2+6 HCl8 NHX3+3 ClX2=NX2+6 NHX4ClNHX3+3 ClX2=NClX3+3 HCl \\left\\{ \\begin{aligned} \\ce{2NH3 + 3Cl2&amp;=N2 + 6HCl}\\\\ \\ce{8NH3 + 3Cl2&amp;=N2 + 6NH4Cl}\\\\ \\ce{NH3 + 3Cl2&amp;=NCl3 + 3HCl}\\\\ \\end{aligned} \\right. ⎩⎪⎪⎨⎪⎪⎧​2NHX3​+3ClX2​8NHX3​+3ClX2​NHX3​+3ClX2​​=NX2​+6HCl=NX2​+6NHX4​Cl=NClX3​+3HCl​ 制取，平衡左移（OHX−\\ce{OH-}OHX−），放热 CaO(s)+NHX3 ⋅ HX2O(l)→Ca(OH)X2+NHX3↑ \\ce{CaO(s) + NH3.H2O(l)-&gt;Ca(OH)2 + NH3 ^}\\\\ CaO(s)+NHX3​⋅HX2​O(l)​Ca(OH)X2​+NHX3​↑NHX3 ⋅ HX2O(l)→NaOH(s)NHX3↑+HX2O \\ce{NH3.H2O(l)-&gt;[NaOH(s)]NH3 ^ + H2O}\\\\ NHX3​⋅HX2​O(l)NaOH(s)​NHX3​↑+HX2​OCa(OH)X2+2 NHX4Cl→2 NHX3↑+CaClX2 \\ce{Ca(OH)2 + 2NH4Cl -&gt; 2NH3 ^ + CaCl2}\\\\ Ca(OH)X2​+2NHX4​Cl​2NHX3​↑+CaClX2​ 控制流速（气泡数），控制反应气比例（掌握仪器） ¶ 氨盐 白色固体 离子晶体 加热皆可分解 NHX3↑\\ce{NH3 ^}NHX3​↑ NHX4NOX3→ΔNX2O+2 HX2O\\ce{NH4NO3 -&gt;[\\Delta]N2O + 2 H2O}NHX4​NOX3​Δ​NX2​O+2HX2​O NHX4NOX2→ΔNX2+2 HX2O\\ce{NH4NO2 -&gt;[\\Delta]N2 + 2H2O}NHX4​NOX2​Δ​NX2​+2HX2​O ¶ 硝酸 不稳定 4 HNOX3X浓→光/Δ4 NOX2↑+OX2↑+2 HX2O \\ce{4HNO3_{浓} -&gt;[光/\\Delta] 4NO2 ^ + O2 ^ + 2H2O} 4HNOX3​X浓​光/Δ​4NOX2​↑+OX2​↑+2HX2​O 酸性 金属 不生成 HX2\\ce{H2}HX2​ CuO,CaCOX3\\ce{CuO, CaCO3}CuO,CaCOX3​ 就像普通酸 紫色石蕊，先变红，后褪色 强氧化 HNOX3X浓&gt;HNOX3X稀&gt;HX2SOX4X浓\\ce{HNO3_{浓} &gt; HNO3_{稀} &gt; H2SO4_{浓}}HNOX3​X浓​&gt;HNOX3​X稀​&gt;HX2​SOX4​X浓​ 金属 Pt,Au\\ce{Pt, Au}Pt,Au 不反应 和王水（HNOX3:HCl=1:3\\ce{HNO3:HCl} = 1:3HNOX3​:HCl=1:3）反应 Fe,Cu\\ce{Fe, Cu}Fe,Cu 常温钝化 Cu\\ce{Cu}Cu Cu+4 HNOX3X浓→Cu(NOX3)X2+2 NOX2↑+4 HX2O(会稀释) \\ce{Cu + 4HNO3_{浓} -&gt; Cu(NO3)2 + 2NO2 ^ + 4H2O}(会稀释) Cu+4HNOX3​X浓​​Cu(NOX3​)X2​+2NOX2​↑+4HX2​O(会稀释)3 Cu+8 HX++2 NOX3X−→3 CuX2++2 NO↑+4 HX2O \\ce{3Cu + 8H+ + 2NO3- -&gt; 3Cu^{2+} + 2NO ^ + 4H2O} 3Cu+8HX++2NOX3​X−​3CuX2++2NO↑+4HX2​O 非金属 C+HNOX3X浓→(Δ)4 NOX2↑+COX2↑+2 HX2O \\ce{C + HNO3_{浓}-&gt;[(\\Delta)] 4NO2 ^ + CO2 ^ + 2H2O} C+HNOX3​X浓​(Δ)​4NOX2​↑+COX2​↑+2HX2​OSX2−, SOX3X2−&gt;IX−&gt;FeX2+&gt;BrX− &gt;(ClX−不会反应) \\ce{S^{2-},SO3^{2-} &gt; I- &gt; Fe^{2+}&gt;Br- &gt;(Cl- 不会反应)} SX2−,SOX3​X2−&gt;IX−&gt;FeX2+&gt;BrX− &gt;(ClX−不会反应) 工业制取 （2233） NO\\ce{NO}NO 生成 （转化器） 4 NHX3+5 OX2→ΔPt4 NO+6 HX2O \\ce{4NH3 + 5O2 -&gt;[Pt][\\Delta] 4NO + 6H2O} 4NHX3​+5OX2​PtΔ​4NO+6HX2​O HNOX3\\ce{HNO3}HNOX3​ 生成 （吸收塔） {2 NO+OX2=2 NOX23 NOX2+HX2O=2 HNOX3+NO→4 NO+3 OX2+2 HX2O=4 HNOX3 \\left\\{ \\begin{aligned} \\ce{2NO + O2 &amp;= 2NO2}\\\\ \\ce{3NO2 + H2O &amp;= 2HNO3 + NO}\\\\ \\end{aligned} \\right. \\rightarrow \\ce{4NO + 3O2 + 2H2O = 4HNO3}\\\\ {2NO+OX2​3NOX2​+HX2​O​=2NOX2​=2HNOX3​+NO​→4NO+3OX2​+2HX2​O=4HNOX3​","link":"/archives/%E6%96%87%E5%8C%96%E8%AF%BE/%E6%B0%AE"},{"title":"简谐运动","text":"¶ 简单情况 先考虑最简单的情况，平衡位置为 x=0x=0x=0，振幅为 AAA，质点质量为 mmm，弹簧劲度系数为 kkk，从平衡位置起振。 由运动学规律得 x(t)=Asin⁡ωtv(t)=dxdt=Aωcos⁡ωta(t)=dvdt=−Aω2sin⁡ωt \\def\\d{\\mathrm{d}} \\begin{aligned} x(t)&amp;=A\\sin\\omega t\\\\ v(t)&amp;=\\frac{\\d x}{\\d t} = A\\omega\\cos\\omega t\\\\ a(t)&amp;=\\frac{\\d v}{\\d t} = -A\\omega^2\\sin\\omega t\\\\ \\end{aligned}\\\\ x(t)v(t)a(t)​=Asinωt=dtdx​=Aωcosωt=dtdv​=−Aω2sinωt​ 由力学规律得 a(t)=F(t)m=−kx(t)m=−kAsin⁡ωtm a(t)= \\frac{F(t)}{m}= \\frac{-kx(t)}{m} = \\frac{-kA\\sin\\omega t}{m} a(t)=mF(t)​=m−kx(t)​=m−kAsinωt​故 −Aω2=−kAmk=mω2k=m(2πT)2ω=kmT=2πmk \\begin{aligned} -A\\omega^2&amp;=-\\frac{kA}{m}\\\\ k&amp;=m\\omega^2\\\\ k&amp;=m\\left(\\frac{2\\pi}{T}\\right)^2\\\\ \\omega&amp;=\\sqrt{\\frac{k}{m}}\\\\ T&amp;=2\\pi\\sqrt{\\frac{m}{k}} \\end{aligned} −Aω2kkωT​=−mkA​=mω2=m(T2π​)2=mk​​=2πkm​​​可得简单推论 v=Aω(1) v = A\\omega\\tag{1} v=Aω(1)注意到质点在单位圆上做匀速圆周运动，它 xxx 轴投影符合 x=Acos⁡tx=A\\cos tx=Acost。 故可以将简谐运动想象成角速度为 ω\\omegaω 的匀速圆周运动的投影。 12kA2=12mω2A2=12mv2(2) \\begin{aligned} \\frac{1}{2}kA^2&amp;=\\frac{1}{2}m\\omega^2A^2\\\\ &amp;=\\frac{1}{2}mv^2\\tag{2} \\end{aligned} 21​kA2​=21​mω2A2=21​mv2​(2)振动动能和振动势能之和始终为 kA2/2kA^2/2kA2/2，在弹簧情景下是容易理解的。 ¶ 也简单的情况 假定斜面倾角为 θ\\thetaθ，初始时弹簧自然伸长，劲度系数为 kkk，质点质量为 mmm。 G=mgsin⁡θF=−kx+G=−k(x−Gk) \\begin{gathered} G=mg\\sin\\theta\\\\ \\begin{aligned} F&amp;=-kx+G\\\\ &amp;=-k\\left(x-\\frac{G}{k}\\right)\\\\ \\end{aligned} \\end{gathered} G=mgsinθF​=−kx+G=−k(x−kG​)​​故此时 A=Gk A=\\frac{G}{k}\\\\ A=kG​并且 ω=km \\omega=\\sqrt{\\frac{k}{m}}\\\\ ω=mk​​也就是说，只要力的变化是随位移线性的，且另外只受一个恒力，则质点做简谐运动。 ¶ 几个题 倾角为 θ=30°\\theta=30\\degreeθ=30°、宽 d=0.1md=0.1\\text{m}d=0.1m 的斜面导轨，上有 m=0.1kgm=0.1\\text{kg}m=0.1kg 金属棒，通过恒定电流 III，受沿斜面向上安培力。磁场垂直导轨，满足 B=2x TB=2x\\,\\text{T}B=2xT。金属棒从 x=0x=0x=0 释放，振幅为 A=1.25mA=1.25\\text{m}A=1.25m。 求 t=0t=0t=0 到 t=T/4t=T/4t=T/4 时间安培力冲量。 k=G/A=mgsin⁡θ/A=0.4ω=km=2I=p1−p0=mωA=0.25IG=mgsin⁡θ⋅T4=π8II=I−IG=2−π8 \\begin{gathered} k = G/A = mg\\sin\\theta/A=0.4\\\\ \\omega=\\sqrt{\\frac{k}{m}}=2\\\\ I = p_1 - p_0 = m\\omega A = 0.25\\\\ I_G=mg\\sin\\theta \\cdot \\frac{T}{4}=\\frac{\\pi}{8}\\\\ I_I = I - I_G = \\frac{2-\\pi}{8} \\end{gathered} k=G/A=mgsinθ/A=0.4ω=mk​​=2I=p1​−p0​=mωA=0.25IG​=mgsinθ⋅4T​=8π​II​=I−IG​=82−π​​ 倾角为 θ\\thetaθ、宽 lll 的斜面导轨，有垂直斜边大小为 BBB 的磁场，末端接有电感为 LLL 的电感线圈。电阻均不计。 静止释放金属棒，求金属棒滑行的最大距离 xmx_mxm​。 已知电感 E=LΔIΔtE=L\\frac{\\Delta I}{\\Delta t}E=LΔtΔI​ 由于无电阻，所以金属棒电动势等于电感电动势。 E=E′=Blv=LΔIΔtBlvΔt=LΔI∫Blvdt=∫LdIBlx=LII=BlxL \\begin{aligned} E=E'&amp;=Blv=L\\frac{\\Delta I}{\\Delta t}\\\\ Blv\\Delta t &amp;= L\\Delta I\\\\ \\int Blv\\mathrm{d}t&amp;=\\int L\\mathrm{d}I\\\\ Blx &amp;= LI\\\\ I &amp;= \\frac{Blx}{L}\\\\ \\end{aligned} E=E′BlvΔt∫BlvdtBlxI​=Blv=LΔtΔI​=LΔI=∫LdI=LI=LBlx​​易得 F=BIl=B2l2Lxk=B2l2LG=mgsin⁡θA=G/k=mgLsin⁡θB2l2 \\begin{aligned} F = BIl &amp;= \\frac{B^2l^2}{L}x\\\\ k &amp;= \\frac{B^2l^2}{L}\\\\ G &amp;= mg\\sin\\theta\\\\ A = G/k &amp;= \\frac{mgL\\sin\\theta}{B^2l^2} \\end{aligned} F=BIlkGA=G/k​=LB2l2​x=LB2l2​=mgsinθ=B2l2mgLsinθ​​xm=2A=2mgLsin⁡θB2l2x_m=2A=\\frac{2mgL\\sin\\theta}{B^2l^2}xm​=2A=B2l22mgLsinθ​ ¶ 电磁振荡 由于高中考察定性，所以就随便写了。 电容器电压为 UUU，电路电流为 III，感应电动势为 EEE，磁场强度为 BBB U=cos⁡tI=sin⁡tE=I′=cos⁡tB=sin⁡tU2+B2=1 \\begin{aligned} U&amp;=\\cos t\\\\ I&amp;=\\sin t\\\\ E&amp;= I' = \\cos t\\\\ B&amp;=\\sin t\\\\ U^2 &amp;+ B^2 = 1 \\end{aligned}\\\\ UIEBU2​=cost=sint=I′=cost=sint+B2=1​","link":"/archives/%E6%96%87%E5%8C%96%E8%AF%BE/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8"},{"title":"快速傅里叶变换 Fast Fourier Transform","text":"¶ 前置技能 ¶ 虚数 i2=−1i=−1 i^2 = -1\\\\ i = \\sqrt{-1} i2=−1i=−1​¶ 复数 任意复数 zzz 都可表示为 a+bi(a,b∈R)a+bi(a,b\\in R)a+bi(a,b∈R) aaa 叫做实部，定义 Re(z)=a\\mathrm{Re}(z) = aRe(z)=a b​b​b​ 叫做虚部，定义 Im(z)=b​\\mathrm{Im}(z) = b​Im(z)=b​ ¶ 复平面 实数只有一根数轴 现在不够用了，于是我们再加一条 画一个平面直角坐标系，横轴定义为实轴，纵轴定义为虚轴 对于一个复数 z=a+biz=a+biz=a+bi，有如下定义 模 r=∣z∣=a2+b2r=\\left| z \\right| = \\sqrt{a^2+b^2}r=∣z∣=a2+b2​ 辐角 φ=arg⁡z\\varphi = \\arg zφ=argz 与实轴正方向的角度 于是可以得到 z=r(cos⁡φ+isin⁡φ)z=r(\\cos\\varphi+i\\sin\\varphi)z=r(cosφ+isinφ) 可以类比向量 ¶ 运算规律 z1=a+bi,z2=c+diz_1=a+bi, z_2=c+diz1​=a+bi,z2​=c+di ¶ 加减 z1+z2=(a+c)+(b+d)i−z2=−c−diz1−z2=z1+(−z2) z_1+z_2=(a+c)+(b+d)i\\\\ -z_2=-c-di\\\\ z_1-z_2=z_1+(-z_2) z1​+z2​=(a+c)+(b+d)i−z2​=−c−diz1​−z2​=z1​+(−z2​)复平面上类比向量加减 ¶ 乘法 φ1=arg⁡z1φ2=arg⁡z2r1=∣z1∣r2=∣z2∣z1×z2=(a+bi)(c+di)=(ac−bd)+(ad+bc)i=r1(cos⁡φ1+isin⁡φ1)r2(cos⁡φ2+isin⁡φ2)=r1r2((cos⁡φ1cos⁡φ2−sin⁡φ1sin⁡φ2)+i(sin⁡φ1cos⁡φ2+cos⁡φ1sin⁡φ2))=r1r2(cos⁡(φ1+φ2)+isin⁡(φ1+φ2)) \\varphi_1=\\arg z_1\\\\ \\varphi_2=\\arg z_2\\\\ r_1=\\left| z_1 \\right|\\\\ r_2=\\left| z_2 \\right|\\\\ \\begin{aligned} z_1\\times z_2 &amp;= (a+bi)(c+di)\\\\ &amp;= (ac-bd)+(ad+bc)i\\\\ &amp;= r_1(\\cos\\varphi_1+i\\sin\\varphi_1) r_2(\\cos\\varphi_2+i\\sin\\varphi_2)\\\\ &amp;=r_1r_2\\big((\\cos\\varphi_1\\cos\\varphi_2-\\sin\\varphi_1\\sin\\varphi_2)+i(\\sin\\varphi_1\\cos\\varphi_2+\\cos\\varphi_1\\sin\\varphi_2)\\big)\\\\ &amp;=r_1r_2\\big(\\cos(\\varphi_1+\\varphi_2)+i\\sin(\\varphi_1+\\varphi_2)\\big) \\end{aligned} φ1​=argz1​φ2​=argz2​r1​=∣z1​∣r2​=∣z2​∣z1​×z2​​=(a+bi)(c+di)=(ac−bd)+(ad+bc)i=r1​(cosφ1​+isinφ1​)r2​(cosφ2​+isinφ2​)=r1​r2​((cosφ1​cosφ2​−sinφ1​sinφ2​)+i(sinφ1​cosφ2​+cosφ1​sinφ2​))=r1​r2​(cos(φ1​+φ2​)+isin(φ1​+φ2​))​复平面上，复数相乘，幅角相加，模相乘 ¶ 单位根 对于方程 xn=1 x^n=1 xn=1我们有 n​n​n​ 个复数域上的解 在复平面上，这些点都落在单位圆上，它们将圆 n​n​n​ 等分 定义 ωn=cos⁡2πn+isin⁡2πn\\omega_n=\\cos\\frac{2\\pi}{n}+i\\sin\\frac{2\\pi}{n}ωn​=cosn2π​+isinn2π​ ωnk=(ωn)k=cos⁡2πkn+isin⁡2πkn \\omega_n^k = (\\omega_n)^k = \\cos\\frac{2\\pi k}{n}+i\\sin\\frac{2\\pi k}{n} ωnk​=(ωn​)k=cosn2πk​+isinn2πk​以 x5=1x^5=1x5=1 为例 ¶ 性质 ω2n2k=ωnk\\omega_{2n}^{2k}=\\omega_n^kω2n2k​=ωnk​ ωnn/2=−1\\omega_n^{n/2}=-1ωnn/2​=−1 ¶ 多项式 F(x)=∑i=0n−1aixi F(x)=\\sum_{i=0}^{n-1}a_ix^i F(x)=i=0∑n−1​ai​xi¶ 代数基本定理 一个 nnn 次多项式，在复数域上恰有 nnn 个根 ¶ 点值表示 选择 nnn 个互不相同的数带入可得到许多点值 (x1,y1),(x2,y2)⋯(xn,yn) (x_1,y_1),(x_2,y_2)\\cdots(x_n,y_n) (x1​,y1​),(x2​,y2​)⋯(xn​,yn​)根据 nnn 个点，我们同样可以确定一个唯一的 n−1n-1n−1 次多项式 ¶ 证明 假设同时有两个不相同多项式 A(x),B(x)A(x),B(x)A(x),B(x) 满足 ∀i∈[1,n],A(x)=B(x)=yi\\forall i\\in[1,n],A(x)=B(x)=y_i∀i∈[1,n],A(x)=B(x)=yi​ 那么对于 C(x)=A(x)−B(x)C(x)=A(x)-B(x)C(x)=A(x)−B(x) 则有 nnn 个根，而 C(x)C(x)C(x) 为 n−1n-1n−1 次多项式 矛盾 ¶ 快速傅里叶变换 FFT ¶ 离散傅里叶变换 DFT 已知多项式系数求点值表达 nnn 为 222 的整数次幂 F(x)=∑i=0n−1aixie.g.F(x)=a3x3+a2x2+a1x+a0A(x)=∑i=0n/2−1a2ix2ie.g.A(x)=a2x2+a0B(x)=∑i=0n/2−1a2i+1x2ie.g.B(x)=a3x2+a1F(x)=A(x)+xB(x)e.g.F(x)=a2x2+a0+x(a3x2+a1)∀k∈[1,n/2]F(ωnk)=A(ωnk)+ωnkB(ωnk)∵ωnk+n/2=ωnkωnn/2=−ωnkF(ωnk+n/2)=A(ωnk+n/2)+ωnk+n/2B(ωnk+n/2)=A(ωnk)−ωnkB(ωnk) \\begin{aligned} F(x)&amp;=\\sum_{i=0}^{n-1}a_ix^i\\\\ e.g.\\quad F(x)&amp;=a_3x^3+a_2x^2+a_1x+a_0\\\\\\\\ A(x)&amp;=\\sum_{i=0}^{n/2-1}a_{2i}x^{2i}\\\\ e.g.\\quad A(x)&amp;=a_2x^2+a_0\\\\\\\\ B(x)&amp;=\\sum_{i=0}^{n/2-1} a_{2i+1}x^{2i}\\\\ e.g.\\quad B(x)&amp;=a_3x^2+a_1\\\\\\\\ F(x)&amp;=A(x)+xB(x)\\\\ e.g.\\quad F(x)&amp;=a_2x^2+a_0+x(a_3x^2+a_1)\\\\\\\\ \\forall \\quad k&amp;\\in[1,n/2]\\\\ F(\\omega_n^k)&amp;=A(\\omega_n^k)+\\omega_n^kB(\\omega_n^k)\\\\ \\because \\omega_n^{k+n/2}&amp;=\\omega_n^k\\omega_n^{n/2}=-\\omega_n^k \\\\ F(\\omega_n^{k+n/2})&amp;=A(\\omega_n^{k+n/2})+\\omega_n^{k+n/2}B(\\omega_n^{k+n/2})\\\\ &amp;= A(\\omega_n^k)-\\omega_n^kB(\\omega_n^k) \\end{aligned}\\\\ F(x)e.g.F(x)A(x)e.g.A(x)B(x)e.g.B(x)F(x)e.g.F(x)∀kF(ωnk​)∵ωnk+n/2​F(ωnk+n/2​)​=i=0∑n−1​ai​xi=a3​x3+a2​x2+a1​x+a0​=i=0∑n/2−1​a2i​x2i=a2​x2+a0​=i=0∑n/2−1​a2i+1​x2i=a3​x2+a1​=A(x)+xB(x)=a2​x2+a0​+x(a3​x2+a1​)∈[1,n/2]=A(ωnk​)+ωnk​B(ωnk​)=ωnk​ωnn/2​=−ωnk​=A(ωnk+n/2​)+ωnk+n/2​B(ωnk+n/2​)=A(ωnk​)−ωnk​B(ωnk​)​复杂度分析 DFT(n)=2DFT(n/2)+O(n)=O(nlog⁡n)\\mathrm{DFT}(n)=2\\mathrm{DFT}(n/2)+O(n)=O(n\\log n)DFT(n)=2DFT(n/2)+O(n)=O(nlogn) ¶ 逆离散傅里叶变换 IDFT 已知点值表达求系数表达 bi=F(ωni)ck=∑i=1nbi(ωn−k)i=∑i=1n(∑j=0n−1aj(ωni)j)(ωn−k)i=∑i=1n∑j=0n−1aj(ωnj−k)i=∑j=0n−1∑i=1naj(ωnj−k)i=∑j=0n−1(aj∑i=1n(ωnj−k)i)S(ωnk)=ωnk+(ωnk)2+⋯+(ωnk)n={ωnk−(ωnk)n⋅ωnk1−ωnk=0,ωnk=1̸n,ωnk=1ck=∑j=0n−1ajS(ωnj−k)=nak∴ak=1nck b_i=F(\\omega_n^i)\\\\\\\\ \\begin{aligned} c_k&amp;=\\sum_{i=1}^nb_i(\\omega_n^{-k})^i\\\\ &amp;=\\sum_{i=1}^n(\\sum_{j=0}^{n-1}a_j(\\omega_n^i)^j)(\\omega_n^{-k})^i\\\\ &amp;=\\sum_{i=1}^n\\sum_{j=0}^{n-1}a_j(\\omega_n^{j-k})^i\\\\ &amp;=\\sum_{j=0}^{n-1}\\sum_{i=1}^na_j(\\omega_n^{j-k})^i\\\\ &amp;=\\sum_{j=0}^{n-1}\\bigg(a_j\\sum_{i=1}^n(\\omega_n^{j-k})^i\\bigg)\\\\ \\end{aligned}\\\\ \\begin{aligned}\\\\\\\\ S(\\omega_n^k)&amp;=\\omega_n^k+(\\omega_n^k)^2+\\cdots+(\\omega_n^k) ^n\\\\ &amp;=\\left\\{ \\begin{aligned} \\frac{\\omega_n^k-(\\omega_n^k) ^n\\cdot\\omega_n^k}{1-\\omega_n^k}=0, \\omega_n^k=\\not1\\\\ n, \\omega_n^k=1 \\end{aligned} \\right.\\\\\\\\ \\end{aligned}\\\\ \\begin{aligned} c_k&amp;=\\sum_{j=0}^{n-1}a_jS(\\omega_n^{j-k})\\\\ &amp;=na_k\\\\ \\end{aligned}\\\\ \\therefore \\quad a_k=\\frac{1}{n}c_k bi​=F(ωni​)ck​​=i=1∑n​bi​(ωn−k​)i=i=1∑n​(j=0∑n−1​aj​(ωni​)j)(ωn−k​)i=i=1∑n​j=0∑n−1​aj​(ωnj−k​)i=j=0∑n−1​i=1∑n​aj​(ωnj−k​)i=j=0∑n−1​(aj​i=1∑n​(ωnj−k​)i)​S(ωnk​)​=ωnk​+(ωnk​)2+⋯+(ωnk​)n=⎩⎪⎪⎨⎪⎪⎧​1−ωnk​ωnk​−(ωnk​)n⋅ωnk​​=0,ωnk​=1n,ωnk​=1​​ck​​=j=0∑n−1​aj​S(ωnj−k​)=nak​​∴ak​=n1​ck​我们知道了点值 bib_ibi​ 可以通过和 DFT 类似的方法求出 ckc_kck​ 然后 ak=1ncka_k=\\frac{1}{n}c_kak​=n1​ck​ 就求出了系数表达","link":"/archives/%E7%AE%97%E6%B3%95/FFT"},{"title":"Miller Rabin 判素","text":"¶ 数学 ¶ 费马小定理 对于素数 ppp 必存在 ap−1≡1(modp) a^{p-1} \\equiv 1 \\pmod{p} ap−1≡1(modp)所以可以随机选取 a∈[2,n−1]a\\in[2,n-1]a∈[2,n−1] 检验是否满足上式，若不满足，则必然是合数 遗憾的是，存在无穷多个 nnn，可以满足 ∀ x∈[2,n−1]xn−1≡1(modn) \\forall\\ x\\in[2,n-1]\\\\ x^{n-1}\\equiv 1 \\pmod{n} ∀ x∈[2,n−1]xn−1≡1(modn)也就是说使费马判素失效 ¶ 二次探测定理 素数 ppp 必满足方程 x2≡1(modp) x^2\\equiv1\\pmod{p} x2≡1(modp)有且仅有两个解 x1≡1, x2≡p−1(modp) x_1\\equiv1,\\ x_2\\equiv p-1\\pmod{p} x1​≡1, x2​≡p−1(modp)¶ 实现 把 n−1n-1n−1 分解成 d⋅2td\\cdot2^td⋅2t 使 ttt 尽量大 然后 x≡based(modn)x\\equiv base^{d} \\pmod{n}x≡based(modn) 然后不断进行二次探测 即如果满足 x≢1x\\not\\equiv 1x≡1 且 x≢n−1x\\not\\equiv n-1x≡n−1 且 x2≡1x^2\\equiv 1x2≡1 那么这个数解不是素数了 最后进行费马判素 12345678910111213bool miller_rabin(ll n) { if (n &lt;= 2) return n == 2; int d = n - 1, t = 0; while (d % 2 == 0) d /= 2, ++t; rep(i, 0, T) { // T 是测试次数, p 是测试基 ll x = ksm(p[i] % (n - 2) + 2, d, n); if (x == 1 || x == n - 1) continue; // 无效的二次探测 for (int j = 0; j &lt; t; ++j, x = x * x % n) if (x != n - 1 &amp;&amp; x != 1 &amp;&amp; x * x % n == 1) return 0; if (x != 1) return 0; // 费马判素 } return 1;} 这是测试基选择的推荐 数据范围 测试基 2322^{32}232 2,7,61 2642^{64}264 2,3,5,7,11,13,17,19,23,29,31,37","link":"/archives/%E7%AE%97%E6%B3%95/miller-rabin"},{"title":"「POI 2015」WIL-Wilcze doły","text":"假设选中区间 [l,r][l, r][l,r]，经过题目中的操作，获得的和为该区间的得分，其中最小的成为最小得分 fl,rf_{l,r}fl,r​ 显然得选满 ddd 长度 所以对于区间 [l,r][l, r][l,r] 只需要知道其中长度为 ddd 的最大子段和就可以知道区间的最小得分 当然是用线段树维护啦 学数据结构果然会变傻 发现可以用单调队列维护最大子段和 然后发现若是区间 fl,r&gt;pf_{l, r} &gt; pfl,r​&gt;p 则必然有 ∀ x&lt;l,y&gt;r fx,y&gt;p\\forall~x&lt;l,y&gt;r~~~f_{x, y} &gt; p∀ x&lt;l,y&gt;r fx,y​&gt;p 然后就是一道 two-pointer 的题了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef long long ll;typedef unsigned int ui;typedef pair&lt;int, ll&gt; pii;const int N = 2000010;ll a[N], s[N];std::deque&lt;pii&gt; q;int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, d; ll p; cin &gt;&gt; n &gt;&gt; p &gt;&gt; d; rep(i, 1, n) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } int ans = d, l = 1, r = d; ll c = 0; q.push_back(pii(1, s[d])); for (; r &lt;= n; ++r) { // c += a[r]; c = s[r] - s[r - d]; while (q.size() &amp;&amp; q.back().second &lt;= c) q.pop_back(); q.push_back(pii(r - d + 1, c)); c = s[r] - s[l - 1] - q.front().second; while (c &gt; p) { ++l; while (q.size() &amp;&amp; q.front().first &lt; l) q.pop_front(); c = s[r] - s[l - 1] - q.front().second; } ans = std::max(r - l + 1, ans); // for(q.size() &amp;&amp; q.front().first) } cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/P3594"},{"title":"「CodePlus 2017 11 月赛」Yazid 的新生舞会","text":"给定长度为 n≤105n\\le10^5n≤105 的序列 aaa ，统计满足以下条件的子区间数量 区间 [l,r][l, r][l,r] 中，存在一个数 xxx ，它的出现次数为 mmm，并且 2m&gt;r−l+12m&gt;r-l+12m&gt;r−l+1 记录一下思考过程 首先觉得是枚举 xxx，那么记 si=∑k=1i[ai=x]s_i = \\sum_{k=1}^i [a_i=x]si​=∑k=1i​[ai​=x] 条件转化为 2(sr−sl)&gt;r−l2(s_r - s_l) &gt; r - l2(sr​−sl​)&gt;r−l （现在考虑 [l+1,r][l+1, r][l+1,r] ） 化简一下 2sl−l&lt;2sr−r2s_l-l&lt;2s_r-r2sl​−l&lt;2sr​−r 那么又记 ci=2si−ic_i = 2s_i - ici​=2si​−i 也就是说，若 cl&lt;crc_l&lt;c_rcl​&lt;cr​ 则 [l+1,r][l+1, r][l+1,r] 满足条件 对于每个 crc_rcr​ 都要数出来多少 clc_lcl​ 满足，朴素可能是 O(nV)O(nV)O(nV) 观察 cic_ici​ 的性质，发现其为 1+∑i=1n[ai=x]1+\\sum_{i=1}^n [a_i=x]1+∑i=1n​[ai​=x] 个 d=−1d=-1d=−1 的等差数列组合 还有另外一个思考方式 建立新数组 bi={1 ai=x−1 ai≠x b_i = \\left\\{ \\begin{aligned} &amp;1~~~a_i=x\\\\ -&amp;1~~~a_i\\neq x \\end{aligned} \\right. bi​={−​1 ai​=x1 ai​=x​建立 bbb 的前缀和 ddd，ddd 和 ccc 完全相同 然后就变成一道数据结构问题 维护序列 aaa，支持 给出 x,yx,yx,y ，区间加 111 给出 x,yx,yx,y ，回答 ∑i=xy∑j=1x−1ai\\sum_{i=x}^y\\sum_{j=1}^{x-1}a_i∑i=xy​∑j=1x−1​ai​ 对应到这个问题，就是定义 px=∑[ci=x]p_x=\\sum[c_i=x]px​=∑[ci​=x]（当然这个 ppp 是在更新的） 当正在处理 ae=xa_e=xae​=x 时（此处的 aaa 是原题的） 处理对 ansansans 的贡献 更新 ppp 假设 fff 为 eee 之后第一个满足 af=xa_f=xaf​=x 那么对于 ce,ce+1,⋯ ,cf−1c_e,c_{e+1},\\cdots,c_{f-1}ce​,ce+1​,⋯,cf−1​ 为一个 d=−1d=-1d=−1的等差数列 记 g=ce,h=cf−1g=c_e,h=c_{f-1}g=ce​,h=cf−1​ 注意 h&lt;gh&lt;gh&lt;g ∑i=hg∑j=−∞i−1pj=(g−h+1)∑i=−∞h−1pi+∑i=hg−1(g−i)pi=(g−h+1)∑i=−∞h−1pi+g∑i=hg−1pi−∑i=hg−1i⋅pi \\begin{aligned} \\sum_{i=h}^g\\sum_{j=-\\infin}^{i-1}p_j &amp;=(g-h+1)\\sum_{i=-\\infin}^{h-1}p_i+\\sum_{i=h}^{g-1}(g-i)p_i\\\\ &amp;=(g-h+1)\\sum_{i=-\\infin}^{h-1}p_i+g\\sum_{i=h}^{g-1}p_i-\\sum_{i=h}^{g-1}i\\cdot p_i \\end{aligned} i=h∑g​j=−∞∑i−1​pj​​=(g−h+1)i=−∞∑h−1​pi​+i=h∑g−1​(g−i)pi​=(g−h+1)i=−∞∑h−1​pi​+gi=h∑g−1​pi​−i=h∑g−1​i⋅pi​​即需要维护 pip_ipi​ 和 i⋅pii\\cdot p_ii⋅pi​ ，可以通过开两个线段树解决，需支持区间求和、修改 常数极其巨大，最长一个点跑了 2.33s（未 -O2） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;const int N = 500000;const int FIX = N + 1;struct S { struct Seg1 { struct Node { Node *ls, *rs; ll sum, tag; int clear; int l, r; int dis() { return r - l + 1; } void pushdown() { if (clear) ls-&gt;clear = rs-&gt;clear = 1, ls-&gt;tag = rs-&gt;tag = ls-&gt;sum = rs-&gt;sum = 0, clear = 0; ls-&gt;sum += ls-&gt;dis() * tag, ls-&gt;tag += tag; rs-&gt;sum += rs-&gt;dis() * tag, rs-&gt;tag += tag; tag = 0; } void maintain() { sum = ls-&gt;sum + rs-&gt;sum; } } T[8 * N]; int cnt = 0, L, R; Node* root; Seg1() { build(root, 1, N + FIX); } void build(Node*&amp; c, int l, int r) { c = &amp;T[cnt++]; c-&gt;l = l, c-&gt;r = r; if (l == r) return; int mid = (l + r) / 2; build(c-&gt;ls, l, mid), build(c-&gt;rs, mid + 1, r); } void clear() { root-&gt;sum = root-&gt;tag = 0, root-&gt;clear = 1; } void _e(Node* c) { if (L &lt;= c-&gt;l &amp;&amp; c-&gt;r &lt;= R) { c-&gt;tag += 1, c-&gt;sum += c-&gt;dis(); return; } if (c-&gt;r &lt; L || R &lt; c-&gt;l) return; c-&gt;pushdown(); _e(c-&gt;ls), _e(c-&gt;rs); c-&gt;maintain(); } ll _q(Node* c) { if (L &lt;= c-&gt;l &amp;&amp; c-&gt;r &lt;= R) return c-&gt;sum; if (c-&gt;r &lt; L || R &lt; c-&gt;l) return 0; c-&gt;pushdown(); return _q(c-&gt;ls) + _q(c-&gt;rs); } void edit(int l, int r) { L = l + FIX, R = r + FIX; _e(root); } ll query(int l, int r) { L = l + FIX, R = r + FIX; return _q(root); } void print(Node* c) { if (!c) return; cout &lt;&lt; c-&gt;l &lt;&lt; ' ' &lt;&lt; c-&gt;r &lt;&lt; endl; print(c-&gt;ls), print(c-&gt;rs); } } s1; struct Seg2 { int cnt = 0, L, R; struct Node { Node *ls, *rs; ll sum, tag; int clear; int l, r; ll calc() { return ((ll)l + r - 2 * FIX) * (r - l + 1) / 2; } int dis() { return r - l + 1; } void pushdown() { if (clear) ls-&gt;clear = rs-&gt;clear = 1, ls-&gt;tag = rs-&gt;tag = ls-&gt;sum = rs-&gt;sum = 0, clear = 0; ls-&gt;sum += ls-&gt;calc() * tag, ls-&gt;tag += tag; rs-&gt;sum += rs-&gt;calc() * tag, rs-&gt;tag += tag; tag = 0; } void maintain() { sum = ls-&gt;sum + rs-&gt;sum; } } T[8 * N]; Node* root; Seg2() { build(root, 1, N + FIX); } void build(Node*&amp; c, int l, int r) { c = &amp;T[cnt++]; c-&gt;l = l, c-&gt;r = r; if (l == r) return; int mid = (l + r) / 2; build(c-&gt;ls, l, mid), build(c-&gt;rs, mid + 1, r); } void clear() { root-&gt;sum = root-&gt;tag = 0, root-&gt;clear = 1; } void _e(Node* c) { if (L &lt;= c-&gt;l &amp;&amp; c-&gt;r &lt;= R) { c-&gt;tag += 1, c-&gt;sum += c-&gt;calc(); return; } if (c-&gt;r &lt; L || R &lt; c-&gt;l) return; c-&gt;pushdown(); _e(c-&gt;ls), _e(c-&gt;rs); c-&gt;maintain(); } ll _q(Node* c) { if (L &lt;= c-&gt;l &amp;&amp; c-&gt;r &lt;= R) return c-&gt;sum; if (c-&gt;r &lt; L || R &lt; c-&gt;l) return 0; c-&gt;pushdown(); return _q(c-&gt;ls) + _q(c-&gt;rs); } void edit(int l, int r) { L = l + FIX, R = r + FIX; _e(root); } ll query(int l, int r) { L = l + FIX, R = r + FIX; return _q(root); } } s2; void clear() { s1.clear(), s2.clear(); } void edit(int l, int r) { if (l &gt; r) std::swap(l, r); // cerr &lt;&lt; &quot;editing&quot; &lt;&lt; endl; // rep(i, l, r) cerr &lt;&lt; s1.query(i, i) &lt;&lt; ' '; // cerr &lt;&lt; endl; s1.edit(l, r), s2.edit(l, r); // rep(i, l, r) cerr &lt;&lt; s1.query(i, i) &lt;&lt; ' '; // cerr &lt;&lt; endl; } ll query(ll x, ll y) { if (x &gt; y) std::swap(x, y); return (y - x + 1) * s1.query(-N, x - 1) + y * s1.query(x, y - 1) - s2.query(x, y - 1); }} s;int n, a[N + 10];struct X { struct Node { int pos; Node* nxt; } pool[N + 10]; Node* p[N + 10]; Node* end[N + 10]; int cnt = 0; void add(int x, int pos) { pool[cnt].pos = pos, pool[cnt].nxt = nullptr; // p[x] = &amp;pool[cnt++]; if (p[x] == nullptr) p[x] = &amp;pool[cnt], end[x] = &amp;pool[cnt]; else end[x]-&gt;nxt = &amp;pool[cnt], end[x] = &amp;pool[cnt]; cnt++; } bool empty(int x) { return p[x] == nullptr; } void del(int x) { p[x] = p[x]-&gt;nxt; } int ask(int x) { return p[x] != nullptr ? p[x]-&gt;pos : (n + 1); }} q;int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int t; cin &gt;&gt; n &gt;&gt; t; rep(i, 1, n) { cin &gt;&gt; a[i]; q.add(a[i], i); } ll ans = 0; rep(x, 0, n) { // cerr &lt;&lt; &quot;doing &quot; &lt;&lt; x &lt;&lt; endl; if (q.empty(x)) continue; s.clear(); int pre = 0, lst = 0, cur, nxt; while (!q.empty(x)) { cur = q.ask(x); // cerr &lt;&lt; &quot;cur &quot; &lt;&lt; cur &lt;&lt; endl; q.del(x); s.edit(2 * pre - lst, 2 * pre - (cur - 1)); // cerr &lt;&lt; &quot;value &quot; &lt;&lt; 2 * pre - lst &lt;&lt; ' ' &lt;&lt; 2 * pre - (cur - 1) &lt;&lt; endl; // cerr &lt;&lt; &quot;edit &quot; &lt;&lt; lst &lt;&lt; ' ' &lt;&lt; cur - 1 &lt;&lt; endl; pre++, lst = cur; nxt = q.ask(x); // cerr &lt;&lt; &quot;ans &quot; &lt;&lt; s.query(2 * pre - cur, 2 * pre - (nxt - 1)) &lt;&lt; endl; // cerr &lt;&lt; &quot;dbg &quot; &lt;&lt; s.s1.query(0, 2 * pre - (nxt - 1)) &lt;&lt; endl; ans += s.query(2 * pre - cur, 2 * pre - (nxt - 1)); } } cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Yazid%E7%9A%84%E6%96%B0%E7%94%9F%E8%88%9E%E4%BC%9A"},{"title":"「POJ 1201」Intervals","text":"这是一个贪心+线段树的解法，复杂度是 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n) 把要求按 bbb 升序排序，修改时用二分套线段树 其他题解怎么都是一个一个跳的，复杂度不会挂吗？ 线段树部分写得比较神奇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;#define ls (u &lt;&lt; 1)#define rs ((u &lt;&lt; 1) | 1)const int N = 50010;inline int lowbit(int x) { return x &amp; (-x); }struct N { int sum, tag;} T[N * 4];int L, R;inline void pushdown(int u, int l, int r) { if (T[u].tag) { T[ls].tag = T[rs].tag = 1; int mid = (l + r) / 2; T[ls].sum = mid - l + 1, T[rs].sum = r - mid; }}inline void pushup(int u) { T[u].sum = T[ls].sum + T[rs].sum; }int _q(int u, int l, int r) { int mid = (l + r) / 2; if (r &lt; L || R &lt; l) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return T[u].sum; pushdown(u, l, r); return _q(ls, l, mid) + _q(rs, mid + 1, r);}int q(int l, int r) { L = l, R = r; return _q(1, 1, N);}void _a(int u, int l, int r) { if (r &lt; L || R &lt; l) return; // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; if (L &lt;= l &amp;&amp; r &lt;= R) { // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; T[u].tag = 1; T[u].sum = r - l + 1; // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; T[u].sum &lt;&lt; endl; return; } int mid = (l + r) / 2; _a(ls, l, mid), _a(rs, mid + 1, r); pushup(u);}void add(int l, int r) { // cerr &lt;&lt; &quot;ADD &quot; &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; L = l, R = r; _a(1, 1, N);}struct Node { int a, b, c;} a[N];bool cmp(const Node &amp;a, const Node &amp;b) { return a.b &lt; b.b; }int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n; cin &gt;&gt; n; rep(i, 1, n) { cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c; a[i].a++, a[i].b++; } std::sort(a + 1, a + 1 + n, cmp); int ans = 0; rep(i, 1, n) { int u = a[i].c - q(a[i].a, a[i].b); if (u &gt; 0) { int l = a[i].a, r = a[i].b; while (l + 1 &lt; r) { // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; int mid = (l + r) / 2; int qa = q(mid, a[i].b); if (a[i].b - mid + 1 - qa &gt;= u) l = mid; else r = mid - 1; } if (a[i].b - r + 1 == u + q(r, a[i].b)) add(r, a[i].b); else add(l, a[i].b); } } cout &lt;&lt; q(1, N); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/intervals"},{"title":"Jury Compromise","text":"尽量充分利用状态，降低复杂度，另外一道题 状态设计比较巧妙 FFF[ 剩余空间 ][ 辩方总分 - 控方总分 ] = 辩方总分 + 控方总分 跑一个背包 F[v+1,x+ai−bi]=max⁡{F[v,x]+ai+bi,F[v+1,x+ai−bi]}F[v+1, x + a_i - b_i] = \\max\\{F[v, x] + a_i + b_i, F[v+1, x + a_i - b_i]\\}F[v+1,x+ai​−bi​]=max{F[v,x]+ai​+bi​,F[v+1,x+ai​−bi​]} 找方案比较麻烦，如果直接记由哪个状态转移来是不行的，因为后续更新会破坏 所以要搞一个类似链表的东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;int f[202][9000], a[202], b[202], path[202][9000];const int fix = 4500;struct Node { int prev, i;} p[10000000];int cnt = 1;void output(int id) { if (p[id].i == 0) return; output(p[id].prev); cout &lt;&lt; ' ' &lt;&lt; p[id].i;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, m; // clang-format off int T = 0; while (cin &gt;&gt; n &gt;&gt; m) { ++T; cnt = 1; if (n == 0 &amp;&amp; m == 0) break; rep(i, 1, n) cin &gt;&gt; a[i] &gt;&gt; b[i]; rep(i, 0, 201) rep(j, 0, 8999) f[i][j] = -1000000, path[i][j] = 0; f[0][0 + fix] = 0; rep(i, 1, n) per(v, m, 0) rep(x, -4000, 4000) { if (f[v][x + fix] + a[i] + b[i] &gt; f[v + 1][x + a[i] - b[i] + fix]) { f[v + 1][x + a[i] - b[i] + fix] = f[v][x + fix] + a[i] + b[i], // path[v + 1][x + a[i] - b[i] + fix] = i; path[v + 1][x + a[i] - b[i] + fix] = cnt; p[cnt].i = i, p[cnt++].prev = path[v][x + fix]; } } // clang-format on rep(i, 0, 4000) { if (f[m][i + fix] &gt;= 0 || f[m][-i + fix] &gt;= 0) { cout &lt;&lt; &quot;Jury #&quot; &lt;&lt; T &lt;&lt; endl; if (f[m][i + fix] &gt; f[m][-i + fix]) { cout &lt;&lt; &quot;Best jury has value &quot; &lt;&lt; (f[m][i + fix] + i) / 2 &lt;&lt; &quot; for prosecution and value &quot; &lt;&lt; (f[m][i + fix] - i) / 2 &lt;&lt; &quot; for defence:&quot; &lt;&lt; endl; // cout &lt;&lt; f[m][i + fix] &lt;&lt; endl; output(path[m][i + fix]); } else { cout &lt;&lt; &quot;Best jury has value &quot; &lt;&lt; (f[m][fix - i] - i) / 2 &lt;&lt; &quot; for prosecution and value &quot; &lt;&lt; (f[m][fix - i] + i) / 2 &lt;&lt; &quot; for defence:&quot; &lt;&lt; endl; output(path[m][fix - i]); } cout &lt;&lt; endl &lt;&lt; endl; break; } } } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/jury-compromise"},{"title":"Network，闇の連鎖","text":"仔细分析，考虑树上，若断一条树边 (u,v)(u, v)(u,v)，则会分成两个连通块 两个连通块之间有 000 条附加边，则任意再切一条 两个连通块之间有 111 条附加边，则只能切特定的一条 两个连通块之间有 ≥2\\geq 2≥2 条附加边，无方案 如何快速计数？ 记附加边为 (x,y)(x,y)(x,y) ，发现 (u,x),(v,y)(u, x),(v,y)(u,x),(v,y) 两条路径不相交则 (x,y)(x,y)(x,y) 对 (u,v)(u,v)(u,v) 有影响 即，附加边 (x,y)(x,y)(x,y) 对于主要边树上 (x,y)(x,y)(x,y) 路径上所有边都有影响 或者说，附加边 (x,y)(x,y)(x,y) 会在树上产生环，如果切环上的边就必须把 (x,y)(x,y)(x,y) 切掉 然后就是树上边差分 POJ 上 TLE 了，但是本地没问题，复杂度（应该）没挂？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 100010;std::vector&lt;int&gt; g[N], ng[N];int fa[20][N], dep[N], val[N];void dfs(int u) { for (int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if (v == fa[0][u]) continue; fa[0][v] = u; dep[v] = dep[u] + 1; dfs(v); }}int up(int u, int l) { for (int i = 19; i &gt;= 0; --i) { if (l &gt;= (1 &lt;&lt; i)) u = fa[i][u], l -= 1 &lt;&lt; i; } return u;}int q(int u, int v) { if (dep[u] &lt; dep[v]) std::swap(u, v); u = up(u, dep[u] - dep[v]); if (u == v) return u; for (int i = 19; i &gt;= 0; --i) if (fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v]; return fa[0][u];}int n, m, ans;int calc(int u) { int ret = 0; for (int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if (v == fa[0][u]) continue; v = calc(v); if (v == 0) ans += m; else if (v == 1) ans += 1; ret += v; } return ret + val[u];}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int u, v; cin &gt;&gt; n &gt;&gt; m; rep(i, 2, n) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v), g[v].push_back(u); } dep[1] = 1; dfs(1); // cerr &lt;&lt; &quot;dfs over&quot; &lt;&lt; endl; rep(k, 1, 19) rep(i, 1, n) fa[k][i] = fa[k - 1][fa[k - 1][i]]; // cerr &lt;&lt; &quot;dfs over&quot; &lt;&lt; endl; rep(i, 1, m) { cin &gt;&gt; u &gt;&gt; v; val[u] += 1; val[v] += 1; val[q(u, v)] -= 2; } calc(1); cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/network"},{"title":"「USACO 2013」Photo","text":"给定长为 n≤2×105n\\le 2\\times 10^5n≤2×105 的序列，你需要将其中 kkk 个节点染色，满足 m≤105m\\le 10^5m≤105 组条件：[li,ri][l_i, r_i][li​,ri​] 中有且仅有一个节点被染色。 最大化 kkk 题面，数据 又是一道神 DP，虐爆我 定义 fif_ifi​ 为在最后在 iii 染色，并且保证 1∼i1\\sim i1∼i 合法的最多染色个数 考虑如何由 fj j&lt;if_j\\, j&lt;ifj​j&lt;i 推得 fif_ifi​ 如果要染 iii ，如果 限制条件 xxx 包含 iii（ 即 i∈[lx,rx]i\\in[l_x, r_x]i∈[lx​,rx​] ） 由于需要满足 仅有一个 ，所以 j&lt;min⁡i≤rxlxj&lt;\\min_{i\\le r_x} l_xj&lt;mini≤rx​​lx​ （当然也要满足 j&lt;ij&lt;ij&lt;i ） 若从 jjj 转移，则意味着 j+1∼i−1j+1 \\sim i-1j+1∼i−1 都不会选了，由于需要满足 至少一个 ，则 j≥max⁡rx&lt;ilxj\\ge \\max_{r_x&lt;i} l_xj≥maxrx​&lt;i​lx​ 预处理 12345678910#define ckmin(x, y) x = std::min(x, y)#define ckmax(x, y) x = std::max(x, y)while (m--) { int l, r; cin &gt;&gt; l &gt;&gt; r; ckmin(minl[r], l); ckmax(maxl[r + 1], l);}per(i, n, 1) ckmin(minl[i], minl[i + 1]);rep(i, 1, n + 1) ckmax(maxl[i], maxl[i - 1]);// 注意边界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 200100;int maxl[N], minl[N], f[N];#define ckmin(x, y) x = std::min(x, y)#define ckmax(x, y) x = std::max(x, y)int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n, m; io.read(n), io.read(m); rep(i, 0, n + 1) minl[i] = i; while (m--) { int l, r; io.read(l), io.read(r); ckmin(minl[r], l); ckmax(maxl[r + 1], l); } per(i, n, 1) ckmin(minl[i], minl[i + 1]); rep(i, 1, n + 1) ckmax(maxl[i], maxl[i - 1]); std::deque&lt;int&gt; q; int ptr = 1; q.push_back(0); rep(i, 1, n + 1) { for (; ptr &lt; minl[i]; ptr++) { if (f[ptr] == -1) continue; while (q.size() &amp;&amp; f[q.back()] &lt;= f[ptr]) q.pop_back(); q.push_back(ptr); } while (q.size() &amp;&amp; q.front() &lt; maxl[i]) q.pop_front(); if (q.size()) f[i] = f[q.front()] + (i == n + 1 ? 0 : 1); else f[i] = -1; } io.write(f[n + 1]); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/photo"},{"title":"创世纪","text":"题目概述 上帝手中有 N≤105N \\le 10^5N≤105 种世界元素，每种元素可以限制另外 111 种元素，把第 iii 种世界元素能够限制的那种世界元素记为 A[i]A[i]A[i]。 现在，上帝要把它们中的一部分投放到一个新的空间中去建造世界。 为了世界的和平与安宁，上帝希望所有被投放的世界元素都有至少一个没有被投放的世界元素限制它。 上帝希望知道，在此前提下，他最多可以投放多少种世界元素？ 感觉网上的贪心题解都稍有问题？ 单纯考虑一个树（不是基环树），发现可直接从子节点贪心得出父节点状态 首先，这是一个内向树森林 考虑一颗内向基环树 TTT，环上节点为 s1,s2,⋯ ,sts_1, s_2, \\cdots,s_ts1​,s2​,⋯,st​ 对每一个环上节点和其子树分开执行贪心（这只是描述，实际上用拓扑排序递推） 如果 TTT 是一个环，则 t/2t/2t/2 如果存在一个 sis_isi​ 由贪心过程得出它可以投放，则环就会断成链 如果不存在，则环还是完整的，t/2t/2t/2 贪心过程由拓扑排序执行，讨论 2 可以直接在这个过程中完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 1000010;int n, a[N], deg[N], q[N], l, r, vis[N];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); cin &gt;&gt; n; rep(i, 1, n) { cin &gt;&gt; a[i]; deg[a[i]]++; } l = 1, r = 0; rep(i, 1, n) if (deg[i] == 0) q[++r] = i; int ans = 0; while (l &lt;= r) { int u = q[l++], v = a[u]; if (!vis[u] &amp;&amp; !vis[a[u]]) { vis[v] = 1; ans++; deg[a[a[u]]]--; if (deg[a[a[u]]] == 0) q[++r] = a[a[u]]; } vis[u] = 1; } rep(i, 1, n) { if (!vis[i]) { int u = i; int cnt = 0; do { vis[u] = 1, cnt++, u = a[u]; } while (u != i); ans += cnt / 2; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E5%88%9B%E4%B8%96%E7%BA%AA"},{"title":"雅礼集训瞎做","text":"&nbsp;&nbsp;anomalous by Alcxome ¶ 2017 ¶ 「雅礼集训 2017 Day1」市场 支持区间减，区间整除，区间最小查询，区间和查询。 线段树，考虑一个区间的最大值 aaa 和最小值 bbb 若 k=a−⌊a/d⌋=b−⌊b/d⌋k=a-\\lfloor a/d \\rfloor = b-\\lfloor b/d \\rfloork=a−⌊a/d⌋=b−⌊b/d⌋， 则对于 a&lt;c&lt;ba&lt;c&lt;ba&lt;c&lt;b 有 c−⌊c/d⌋=kc-\\lfloor c/d\\rfloor=kc−⌊c/d⌋=k 事实上满足上述的只有 a=ba=ba=b 或 a=b+1a=b+1a=b+1 证明可令 a=αk+p1,b=βk+p2a=\\alpha k+p_1,b=\\beta k+p_2a=αk+p1​,b=βk+p2​ 具体略 于是可转化为区间减处理。 做法和复杂度都很神秘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii; typedef pair&lt;int, ll&gt; pil;const int N = 100010;inline int fdiv(int x, int y){ if (x &gt;= 0) return x/y; else return (x-y+1)/y;}struct Node{ int l, r, max, min, tag; ll sum; Node *lc, *rc; void add(int x){ max += x, min += x, tag += x, sum += (r-l+1)*x; } void pushdown(){ if (tag != 0){ lc-&gt;add(tag); rc-&gt;add(tag); tag = 0; } } void maintain(){ max = std::max(lc-&gt;max, rc-&gt;max); min = std::min(lc-&gt;min, rc-&gt;min); sum = lc-&gt;sum + rc-&gt;sum; } void add(int l, int r, int x){ if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r){ add(x); return; } pushdown(); if (l &lt;= lc-&gt;r) lc-&gt;add(l, r, x); if (rc-&gt;l &lt;= r) rc-&gt;add(l, r, x); maintain(); } void div(int l, int r, int x){ if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r &amp;&amp; max - fdiv(max, x) == min - fdiv(min, x)){ add(fdiv(max, x) - max); return; } // if (max - fdiv(max, x) == min - fdiv(min, x)){ // add(l, r, fdiv(max, x) - max); // return; // } pushdown(); if (l &lt;= lc-&gt;r) lc-&gt;div(l, r, x); if (rc-&gt;l &lt;= r) rc-&gt;div(l, r, x); maintain(); } ll qsum(int l, int r){ if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) return sum; ll ret = 0; pushdown(); if (l &lt;= lc-&gt;r) ret += lc-&gt;qsum(l, r); if (rc-&gt;l &lt;= r) ret += rc-&gt;qsum(l, r); return ret; } int qmin(int l, int r){ if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) return min; int ret = 1e9; pushdown(); if (l &lt;= lc-&gt;r) ret = std::min(ret, lc-&gt;qmin(l, r)); if (rc-&gt;l &lt;= r) ret = std::min(ret, rc-&gt;qmin(l, r)); return ret; } void show(){ if (l == r){ cerr &lt;&lt; max &lt;&lt; ' '; return; } pushdown(); lc-&gt;show(); rc-&gt;show(); }} T[N*4]; int c = 0;Node* build(int l, int r){ Node* ret = &amp;T[c++]; ret-&gt;l = l, ret-&gt;r = r; if (l != r){ int mid = (l+r)/2; ret-&gt;lc = build(l, mid); ret-&gt;rc = build(mid+1, r); ret-&gt;maintain(); } else { cin &gt;&gt; ret-&gt;min; ret-&gt;max = ret-&gt;sum = ret-&gt;min; } return ret;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; Node* tree = build(0, n-1); while(q--){ int opt; cin &gt;&gt; opt; if (opt == 1){ int l, r, c; cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; tree-&gt;add(l, r, c); } else if (opt == 2){ int l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; tree-&gt;div(l, r, d); } else if (opt == 3){ int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; tree-&gt;qmin(l, r) &lt;&lt; '\\n'; } else { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; tree-&gt;qsum(l, r) &lt;&lt; '\\n'; } } return 0;} ¶ 「雅礼集训 2017 Day1」矩阵 操作就是把一行赋给一列，不难发现，若最后列要都变黑，那么作为模板的行必须全黑。 于是现在考虑如何将第 iii 行变全黑，记第 iii 行的白点数为 ccc 若第 iii 列存在一个黑点，那么代价为 ccc 若第 iii 行存在一个黑点，可先将这个点转到第 iii 列，那么代价为 c+1c+1c+1 如果一列全黑，则不用赋，用 ddd 体现 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii; typedef pair&lt;int, ll&gt; pil;const int N = 2010, inf = 1e8;int hang[N], lie[N], cnt[N], cntlie[N];char g[N][N];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int n; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; g[i] + 1; int ans = inf; rep(i, 1, n){ rep(j, 1, n) if (g[i][j] == '.') cnt[i]++; hang[i] = (cnt[i] &lt; n); } int d = n; rep(j, 1, n){ rep(i, 1, n) if (g[i][j] == '.') cntlie[j]++; lie[j] = (cntlie[j] &lt; n); d -= (cntlie[j] == 0); } rep(i, 1, n){ int t = 0; bool flag = 0; if (lie[i]) flag = 1; else if (hang[i]) flag = 1, t = 1; if (flag){ ans = std::min(ans, t + cnt[i] + d); } } if (ans == inf) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; return 0;} ¶ 「雅礼集训 2017 Day2」水箱 看到了好几个做法，可并堆不会就不介绍了 解法都须利用挡板带来的性质。 ¶ 并查集 这种做法比较玄妙，我对着代码瞪了一点时间才搞明白。 首先把条件和挡板都看作一个操作，按高度从小到大排序。 水高 hhh 从小到达考虑 对于每个水箱，有 fff 和 ggg 两个属性，fff 为该水箱 水高 ≤h\\le h≤h 的最大答案，ggg 是当前 hhh 下水箱的最大答案。 当考虑挡板时，用并查集合并，fff 相加，ggg 相加。 当考虑 k=0k=0k=0 时，f=f+1f=f+1f=f+1 当考虑 k=1k=1k=1 时，g=g+1g=g+1g=g+1，用 ggg 更新 fff 这个方法的正确性在于，在每个水箱影响到其他水箱之前，互相影响的水箱就合并了，统一考虑对答案的影响。 注意同一高度，优先级为 挡板、k=0k=0k=0 、k=1k=1k=1 （数据水测不出来） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii; typedef pair&lt;int, ll&gt; pil;const int N = 100010;namespace DisjointSetUnion {template &lt;int N&gt;struct DisjointSetUnion { int fa[N]; DisjointSetUnion() { for (register int i = 0; i &lt; N; ++i) fa[i] = i; } int getf(int x) { return fa[x] = (fa[x] == x ? x : getf(fa[x])); } inline void merge(int x, int y) { fa[getf(x)] = getf(y); } inline bool same(int x, int y) { return getf(x) == getf(y); }};}; // namespace DisjointSetUnionDisjointSetUnion::DisjointSetUnion&lt;N&gt; dsu;struct OPT{ int i, y, k;} q[N+N];inline bool cmp(const OPT&amp; a, const OPT&amp; b){ return a.y != b.y ? a.y &lt; b.y : a.k &lt; b.k;}int f[N], g[N];void solve(){ for (register int i = 0; i &lt; N; ++i) dsu.fa[i] = i; std::memset(f, 0, sizeof(f)); std::memset(g, 0, sizeof(g)); int n, m; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; rep(i, 1, n - 1){ q[++cnt].i = i; cin &gt;&gt; q[cnt].y; q[cnt].k = -1; } rep(i, 1, m){ ++cnt; cin &gt;&gt; q[cnt].i &gt;&gt; q[cnt].y &gt;&gt; q[cnt].k; } std::sort(q+1, q+1+cnt, cmp); rep(qaq, 1, cnt){ int i = q[qaq].i, y = q[qaq].y, k = q[qaq].k; if (k == -1){ int j = dsu.getf(i + 1); i = dsu.getf(i); f[i] += f[j], g[i] += g[j]; dsu.fa[j] = i; } else if (k == 0){ i = dsu.getf(i); f[i]++; // y + 0.5 无水 } else { i = dsu.getf(i); g[i]++; f[i] = std::max(f[i], g[i]); // y + 0.5 有水 } } cout &lt;&lt; f[dsu.getf(1)] &lt;&lt; endl;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int T; cin &gt;&gt; T; while(T--) solve();} ¶ 动态规划 + 线段树 fi,jf_{i, j}fi,j​ 为第 iii 个水箱高度为 jjj 是最大答案，转移是显然的，可用线段树优化。 ¶ 主席树 + 分治 定义 g(l,r,x)g(l, r, x)g(l,r,x) 为 l⋯rl\\cdots rl⋯r 水箱，水高 xxx 时的答案 定义 f(l,r)f(l,r)f(l,r) 为 l⋯rl\\cdots rl⋯r 水箱，水高不超过 lll 左侧挡板高 h1h_1h1​ 且不超过 rrr 右侧挡板高 h2h_2h2​ 的最优答案。 考虑 l≤k&lt;rl\\le k&lt;rl≤k&lt;r 且 kkk 右边的挡板为 l⋯rl\\cdots rl⋯r 中最高的（除了两边）。 转移依旧显然，记 kkk 右边的挡板高度为 lll f(l,r)=max⁡{f(l,k)+f(k+r,r)max⁡l&lt;x≤min⁡h1,h2g(l,r,x) f(l,r) = \\max\\left\\{ \\begin{aligned} &amp;f(l,k) + f(k+r,r)\\\\ &amp;\\max_{l&lt;x\\le \\min h_1,h_2} g(l, r, x) \\end{aligned} \\right. f(l,r)=max⎩⎪⎨⎪⎧​​f(l,k)+f(k+r,r)l&lt;x≤minh1​,h2​max​g(l,r,x)​ggg 用主席树快速计算（单点修改，区间询问，xxx 的取值很少） ¶ 「雅礼集训 2017 Day2」线段游戏 据说是李超树模板，不过我不会 每个节点存储从上传下来的在 midmidmid 处最大的线段。 十分玄妙，请看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii; typedef pair&lt;int, ll&gt; pil;typedef double real;real inline c(real&amp; k, real&amp; b, int x){ return k*x + b; }struct Node{ real k, b; Node *lc, *rc; int l, r; inline real get(int x){ return c(this-&gt;k, this-&gt;b, x); } void insert(int l, int r, real k, real b){ // assert(r &gt;= this-&gt;l); assert(l &lt;= this-&gt;r); int mid = (this-&gt;l+this-&gt;r)/2; if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r){ if (get(l) &gt;= c(k, b, l) &amp;&amp; get(r) &gt;= c(k, b, r)) return; // if (l == r &amp;&amp; l == 1) cerr &lt;&lt; c(k, b, 1) &lt;&lt; endl; if (get(l) &lt; c(k, b, l) &amp;&amp; get(r) &lt; c(k, b, r)){ this-&gt;k = k, this-&gt;b = b; return; } real o = get(mid), n = c(k, b, mid); if (o &lt;= n) { if (this-&gt;l == this-&gt;r) ; else if (k &gt; this-&gt;k) lc-&gt;insert(l, r, this-&gt;k, this-&gt;b); else rc-&gt;insert(l, r, this-&gt;k, this-&gt;b); this-&gt;k = k, this-&gt;b = b; } else { if (this-&gt;l == this-&gt;r) return; if (k &gt; this-&gt;k) rc-&gt;insert(l, r, k, b); else lc-&gt;insert(l, r, k, b); } return; } // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; this-&gt;l &lt;&lt; ' ' &lt;&lt; this-&gt;r &lt;&lt; endl; // assert(this-&gt;l != this-&gt;r); if (l &lt;= mid) lc-&gt;insert(l, r, k, b); if (mid &lt; r) rc-&gt;insert(l, r, k, b); } real query(int x){ real ret = get(x); // cerr &lt;&lt; x &lt;&lt; ' ' &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; get(x) &lt;&lt; endl; if (l != r){ if (x &lt;= lc-&gt;r) ret = std::max(ret, lc-&gt;query(x)); else ret = std::max(ret, rc-&gt;query(x)); } return ret; }} T[100000*4];Node* tree;int xa, ya, xb, yb;void insert(){ real k, b; if (xa == xb){ k = 0; b = std::max(ya, yb); } else { k = ((real)ya-yb)/(xa-xb); b = (real)ya - k * xa; } if (std::min(xa, xb) &gt; 100000 || std::max(xa, xb) &lt; 1) return; tree-&gt;insert(std::max(std::min(xa, xb), 1), std::min(std::max(xa, xb), 100000), k, b);}int cnt = 0;Node* build(int l, int r){ Node* ret = &amp;T[cnt++]; ret-&gt;l = l, ret-&gt;r = r; ret-&gt;k = 0; ret-&gt;b = -1e13; if (l != r){ int mid = (l+r)/2; ret-&gt;lc = build(l, mid); ret-&gt;rc = build(mid+1, r); } return ret;}int main() {#ifdef LOCAL freopen(&quot;C2.in&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; tree = build(1, 100000); cerr &lt;&lt; &quot;built&quot; &lt;&lt; endl; rep(i, 1, n){ cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb; insert(); } cerr &lt;&lt; &quot;in&quot; &lt;&lt; endl; cout.setf(std::ios::fixed); while(m--){ int op; cin &gt;&gt; op; if (op == 0){ cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb; insert(); } else { int x; cin &gt;&gt; x; real res = tree-&gt;query(x); if (res &lt; -1e12) cout &lt;&lt; &quot;0\\n&quot;; else cout &lt;&lt; std::setprecision(3) &lt;&lt; res &lt;&lt; '\\n'; } } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/yali-training"},{"title":"奶牛玩杂技","text":"非常棒的贪心题，我是完全没有想到解法。看了一波题解，证明如下： 若现在要处理两头牛 aaa, bbb 记 www, sss 分别为 waw_awa​ sas_asa​ wbw_bwb​ sbs_bsb​ 设在在 aaa, bbb 上面全部牛的质量为 www 假设 wa+sa&gt;wb+sbw_a + s_a &gt; w_b + s_bwa​+sa​&gt;wb​+sb​ 若 aaa 在上 bbb 在下，易得 aaa 压扁值为 w−saw - s_aw−sa​ bbb 压扁值为 w+wa−sbw + w_a - s_bw+wa​−sb​ 用作差法比较 w−sa−(w+wa−sb)=−sa−wa+sbw - s_a - (w + w_a - s_b) = -s_a -w_a + s_bw−sa​−(w+wa​−sb​)=−sa​−wa​+sb​ 根据 wa+sa&gt;wb+sbw_a + s_a &gt; w_b + s_bwa​+sa​&gt;wb​+sb​ 得 −wb&gt;−sa−wa+sb-w_b &gt; -s_a - w_a + s_b−wb​&gt;−sa​−wa​+sb​ 即 −sa−wa+sb&lt;0-s_a - w_a + s_b &lt; 0−sa​−wa​+sb​&lt;0 所以 w−sa&lt;w+wa−sbw-s_a &lt; w+w_a-s_bw−sa​&lt;w+wa​−sb​ 得 若最大压扁值需更新 w+wa−sbw+w_a-s_bw+wa​−sb​ 即为新的压扁值 若 aaa 在下 bbb 在下 bbb 压扁值为 w−sbw - s_bw−sb​ aaa 压扁值为 w+wb−saw + w_b - s_aw+wb​−sa​ 用作差法无法讨论出谁是新的压扁值 分类讨论 若 w−sb&lt;w+wb−saw-s_b &lt; w+w_b-s_aw−sb​&lt;w+wb​−sa​ 用作差法可得 w+wa−sb&gt;w+wb−saw+w_a-s_b &gt; w+w_b-s_aw+wa​−sb​&gt;w+wb​−sa​ 若 w−sb&gt;w+wb−saw-s_b &gt; w+w_b-s_aw−sb​&gt;w+wb​−sa​ 同理得 w+wa−sb&gt;w−sbw+w_a-s_b &gt; w-s_bw+wa​−sb​&gt;w−sb​ 综上 bbb 放在 aaa 上面更优 即若牛从上到下记为 1~nnn 必须满足 wi+si&lt;wi+1+si+1w_i + s_i &lt; w_{i+1} + s_{i+1}wi​+si​&lt;wi+1​+si+1​ 显然我没有证等于的情况，读者自己去想 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;struct cow { int w, s, sum;}a[50000];bool cmp(cow a, cow b){ return a.sum &lt; b.sum;}int main(){ int ans = -2100000000, n, w=0; std::scanf(&quot;%d&quot;, &amp;n); for (int i=0; i&lt;n; ++i){ std::scanf(&quot;%d%d&quot;, &amp;a[i].w, &amp;a[i].s); a[i].sum = a[i].w + a[i].s; } std::sort(a, a+n, cmp); for (int i=0;i&lt;n;++i){ ans = std::max(ans, w-a[i].s); w += a[i].w; } std::cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E5%A5%B6%E7%89%9B%E7%8E%A9%E6%9D%82%E6%8A%80"},{"title":"小白逛公园","text":"带修改最大子段和查询 考虑维护一棵线段树，节点 [l,r][l, r][l,r] 记录 最大子段和 mmm lll 开始的最大子段和 elelel rrr 结尾的最大子段和 ererer 可以非常方便地合并 然后考虑查询区间 [L,R][L, R][L,R]，当前节点为 [l,r][l, r][l,r] ，保证 [l,r]∩[L,R]≠∅[l,r]\\cap[L,R]\\neq \\varnothing[l,r]∩[L,R]=∅ [l,r]⊆[L,R][l, r]\\subseteq [L, R][l,r]⊆[L,R] 返回 (el, er) ，更新 ans r≤midr \\le midr≤mid 返回 q(ls) l&gt;midl &gt; midl&gt;mid 返回 q(rs) l≤mid&lt;rl \\le mid &lt; rl≤mid&lt;r 返回合并结果，更新 ans 一开始觉得 2 3 42\\ 3\\ 42 3 4 这么做不太严谨，但其实是可以保证正确性的 因为若 elelel 或 rlrlrl 不在 [L,R][L, R][L,R] 时，它们也不会再被用作更新 ans，反证法可证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int inf = 500000000;struct Node { int l, r; int el, er, m, s; Node *ls, *rs;} T[2000000];int cnt = 0;void upd(Node* c) { c-&gt;m = std::max(c-&gt;ls-&gt;m, std::max(c-&gt;rs-&gt;m, c-&gt;ls-&gt;er + c-&gt;rs-&gt;el)); c-&gt;el = std::max(c-&gt;ls-&gt;el, c-&gt;ls-&gt;s + c-&gt;rs-&gt;el); c-&gt;er = std::max(c-&gt;rs-&gt;er, c-&gt;ls-&gt;er + c-&gt;rs-&gt;s); c-&gt;s = c-&gt;ls-&gt;s + c-&gt;rs-&gt;s;}void build(Node*&amp; c, int l, int r) { c = &amp;T[cnt++]; c-&gt;l = l, c-&gt;r = r; if (l == r) { cin &gt;&gt; c-&gt;m; c-&gt;s = c-&gt;el = c-&gt;er = c-&gt;m; return; } int mid = (l + r) / 2; build(c-&gt;ls, l, mid), build(c-&gt;rs, mid + 1, r); upd(c);}int P, S;void e(Node* c) { if (c-&gt;l == c-&gt;r) { c-&gt;s = c-&gt;el = c-&gt;er = c-&gt;m = S; return; } if (P &lt;= c-&gt;ls-&gt;r) e(c-&gt;ls); else e(c-&gt;rs); upd(c);}// first el// second erint ans = 0, L, R;pii q(Node* c) { if (L &lt;= c-&gt;l &amp;&amp; c-&gt;r &lt;= R) { ans = std::max(ans, c-&gt;m); return pii(c-&gt;el, c-&gt;er); } int mid = c-&gt;ls-&gt;r; if (R &lt;= mid) return q(c-&gt;ls); else if (mid &lt; L) return q(c-&gt;rs); else { pii x = q(c-&gt;ls), y = q(c-&gt;rs); ans = std::max(ans, x.second + y.first); return pii(std::max(x.first, c-&gt;ls-&gt;s + y.first), std::max(y.second, c-&gt;rs-&gt;s + x.second)); }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; Node* rt = nullptr; build(rt, 1, n); while (m--) { int k; cin &gt;&gt; k; if (k == 1) { cin &gt;&gt; L &gt;&gt; R; if (L &gt; R) std::swap(L, R); ans = -inf; q(rt); cout &lt;&lt; ans &lt;&lt; endl; } else { cin &gt;&gt; P &gt;&gt; S; e(rt); } } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD"},{"title":"有线电视网","text":"这是一道树形 DP 首先是状态设计，由于用户人数相比耗费作为数组维度比较简单，所以这样设计 fff[节点编号][用户数] = 最大利润（ 可以 &lt;0&lt;0&lt;0 ） 考虑节点 uuu，如何从子节点 vvv 得到 把子节点的状态看成一种物品，就是分组背包了 外层倒序枚举 uuu 的用户（状态），内层枚举 vvv 人数（看成背包中的物品） 12345per(i, s, 1) rep(j, 1, t){ if (i - j &lt; 0) break; f[u][i] = max(f[u][i], f[u][i-j] + f[v][j] + w) } 复杂度不知道怎么证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;int f[3010][3010], n, m, val[3010];std::vector&lt;pii&gt; g[3010];int calc(int u) { f[u][0] = 0; if (u &gt; n - m) { f[u][1] = val[u]; return 1; } int s = 0; for (auto i : g[u]) { int v = i.first, w = i.second, t = calc(v); s += t; per(i, s, 1) { // int lim = std::min(t, i); rep(j, 1, t) { if (i &lt; j) break; f[u][i] = std::max(f[u][i], f[u][i - j] + f[v][j] - w); } } } return s;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; std::memset(f, 0x8F, sizeof(f)); int k, v, w; rep(u, 1, n - m) { cin &gt;&gt; k; while (k--) { cin &gt;&gt; v &gt;&gt; w; g[u].push_back(pii(v, w)); } } rep(i, n - m + 1, n) cin &gt;&gt; val[i]; calc(1); per(i, m, 0) if (f[1][i] &gt;= 0) { cout &lt;&lt; i; break; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91"},{"title":"花神游历各国","text":"因为 ai≤1012a_i\\le 10^{12}ai​≤1012 所以发现开非常少次数的根号就会到达 111，使答案不再改变 于是考虑对 [L,R][L,R][L,R] 区间开根时，若 max⁡ai≤1\\max a_i \\le 1maxai​≤1 就不用操作了 通过在递归过程中判断实现 所以线段树维护区间和与区间最大 辣鸡 BZOJ 评测机，笔记本都只要跑 300ms，在你的老爷 CPU 上直接 TLE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;struct Node { int l, r; ll s, m; Node *ls, *rs;} T[400000];int cnt = 0;inline void upd(Node* c) { c-&gt;s = c-&gt;ls-&gt;s + c-&gt;rs-&gt;s; c-&gt;m = std::max(c-&gt;ls-&gt;m, c-&gt;rs-&gt;m);}void build(Node*&amp; c, int l, int r) { if (c == NULL) c = &amp;T[cnt++]; c-&gt;l = l, c-&gt;r = r; if (l == r) { cin &gt;&gt; c-&gt;m; c-&gt;s = c-&gt;m; return; } int mid = (l + r) / 2; build(c-&gt;ls, l, mid); build(c-&gt;rs, mid + 1, r); upd(c);}int L, R;ll qs(Node* c) { if (c-&gt;r &lt; L || R &lt; c-&gt;l) return 0; if (L &lt;= c-&gt;l &amp;&amp; c-&gt;r &lt;= R) return c-&gt;s; return qs(c-&gt;ls) + qs(c-&gt;rs);}void edit(Node* c) { if (c-&gt;r &lt; L || R &lt; c-&gt;l || c-&gt;m &lt;= 1) return; if (c-&gt;l == c-&gt;r) { c-&gt;m = std::sqrt(c-&gt;m); c-&gt;s = std::sqrt(c-&gt;s); return; } edit(c-&gt;ls), edit(c-&gt;rs); upd(c);}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, m; cin &gt;&gt; n; Node* rt = NULL; build(rt, 1, n); // cerr &lt;&lt; &quot;built&quot; &lt;&lt; endl; cin &gt;&gt; m; while (m--) { int x; cin &gt;&gt; x &gt;&gt; L &gt;&gt; R; if (L &gt; R) std::swap(L, R); if (x == 1) cout &lt;&lt; qs(rt) &lt;&lt; endl; else edit(rt); } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD"},{"title":"动态规划-矩阵加速","text":"¶ 矩阵乘法 {2x+y=33x+2y=9 \\left\\{ \\begin{aligned} 2x + y = 3 \\\\ 3x + 2y = 9 \\end{aligned} \\right. {2x+y=33x+2y=9​可表示成 [2132]×[xy]=[2x+y3x+2y] \\begin{bmatrix} 2 &amp; 1 \\\\ 3 &amp; 2 \\end{bmatrix} \\times \\begin{bmatrix} x \\\\ y \\end{bmatrix}= \\begin{bmatrix} 2x+y \\\\ 3x+2y \\end{bmatrix} [23​12​]×[xy​]=[2x+y3x+2y​]AAA 是 m×nm\\times nm×n 矩阵，BBB 是 n×pn\\times pn×p 矩阵。 A×B=CA\\times B = CA×B=C CCC 是 m×pm\\times pm×p 矩阵 C=(ci,j)ci,j=∑k=1nai,k×bk,j C = (c_{i,j})\\\\ c_{i,j} =\\sum_{k=1}^n a_{i,k}\\times b_{k,j} C=(ci,j​)ci,j​=k=1∑n​ai,k​×bk,j​¶ 形象理解 C=ci,j=AC =c_{i,j} = AC=ci,j​=A 的第 iii 行逐个乘 BBB 的第 jjj 列 非常形象的解释 ¶ 结合律证明 AAA 是 m×nm\\times nm×n 矩阵，BBB 是 n×pn\\times pn×p 矩阵，CCC 是 p×qp \\times qp×q 的矩阵。 A×B×C=A×(B×C)A×B=DD=(di,j)di,j=∑k=1nai,k⋅bk,jD×C=Eei,j=∑l=1p(di,l⋅cl,j)=∑l=1p((∑k=1nai,k⋅bk,l)×cl,j)=∑l=1p(∑k=1nai,k⋅bk,l⋅cl,j)B×C=Ffi,j=∑l=1pbi,l⋅cl,jA×F=Ggi,j=∑k=1n(ai,k⋅fk,j)=∑k=1n(ai,k×(∑l=1pbk,l⋅cl,j))=∑k=1n(∑l=1pai,k⋅bk,l⋅cl,j) A\\times B \\times C = A \\times (B \\times C)\\\\ A \\times B = D \\\\ D = (d_{i,j}) \\\\ d_{i,j} = \\sum_{k=1}^{n} a_{i,k}\\cdot b_{k,j} \\\\ D \\times C = E \\\\ \\begin{aligned} e_{i,j} &amp;= \\sum_{l=1}^p (d_{i,l}\\cdot c_{l,j}) \\\\ &amp;= \\sum_{l=1}^p ((\\sum_{k=1}^{n} a_{i,k}\\cdot b_{k,l}) \\times c_{l,j}) \\\\ &amp;= \\sum_{l=1}^p (\\sum_{k=1}^{n} a_{i,k}\\cdot b_{k,l}\\cdot c_{l,j}) \\\\ \\end{aligned} \\\\ B \\times C = F \\\\ f_{i,j} = \\sum_{l=1}^p b_{i,l}\\cdot c_{l,j} \\\\ A \\times F = G \\\\ \\begin{aligned} g_{i,j} &amp;= \\sum_{k=1}^n(a_{i,k}\\cdot f_{k,j}) \\\\ &amp;= \\sum_{k=1}^n(a_{i,k}\\times (\\sum_{l=1}^p b_{k,l}\\cdot c_{l,j})) \\\\ &amp;= \\sum_{k=1}^n(\\sum_{l=1}^p a_{i,k} \\cdot b_{k,l}\\cdot c_{l,j}) \\end{aligned} A×B×C=A×(B×C)A×B=DD=(di,j​)di,j​=k=1∑n​ai,k​⋅bk,j​D×C=Eei,j​​=l=1∑p​(di,l​⋅cl,j​)=l=1∑p​((k=1∑n​ai,k​⋅bk,l​)×cl,j​)=l=1∑p​(k=1∑n​ai,k​⋅bk,l​⋅cl,j​)​B×C=Ffi,j​=l=1∑p​bi,l​⋅cl,j​A×F=Ggi,j​​=k=1∑n​(ai,k​⋅fk,j​)=k=1∑n​(ai,k​×(l=1∑p​bk,l​⋅cl,j​))=k=1∑n​(l=1∑p​ai,k​⋅bk,l​⋅cl,j​)​显然 ∑l=1p(∑k=1nai,k⋅bk,l⋅cl,j)=∑k=1n(∑l=1pai,k⋅bk,l⋅cl,j)ei,j=gi,jE=GA×B×C=A×(B×C) \\sum_{l=1}^p (\\sum_{k=1}^{n} a_{i,k}\\cdot b_{k,l}\\cdot c_{l,j}) = \\sum_{k=1}^n(\\sum_{l=1}^p a_{i,k} \\cdot b_{k,l}\\cdot c_{l,j}) \\\\ e_{i,j} = g_{i,j} \\\\ E = G \\\\ A\\times B\\times C = A\\times(B\\times C) l=1∑p​(k=1∑n​ai,k​⋅bk,l​⋅cl,j​)=k=1∑n​(l=1∑p​ai,k​⋅bk,l​⋅cl,j​)ei,j​=gi,j​E=GA×B×C=A×(B×C)¶ 快速幂 若 2∣p2|p2∣p 则 ap=(a2)p/2a^p = (a^2)^{p/2}ap=(a2)p/2 若 2∣p+12|p+12∣p+1 则 ap=a⋅(a2)(p−1)/2a^p = a \\cdot (a^2)^{(p-1)/2}ap=a⋅(a2)(p−1)/2 将 O(n)O(n)O(n) 变成 O(log⁡2n)O(\\log_2n)O(log2​n) ¶ 例题 ¶ 洛谷 P1939 【模板】矩阵加速（数列） 没什么好说的 由于每项只和前 333 项有关，我们可以开一个 1×31\\times 31×3 的矩阵表示数列。 然后考虑一下转移。 [a1a2a3]→[a2a3a4]=[a2a3a1+a3] \\begin{bmatrix} a_1 &amp; a_2 &amp; a_3 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} a_2 &amp; a_3 &amp; a_4 \\\\ \\end{bmatrix}= \\begin{bmatrix} a_2 &amp; a_3 &amp; a_1+a_3 \\\\ \\end{bmatrix} [a1​​a2​​a3​​]→[a2​​a3​​a4​​]=[a2​​a3​​a1​+a3​​]用心感觉一下 转移矩阵就是（也可以解一个九元方程 [001100011] \\begin{bmatrix} 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\\\ \\end{bmatrix} ⎣⎢⎡​010​001​101​⎦⎥⎤​可以有 [a1a2a3]×[001100011]=[a2a3a1+a3]=[a2a3a4] \\begin{bmatrix} a_1 &amp; a_2 &amp; a_3 \\end{bmatrix} \\times \\begin{bmatrix} 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\\\ \\end{bmatrix}= \\begin{bmatrix} a_2 &amp; a_3 &amp; a_1+a_3 \\\\ \\end{bmatrix}= \\begin{bmatrix} a_2 &amp; a_3 &amp; a_4 \\\\ \\end{bmatrix} [a1​​a2​​a3​​]×⎣⎢⎡​010​001​101​⎦⎥⎤​=[a2​​a3​​a1​+a3​​]=[a2​​a3​​a4​​]踩了洛谷g++的一个坑，sync_with_stdio(false)必须加在所有输入输出之前。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstring&gt;typedef long long LL;using std::cin; using std::cout; using std::cerr; using std::endl; using std::min; using std::max;const int MOD = 1000000007;struct matrix{ long long a[5][5], m, n; void init(const int &amp;nM, const int &amp;nN){ std::memset(this-&gt;a, 0, sizeof(this-&gt;a)); this-&gt;m = nM; this-&gt;n = nN; } matrix operator=(const matrix &amp;s){ this-&gt;init(s.m, s.n); for (int i = 0; i &lt;= s.m; ++i) for (int j = 0; j &lt;= s.n; ++j) this-&gt;a[i][j] = s.a[i][j]; return *this; } matrix operator*(const matrix &amp;s){ // if (this-&gt;n != s.m) // cerr &lt;&lt; &quot;Matrixs Can't Time&quot;; matrix ans; ans.init(this-&gt;m, s.n); for (int i = 1; i &lt;= this-&gt;m; ++i){ for (int j = 1; j &lt;= s.n; ++j){ for (int k = 1; k &lt;= this-&gt;n; ++k){ ans.a[i][j] += this-&gt;a[i][k]*s.a[k][j]%MOD; } } } return ans; }}A, B, C;std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const matrix &amp;s){ for (int i = 1; i &lt;= s.m; ++i){ out &lt;&lt; '['; for (int j = 1; j &lt;= s.n-1; ++j){ out &lt;&lt; s.a[i][j] &lt;&lt; ' '; } out &lt;&lt; s.a[i][s.n]; out &lt;&lt; &quot;]\\n&quot;; } return out;}int main(){ int T, n; std::ios::sync_with_stdio(false); cin &gt;&gt; T; while (T--){ cin &gt;&gt; n; if (n &lt;= 3){ cout &lt;&lt; 1 &lt;&lt; endl; continue; } A.init(1,3); A.a[1][1] = A.a[1][2] = A.a[1][3] = 1; B.init(3,3); B.a[1][1] = B.a[1][2] = B.a[2][2] = B.a[2][3] = B.a[3][1] = 0; B.a[1][3] = B.a[2][1] = B.a[3][2] = B.a[3][3] = 1; n -= 4; C = B; while (n){ if (n&amp;1){ C = C * B; } B = B * B; n = n &gt;&gt; 1; } A = A * C; cout &lt;&lt; A.a[1][3]%MOD &lt;&lt; endl; } return 0;} ¶ 摆花 递归很好想 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;const int MOD = 1000000007;using std::cin; using std::cout; using std::cerr; using std::endl; using std::min; using std::max;int dp[2][101], a[101][101], n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; dp[1][0] = 1; // cin.get(); char c; for (register int i = 1; i &lt;= m; ++i){ dp[1][i] = 1; for (register int j = 1; j &lt;= m; ++j){ cin &gt;&gt; c; a[i][j] = c - '0'; } } int cur = 0, prev = 1; for (register int i = 2; i &lt;= n; ++i){ for (register int j = 0; j &lt;= m; ++j){ dp[cur][j] = 0; for (register int k = 0; k &lt;= m; ++k){ if (a[j][k]) continue; dp[cur][j] += dp[prev][k]; dp[cur][j] %= MOD; } } std::swap(cur, prev); } int ans = 0; for (int i = 0; i &lt;= m; ++i){ ans += dp[prev][i]; ans %= MOD; } cout &lt;&lt; ans; return 0;} 可以用矩阵加速转移。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstring&gt;typedef long long LL;const int MOD = 1000000007;using std::cin; using std::cout; using std::cerr; using std::endl; using std::min; using std::max;int n, m;struct matrix{ int a[110][110], m, n; void init(const int &amp;nM, const int &amp;nN){ std::memset(this-&gt;a, 0, sizeof(this-&gt;a)); this-&gt;m = nM; this-&gt;n = nN; } matrix operator=(const matrix &amp;s){ this-&gt;init(s.m, s.n); for (int i = 0; i &lt;= s.m; ++i) for (int j = 0; j &lt;= s.n; ++j) this-&gt;a[i][j] = s.a[i][j]; return *this; } matrix operator*(const matrix &amp;s){ matrix ans; ans.init(this-&gt;m, s.n); for (int i = 1; i &lt;= this-&gt;m; ++i){ for (int j = 1; j &lt;= s.n; ++j){ for (int k = 1; k &lt;= this-&gt;n; ++k){ ans.a[i][j] += (LL)this-&gt;a[i][k]%MOD*(LL)s.a[k][j]%MOD; ans.a[i][j] %= MOD; } } } return ans; }}A, B;std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const matrix &amp;s){ for (int i = 1; i &lt;= s.m; ++i){ out &lt;&lt; '['; for (int j = 1; j &lt;= s.n-1; ++j){ out &lt;&lt; s.a[i][j] &lt;&lt; ' '; } out &lt;&lt; s.a[i][s.n]; out &lt;&lt; &quot;]\\n&quot;; } return out;}int main(){ cin &gt;&gt; n &gt;&gt; m; char c; A.init(m+1,m+1); for (register int i = 1; i &lt;= m; ++i){ A.a[i][m+1] = 1; for (register int j = 1; j &lt;= m; ++j){ cin &gt;&gt; c; A.a[i][j] = c - '0'; A.a[i][j] ^= 1; } } for (register int i = 1; i &lt;= m+1; ++i){ A.a[m+1][i] = 1; } B.init(m+1,m+1); B = A; int p = n-2; while (p &gt; 0){ if (p%2!=0) B = B*A; A = A*A; p /= 2; } matrix ans; ans.init(1, m+1); for (int i = 1; i &lt;= ans.n; ++i) ans.a[1][i] = 1; ans = ans * B; int sum = 0; for (int i = 1; i &lt;= ans.n; ++i){ sum += ans.a[1][i]; sum %= MOD; } cout &lt;&lt; sum; return 0;}","link":"/archives/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F"},{"title":"求 LCA 的 Tarjan 算法","text":"这是一个复杂度为 O(n+q)O(n+q)O(n+q) 的离线求 LCA 算法 用 dfs 进行遍历并打 tag 假设遍历到 uuu，则已回溯的节点标为 222，遍历到但未回溯的节点（即 uuu 和 uuu 的祖先）标 111，其余为 000 现在假设 uuu 的子树处理完毕，考虑 uuu 的处理 询问节点为 (u,v)(u, v)(u,v) 此时，若 tagv=2\\mathrm{tag}_v = 2tagv​=2，则可以保证 vvv 向根走遇到的第一个 tag=1\\mathrm{tag} = 1tag=1 的节点即为 LCA(u,v)\\mathrm{LCA}(u,v)LCA(u,v)，可以用反证法证明 若向根走遇到的第一个 tag=1\\mathrm{tag} = 1tag=1 的节点，记为 www，w≠LCA(u,v)w \\not = \\mathrm{LCA}(u,v)w=LCA(u,v) 记 LCA(u,v)\\mathrm{LCA}(u,v)LCA(u,v) 为 ppp 显然 ppp 在 uuu 到根的路径上 若 ppp 在 www 下方，则 tagp≠1\\mathrm{tag}_p \\not= 1tagp​=1，但是 ppp 又为 uuu 的祖先，tag=1\\mathrm{tag}=1tag=1 矛盾 若 ppp 在 www 上方，根据算法可得 www 为 vvv 的 祖先，又 tagw=1\\mathrm{tag}_w = 1tagw​=1 得 www 为 uuu 的祖先，所以 www 必为 uuu 和 vvv 的公共祖先，但是 ppp 是 www 的祖先 矛盾 证毕 下面的程序复杂度应该没有问题，但是要卡一下常，吸一口氧才能过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 500010;std::vector&lt;int&gt; g[N * 2], query[N], query_id[N];int tag[N], ans[N], fa[N];int get(int x) { return (x == fa[x]) ? x : (fa[x] = get(fa[x])); }void tarjan(int u) { tag[u] = 1; for (auto v : g[u]) { if (tag[v] == 0) { tarjan(v); fa[v] = u; } } for (int i = 0; i &lt; query[u].size(); ++i) { int v = query[u][i]; if (tag[v] == 2) { ans[query_id[u][i]] = get(v); } } tag[u] = 2;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; fa[1] = 1; rep(i, 2, n) { fa[i] = i; int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } rep(i, 1, m) { int u, v; cin &gt;&gt; u &gt;&gt; v; query[u].push_back(v), query_id[u].push_back(i); query[v].push_back(u), query_id[v].push_back(i); } tarjan(s); rep(i, 1, m) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;}","link":"/archives/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/Tarjan-LCA"},{"title":"树上差分","text":"首先，树上差分是从子节点推到根节点，定义 ddd 差分数组 若修改 (x,y)(x,y)(x,y) 路径上的点权，则 dx,dy+=k,dlca,dfalca−=kd_x, d_y \\mathrel{+}= k, d_{\\mathrm{lca}}, d_{\\mathrm{fa}_{\\mathrm{lca}}} \\mathrel{-}= kdx​,dy​+=k,dlca​,dfalca​​−=k 123456void dfs(int u){ val[u] = d[u]; for (auto v : g[u]){ dfs(v), val[u] += val[v]; }} 若修改 (x,y)(x,y)(x,y) 路径上的边权，则 dx,dy+=k,dlca−=2kd_x, d_y \\mathrel{+}= k, d_{\\mathrm{lca}}\\mathrel{-}= 2kdx​,dy​+=k,dlca​−=2k 12345678int dfs(int u){ int ret = d[u]; for (auto i : g[u]){ i.w = dfs(i.v); ret += i.w; } return ret;} P3128 最大流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 50010;std::vector&lt;int&gt; g[N];int d[N], fa[20][N], dep[N], val[N];void dfs(int u) { for (auto v : g[u]) { if (v == fa[0][u]) continue; fa[0][v] = u; dep[v] = dep[u] + 1; dfs(v); }}int up(int u, int l) { for (int i = 19; i &gt;= 0; --i) { if (l &gt;= (1 &lt;&lt; i)) u = fa[i][u], l -= 1 &lt;&lt; i; } return u;}int q(int u, int v) { if (dep[u] &lt; dep[v]) std::swap(u, v); u = up(u, dep[u] - dep[v]); if (u == v) return u; for (int i = 19; i &gt;= 0; --i) if (fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v]; return fa[0][u];}void calc(int u) { val[u] = d[u]; for (auto v : g[u]) { if (v == fa[0][u]) continue; calc(v), val[u] += val[v]; }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, k, u, v; cin &gt;&gt; n &gt;&gt; k; rep(i, 2, n) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } dep[1] = 1, dfs(1); rep(k, 1, 19) rep(i, 1, n) fa[k][i] = fa[k - 1][fa[k - 1][i]]; rep(i, 1, k) { cin &gt;&gt; u &gt;&gt; v; int lca = q(u, v); d[u] += 1, d[v] += 1, d[lca] -= 1, d[fa[0][lca]] -= 1; } calc(1); int ans = 0; rep(i, 1, n) ans = std::max(ans, val[i]); cout &lt;&lt; ans; return 0;}","link":"/archives/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"},{"title":"虚树","text":"简介 对于这样一类题目：给定一棵 nnn 点树，有 qqq 个询问，每个询问关于树上 kik_iki​ 个点， n,q,∑k≤105n,q,\\sum k \\leq 10^5n,q,∑k≤105 朴素做法 O(qn)O(qn)O(qn) 由于一些题目的特殊，发现求解只需保留树的结构，故可以重构一棵虚树 虚树包含了所有的 kkk 个关键点和它们两两之间的 LCA，这样可以保证这虚树的节点个数 &lt;2k&lt; 2k&lt;2k，保证了复杂度 构造 先求出原树节点的 dfs 序，把关键点按 dfs 序排序 为了方便，原树直接按 dfs 序编号 假设保留根节点，正在处理 第 iii 个关键点 h[i]h[i]h[i]，l=lca(h[i−1],h[i])l=\\mathrm{lca}(h[i-1], h[i])l=lca(h[i−1],h[i]) 需要注意的是入栈点还没有连边，出栈才连 红色节点为关键点 紫色为入栈关键点 蓝色为入栈非关键点 灰色为出栈点 用栈来维护一条从根到 h[i−1]h[i-1]h[i−1] 的链，考虑如何加入 h[i]h[i]h[i] h[i−1]=lh[i-1] = lh[i−1]=l h[i−1]≠lh[i-1] \\neq lh[i−1]=l 对于第一种情况，直接加入栈即可 对于第二种情况，lll 肯定是在链上的点，但不一定在栈中存在 由于是按 dfs 序一个一个建构虚树，发现栈中 dep&lt;dep[l] 的节点都得出栈，连边 直到倒数第二个点 dep &gt; dep[l]，将栈顶出栈，加入 lll，在 lll 和它之间连边，然后再将 h[i]h[i]h[i] 入栈 这里有一种特殊情况 dep[栈顶] == dep[l]，此时直接加入 h[i]h[i]h[i] 即可 1234567891011121314151617181920std::sort(h + 1, h + 1 + m, cmp_dfn);if (h[1] != rt) stk[sz++] = h[1]; // 防止重复加rep(i, 2, m) { int lca = ::lca(h[i], stk[sz - 1]); if (lca == stk[sz - 1]) stk[sz++] = h[i]; else { while (sz - 2 &gt;= 0 &amp;&amp; dep[stk[sz - 2]] &gt;= dep[lca]) { // 注意取等 addedge(stk[sz - 2], stk[sz - 1]); sz--; } if (stk[sz - 1] != lca) { addedge(lca, stk[sz - 1]); stk[sz - 1] = lca; } stk[sz++] = h[i]; } }// 不要忘了最后加边rep(i, 0, sz - 2) addedge(stk[i], stk[i + 1]); 然后？ 倍增是必备的技巧，因为缩边的需要 「HNOI2014」世界树 「SDOI2011」消耗战","link":"/archives/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E8%99%9A%E6%A0%91"},{"title":"字符串 Hash","text":"¶ 概述 你有一个字符串 sss 你有一个神奇的函数 fff 可以使 f(s)∈Rf(s)\\in Rf(s)∈R s1≠s2s_1 \\neq s_2s1​=s2​ 时基本上不会出现 f(s1)=f(s2)f(s_1)=f(s_2)f(s1​)=f(s2​) 一种常见的 fff 构造方法是 f(s)=∑i=1nsi⋅ration−i f(s)=\\sum_{i=1}^n s_i\\cdot ratio^{n-i} f(s)=i=1∑n​si​⋅ration−i 12rep(i, 1, n) ret = ret * ratio + s[i]; 按这种方法构造 s1≠s2s_1\\neq s_2s1​=s2​ 时必有 f(s1)≠f(s2)f(s_1)\\neq f(s_2)f(s1​)=f(s2​) 但是并不能存一个很大很大的数 故需要对一个数取模 通常是质数 而且我们还可以对两个数取模 这样冲突的概率非常小 这种构造方法的好处显而易见 O(1)O(1)O(1) 取字串 数列骚操作 具体技巧在例题 ¶ 例题 ¶ 子串查找 LOJ #103. 子串查找 这是一道模板题。 给定一个字符串 AAA 和一个字符串 BBB ，求 BBB 在 AAA 中的出现次数。AAA 和 BBB 中的字符均为英语大写字母或小写字母。 AAA 中不同位置出现的 BBB 可重叠。 12rep(i, 1, n) (h[i] = h[i - 1] * ratio + s[i]) %= p; 那么取 sl+1⋯srs_{l+1}\\cdots s_rsl+1​⋯sr​ 的方法是 hr−hl⋅ratior−lh_r-h_l\\cdot ratio^{r-l}hr​−hl​⋅ratior−l ¶ 图书管理 LOJ #10034. 「一本通 2.1 例 2」图书管理 图书管理是一件十分繁杂的工作，在一个图书馆中每天都会有许多新书加入。为了更方便的管理图书（以便于帮助想要借书的客人快速查找他们是否有他们所需要的书），我们需要设计一个图书查找系统。 该系统需要支持 2 种操作： add(s) 表示新加入一本书名为 s 的图书。 find(s) 表示查询是否存在一本书名为 s 的图书。 算出 f(s)f(s)f(s) 丢到 map 里去 ¶ Power Strings LOJ #10035. 「一本通 2.1 练习 1」Power Strings 给定若干个长度 ≤106\\le 10^6≤106 的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 个 ab 连接而成。 这是一个等比数列求和的问题 ¶ Seek the Name, Seek the Fame LOJ #10036. 「一本通 2.1 练习 2」Seek the Name, Seek the Fame 给定若干字符串（这些字符串总长 ≤4×105\\le 4\\times10^5≤4×105），在每个字符串中求出所有既是前缀又是后缀的子串长度。 例如：ababcababababcabab，既是前缀又是后缀的：ab，abab，ababcabab，ababcababababcabab。 从两边分别算 Hash 就可以了","link":"/archives/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/hash"},{"title":"Edmonds-Karp 算法","text":"Edmonds-Karp 算法是用来解决最大流和最小费用最大流的常用算法。 ¶ 原理 对于一个图（流量/容量） 显然最大流为 222 我们考虑贪心，每次找出一条增广路 并没有得到最优解 是不是忘了什么？ fff 有反对称性 我们发现还有一条增广 于是得到了正解 如果我们以 cfc_fcf​ 绘图，可能更简洁一些 在我的理解中，反向边就是给了一个反悔的机会 ¶ 最大流 ¶ 实现 我们可以对一个边存 f,cf, cf,c，或者可以只存 cfc_fcf​，因为保证 cf&gt;0c_f&gt;0cf​&gt;0 就可以满足 f≤cf\\le cf≤c 的条件 如何寻找增广路呢？ 可以发现 dfs 是不行的，因为可能有环存在。 于是可以用 bfs 代码中采用记录 cfc_fcf​ 对于反向边的记录，我们可以直接在 struct edge 中开指针指向反向边 或者用 xor 成对储存的技巧： 12340 xor 1 = 11 xor 1 = 02 xor 1 = 33 xor 1 = 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;cstring&gt;#define rep(i, l, r) for (int i = (l); i &lt; (r); ++i)using std::cin; using std::cout; using std::cerr; using std::endl;const int N = 10000, M = 100000, INF = 1e8;#define travese(i, u) for(edge* i = p[u]; i; i = i-&gt;nxt)int n, m, s, t;struct edge;edge* begin;struct edge{ edge* nxt; int v, cap; edge* rev(){ // 求反向边 return begin + ((this-begin)^1); }}e[M*2+100];edge* p[N+100];int cnt = 0;inline void addedge(int u, int v, int cap){ e[cnt].v = v, e[cnt].cap = cap, e[cnt].nxt = p[u], p[u] = &amp;e[cnt++];}struct que{ int a[N+100], l = 0, r = 0; int front() {return a[l];} void pop() { ++l;} bool empty() {return l &gt;= r; } void push(int x){ a[r++] = x; } void clear(){ l = 0, r = 0; }} q;struct node{ edge* e; int v;} pre[N+100];bool flag[N+100];bool bfs(){ // 求增广路 std::memset(flag, 0, sizeof(flag)); // vis 标记 flag[s] = 1; q.clear(); q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); travese(i, u){ if (i-&gt;v == t &amp;&amp; i-&gt;cap &gt; 0){ pre[i-&gt;v].v = u; pre[i-&gt;v].e = i; return 1; } if (flag[i-&gt;v]) continue; if (i-&gt;cap &gt; 0){ pre[i-&gt;v].v = u; pre[i-&gt;v].e = i; q.push(i-&gt;v); flag[i-&gt;v] = 1; } } } return 0;}int main(){ std::ios::sync_with_stdio(false); cout.tie(0); begin = e; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; rep(i, 0, m){ int u, v, cap; cin &gt;&gt; u &gt;&gt; v &gt;&gt; cap; addedge(u, v, cap); addedge(v, u, 0); } int maxflow = 0; while(bfs()){ int delta = INF; for(int i = t; i != s; i = pre[i].v){ delta = std::min(delta, pre[i].e-&gt;cap); } for(int i = t; i != s; i = pre[i].v){ pre[i].e-&gt;cap -= delta; pre[i].e-&gt;rev()-&gt;cap += delta; } maxflow += delta; } cout &lt;&lt; maxflow; return 0;} ¶ 复杂度 https://brilliant.org/wiki/edmonds-karp-algorithm/","link":"/archives/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/Edmonds-Karp"},{"title":"网络流基础","text":"¶ 定义 ¶ 网络 有向图 G=(V,E)G=(V,E)G=(V,E) 满足 有且仅有一个源点 s∈Vs \\in Vs∈V，有且仅有一个汇点 t∈Vt \\in Vt∈V，且 s≠ts\\not = ts=t 有一个函数 c:V×V→R+c: V \\times V \\to R^+c:V×V→R+ 每一条边对应容量 c(u,v)c(u,v)c(u,v) 如果 (u,v)∈E(u,v) \\in E(u,v)∈E 且 (v,u)∉E(v,u)\\not\\in E(v,u)∈E 则 c(v,u)=0c(v,u) = 0c(v,u)=0 (u,v)(u,v)(u,v) 可称为弧 c(u,v)c(u,v)c(u,v) 为弧的容量 可以类比水流，有很多只能单向流水的水管组成网络，水管有粗细 ccc 有一个有无限水流进入的源点 sss，和无限水流出的汇点 ttt ¶ 网络流 定义函数 f:V×V→Rf: V \\times V \\to Rf:V×V→R，满足 容量限制 f(u,v)≤c(u,v)f(u,v)\\le c(u,v)f(u,v)≤c(u,v) 反对称性 f(u,v)=−f(v,u)f(u,v) = -f(v,u)f(u,v)=−f(v,u) 流守恒 基尔霍夫电流定律 ∑v∈Vf(u,v)=0\\sum_{v\\in V} f(u,v) = 0∑v∈V​f(u,v)=0 就是一种方案 你可以规定水管 (u,v)(u,v)(u,v) 流 f(u,v)f(u,v)f(u,v) 水 不能有没有规定过流量的水管 ¶ 残量网络 边的剩余容量简称为残量，cf(u,v)=c(u,v)−f(u,v)c_f(u,v) = c(u,v) - f(u,v)cf​(u,v)=c(u,v)−f(u,v) 通过残量我们可以构成残量网络 Gf(V,Ef)G_f(V, E_f)Gf​(V,Ef​) 我们有这样一个显然的结论，对于一个网络 GGG，有一个流 fff，记此图的残量网络为 GfG_fGf​，剩余容量为 cfc_fcf​ 残量网络上有一个流 f′f'f′ 定义 f↑f′(u,v)=f(u,v)+f′(u,v)f\\uparrow f'(u,v)=f(u,v)+f'(u,v)f↑f′(u,v)=f(u,v)+f′(u,v) 有 f↑f′f\\uparrow f'f↑f′ 是原网络 GGG 上的一个合法流 ¶ 证明 十分简单，可略过 f(u,v)≤c(u,v)f′(u,v)≤cf(u,v)=c(u,v)−f(u,v)f↑f′(u,v)=f(u,v)+f′(u,v)f↑f′(u,v)≤f(u,v)+c(u,v)−f(u,v)=c(u,v) f(u,v)\\le c(u,v)\\\\ f'(u,v)\\le c_f(u,v)=c(u,v)-f(u,v)\\\\ f\\uparrow f'(u,v)=f(u,v)+f'(u,v)\\\\ f\\uparrow f'(u,v)\\le f(u,v)+c(u,v)-f(u,v) = c(u,v) f(u,v)≤c(u,v)f′(u,v)≤cf​(u,v)=c(u,v)−f(u,v)f↑f′(u,v)=f(u,v)+f′(u,v)f↑f′(u,v)≤f(u,v)+c(u,v)−f(u,v)=c(u,v)证毕（其实只证了容量限制 就是一个网络各个弧的容量减去以用流量 算法中通常只存残量网络，每次直接在残量网络上修改 ¶ 增广路 在残量网络上的一条路径 (u1,⋯ ,uk)(u_1, \\cdots, u_k)(u1​,⋯,uk​)，满足 u1=s,uk=tu_1 = s, u_k = tu1​=s,uk​=t cf(ui,ui+1)&gt;0c_f(u_i, u_{i+1}) &gt; 0cf​(ui​,ui+1​)&gt;0 显然，当残量网络无增广路时达到最大流 min⁡{cf(ui,ui+1)}\\min\\{c_f(u_i,u_{i+1})\\}min{cf​(ui​,ui+1​)} 称为增广流量 ¶ 问题 ¶ 最大流 定义 ∣f∣=∑v∈Vf(s,v)=∑v∈Vf(v,t)\\left | f \\right | = \\sum_{v\\in V} f(s,v) = \\sum_{v\\in V} f(v, t)∣f∣=∑v∈V​f(s,v)=∑v∈V​f(v,t) 最大流就是求出最大的 ∣f∣\\left | f \\right |∣f∣，有时候还求方案 水管网络最大的流速","link":"/archives/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%9F%BA%E7%A1%80"},{"title":"粒子群算法","text":"¶ 概述 这是一种随机算法 模仿鸟类捕食 在定义域中随机撒 nnn 个点，需要维护（以二维定义域为例） 坐标 p(x,y)p(x,y)p(x,y) 速度 vvv ，一个二维向量 历史最优值 pbpbpb 和其坐标 同时还要维护全局最优解及其坐标 定义三个常数 ω,c1,c2\\omega,c_1,c_2ω,c1​,c2​ 每次更新点的速度 v=ωv+c1(pb−p)+c2(gb−p) v=\\omega v+c_1(pb-p)+c_2(gb-p) v=ωv+c1​(pb−p)+c2​(gb−p)更新坐标 p=p+v p=p+v p=p+v最后更新 pb,gbpb,gbpb,gb ¶ 传送带 题目概述 LOJ #10017. 「一本通 1.2 练习 4」传送带 原题来自：SCOI 2010 在一个 222 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 AB\\text{AB}AB 和线段 CD\\text{CD}CD。lxhgww 在 AB\\text{AB}AB 上的移动速度为 PPP ，在 CD\\text{CD}CD 上的移动速度为 QQQ ，在平面上的移动速度 RRR。 现在 lxhgww 想从 AAA 点走到 DDD 点，他想知道最少需要走多长时间。 三分的做法显然 假设在 AB\\text{AB}AB 上走 xxx 秒，假设在 CD\\text{CD}CD 上走 yyy 秒，总时间为 f(x,y)f(x,y)f(x,y)，然后注意边界直接跑就行 随机 1000 组数据有 97% 的正确率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define Rn(n) for (int i = 0; i &lt; (n); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int cnt = 1000, inf = 0x3f3f3f3f;inline double dis(double a, double b) { return std::sqrt(a * a + b * b); }struct Vector { double x, y, len; Vector() { x = 0, y = 0, len = 0; } Vector(double _x, double _y) { x = _x, y = _y, calc(); } void calc() { len = dis(x, y); } Vector&amp; operator+=(const Vector&amp; b) { x += b.x; y += b.y; calc(); return *this; } Vector operator+(const Vector&amp; b) const { Vector n(x + b.x, y + b.y); return n; } Vector operator-(const Vector&amp; b) const { Vector n(x - b.x, y - b.y); return n; } Vector operator*(double k) const { Vector n(x * k, y * k); return n; }} gb, a, b, c, d, uab, udc;double gb_a, p, q, r, mx, my;inline double dis(Vector a, Vector b) { return dis(a.x - b.x, a.y - b.y); }double omega = 0.4, c1 = 2, c2 = 2;std::random_device rd;std::mt19937 gen(rd());std::uniform_real_distribution&lt;&gt; qwq(0, 1);double rr() { return qwq(gen); } // 返回 [0,1) 实数struct Unit { Vector p, v, pb; double pb_a; double ans() { return p.x + p.y + dis(a + uab * p.x, d + udc * p.y) / r; } void upd_v() { v = v * omega + (pb - v) * c1 * rr() + (gb - v) * c2 * rr(); } void upd() { upd_v(); p += v; if (p.x &lt; 0) p.x = 0; if (p.y &lt; 0) p.y = 0; if (p.x &gt; mx) p.x = mx; if (p.y &gt; my) p.y = my; double c = ans(); if (c &lt;= pb_a) { pb = p, pb_a = c; if (c &lt;= gb_a) gb = p, gb_a = c; } }} u[cnt];int main() { std::ios::sync_with_stdio(false); cout.tie(0); int t1, t2; cin &gt;&gt; t1 &gt;&gt; t2; a = Vector(t1, t2); cin &gt;&gt; t1 &gt;&gt; t2; b = Vector(t1, t2); cin &gt;&gt; t1 &gt;&gt; t2; c = Vector(t1, t2); cin &gt;&gt; t1 &gt;&gt; t2; d = Vector(t1, t2); uab = b - a; udc = c - d; cin &gt;&gt; p &gt;&gt; q &gt;&gt; r; mx = uab.len / p; my = udc.len / q; uab = (uab.len == 0 ? Vector(0, 0) : uab * (p / uab.len)); udc = (udc.len == 0 ? Vector(0, 0) : udc * (q / udc.len)); gb_a = inf; Rn(cnt) { u[i].p = u[i].pb = Vector(mx * rr(), my * rr()); u[i].pb_a = u[i].ans(); if (u[i].pb_a &lt; gb_a) gb_a = u[i].pb_a, gb = u[i].p; } rep(ewq, 1, 500) { Rn(cnt) { u[i].upd(); } } cout.setf(std::ios::fixed); cout &lt;&lt; std::setprecision(2) &lt;&lt; gb_a &lt;&lt; endl; return 0;}","link":"/archives/%E7%AE%97%E6%B3%95/%E9%9A%8F%E6%9C%BA/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95"},{"title":"「APIO 2010」巡逻","text":"容易发现，若不加新边，则总距离为 2(n−1)2(n-1)2(n−1) 发现 k=1k=1k=1 时，连一条边等于环上的边只需走一次，显然最优连直径 发现 k=2k=2k=2 时，再连一条边，若构成的环和第一次的环不相交，则可以直接减 若相交，则需要经过重叠部分两次，可以通过把边权改成 −1-1−1 实现 对于新边能走一次，可以用，不实际在图上加边，来控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::max;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 100010;struct Edge { Edge* nxt; int v, w;} e[N * 2];Edge* p[N];int cnt = 0;void addedge(int u, int v, int w) { e[cnt].v = v, e[cnt].w = w, e[cnt].nxt = p[u], p[u] = &amp;e[cnt++];}int dis[N], from[N];void dfs(int u, int fa, int&amp; far) { if (dis[far] &lt; dis[u]) far = u; for (auto i = p[u]; i; i = i-&gt;nxt) { if (i-&gt;v == fa) continue; dis[i-&gt;v] = dis[u] + i-&gt;w; from[i-&gt;v] = (i - e) ^ 1; dfs(i-&gt;v, u, far); }}int tot, dp[N];void calc(int u, int fa) { for (auto i = p[u]; i; i = i-&gt;nxt) { if (i-&gt;v == fa) continue; calc(i-&gt;v, u); tot = max(tot, i-&gt;w + dp[u] + dp[i-&gt;v]); // 精妙 dp[u] = max(dp[u], dp[i-&gt;v] + i-&gt;w); // 精妙 }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 2, n) { int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v, 1); addedge(v, u, 1); } int s, t; dfs(1, 0, s); dis[s] = 0, t = s; dfs(s, 0, t); int ans = (n - 1) * 2 - dis[t] + 1; cerr &lt;&lt; ans &lt;&lt; endl; while (t != s) { e[from[t]].w = e[from[t] ^ 1].w = -1; t = e[from[t]].v; } if (k == 2) { std::memset(dis, 0, sizeof(dis)); calc(s, 0); ans = ans - tot + 1; } cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/APIO/%E5%B7%A1%E9%80%BB"},{"title":"「Codeforces 1111B」Average Superhero Gang Power","text":"题目链接 首先观察求平均数的公式 avg=sumn avg=\\frac{sum}{n} avg=nsum​所以我们要么改变 sumsumsum 要么改变 nnn 如果忽略 kkk 这个条件，我们有以下解法 我们先删数，数量记为为 qqq ，剩余数的和记为 s′s's′ avg=s′+m−qn−q avg = \\frac{s'+m-q}{n-q} avg=n−qs′+m−q​对于一个数，我们要么舍弃，要么保留，显然的我们需要先删小的数（可以用 Exchange Argument 证明 12345678std::sort(a + 1, a + 1 + n, std::greater&lt;int&gt;());double sum = 0, ans = 0;rep(i, 1, n) { sum += a[i]; int q = n - i; if (m &gt;= q) ans = std::max(ans, (sum + m - q) / i)} 现在我们加上 kkk 这个条件，我们只需改动一行代码（因为 kkk 的约束导致加上 m−qm-qm−q 的目标不一定可以实现 1ans = std::max(ans, (sum + std::min((m - q), i * k)) / i); 复杂度 O(n)O(n)O(n) 我也不知道我比赛时怎么想出 O(nlog⁡n)O(n\\log n)O(nlogn) 的错误算法（划掉 此题需要注意溢出 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;ll a[100100];int main() { std::ios::sync_with_stdio(false); cout.tie(0); ll n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; double l, r; rep(i, 1, n) cin &gt;&gt; a[i]; std::sort(a + 1, a + 1 + n, std::greater&lt;int&gt;()); double sum = 0, ans = 0; rep(i, 1, n) { sum += a[i]; if (m &gt;= (n - i)) ans = std::max(ans, (sum + std::min((m - (n - i)), i * k)) / i); } cout.setf(std::ios::fixed); cout &lt;&lt; std::setprecision(14) &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF1111B"},{"title":"「Codeforces 1111C」Creative Snap","text":"题目链接 题目非常简单，只要实现不带修改的区间个数查询就可以了（还有适当剪枝 ¶ 解法一 123456for (int i = 0; i &lt; k; ++i) cin &gt;&gt; a[i];std::sort(a, a + k);int query(ll l, ll r) { return std::upper_bound(a, a + k, r) - std::lower_bound(a, a + k, l);} 12345678910ll solve(ll l, ll r) { if (query(l, r) == 0) return A; // 适当剪枝 有益身心 if (l == r) { return B * query(l, r); } else { ll sol1 = solve(l, l + (r - l + 1) / 2 - 1) + solve(l + (r - l + 1) / 2, r); ll sol2 = B * (r - l + 1) * query(l, r); return std::min(sol1, sol2); }} ¶ 解法二 发现递归结构和二叉的线段树是一样的 实现了一个 new 12345node* nn() { return &amp;t[cnt++]; }node* nn(ui _l, ui _r) { t[cnt].l = _l, t[cnt].r = _r; return &amp;t[cnt++];} 12345678910111213141516171819202122232425262728int cnt = 0;struct node { ui l, r, cnt = 0; node *ls, *rs; void pushup() { cnt = (ls == nullptr ? 0 : ls-&gt;cnt) + (rs == nullptr ? 0 : rs-&gt;cnt); } void insert(int x) { if (l == r) { cnt++; return; } ui mid = (l + r) / 2; if (x &lt;= mid) { if (ls == nullptr) ls = nn(l, mid); ls-&gt;insert(x); } if (x &gt; mid) { if (rs == nullptr) rs = nn(mid + 1, r); rs-&gt;insert(x); } pushup(); } ll solve(int dep) { ll sol = (ll)B * cnt * (1 &lt;&lt; dep); if (dep) sol = std::min(sol, ((ls == nullptr) ? A : ls-&gt;solve(dep - 1)) + ((rs == nullptr) ? A : rs-&gt;solve(dep - 1))); return sol; }} t[10000010], *rt; 1234567891011121314int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B; rt = nn(1, 1 &lt;&lt; n); rep(i, 1, k) { int x; cin &gt;&gt; x; rt-&gt;insert(x); } cout &lt;&lt; rt-&gt;solve(n); return 0;} 两份代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 100100;ll a[N];ll k, A, B;ll query(ll l, ll r) { return std::upper_bound(a, a + k, r) - std::lower_bound(a, a + k, l); }ll solve(ll l, ll r) { if (query(l, r) == 0) return A; if (l == r) { return B * query(l, r); } else { ll sol1 = solve(l, l + (r - l + 1) / 2 - 1) + solve(l + (r - l + 1) / 2, r); ll sol2 = B * (r - l + 1) * query(l, r); return std::min(sol1, sol2); }}int main() { std::ios::sync_with_stdio(false); cout.tie(0); ll n; cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B; // rep(i, 0, k - 1) cin &gt;&gt; a[i]; for (int i = 0; i &lt; k; ++i) cin &gt;&gt; a[i]; std::sort(a, a + k); // int l, r; // while (cin &gt;&gt; l &gt;&gt; r) cout &lt;&lt; query(l, r) &lt;&lt; endl; cout &lt;&lt; solve(1, 1 &lt;&lt; n); return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;int cnt = 0;struct node;node* nn();node* nn(ui _l, ui _r);int L, R;ll A, B;struct node { ui l, r, cnt = 0; node *ls, *rs; void pushup() { cnt = (ls == nullptr ? 0 : ls-&gt;cnt) + (rs == nullptr ? 0 : rs-&gt;cnt); } void insert(int x) { if (l == r) { cnt++; return; } ui mid = (l + r) / 2; if (x &lt;= mid) { if (ls == nullptr) ls = nn(l, mid); ls-&gt;insert(x); } if (x &gt; mid) { if (rs == nullptr) rs = nn(mid + 1, r); rs-&gt;insert(x); } pushup(); } ll solve(int dep) { ll sol = (ll)B * cnt * (1 &lt;&lt; dep); if (dep) sol = std::min(sol, ((ls == nullptr) ? A : ls-&gt;solve(dep - 1)) + ((rs == nullptr) ? A : rs-&gt;solve(dep - 1))); return sol; }} t[10000010];node* nn() { return &amp;t[cnt++]; }node* nn(ui _l, ui _r) { t[cnt].l = _l, t[cnt].r = _r; return &amp;t[cnt++];}node* rt;int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B; rt = nn(1, 1 &lt;&lt; n); rep(i, 1, k) { int x; cin &gt;&gt; x; rt-&gt;insert(x); } cout &lt;&lt; rt-&gt;solve(n); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF1111C"},{"title":"「Codeforces 1140E」Palindrome-less Arrays","text":"题意 当一个数组 bbb 至少有一个长度为奇数的连续回文子串时，称 bbb 是坏的，否则称 bbb 是好的。 给你长度为 nnn 的数组 aaa，其中 −1−1−1 可替换为任意从 111 到 kkk 的整数。 求好数组的个数，对 998244353 取模。 题解 发现 bbb 为坏的条件完全等价于 不存在长度为三的回文串，即 ai≠ai+2a_i \\neq a_{i+2}ai​=ai+2​，故考虑分奇偶处理，最后乘起来。 问题转换成 长度为 nnn 的串，相邻数不能相等，方案有多少？ 考虑分治 a≠ba\\neq ba=b，fi,0/1f_{i,0/1}fi,0/1​ 表示中间 −1-1−1 个数为 iii，1/01/01/0 表示两端数是否相等 a,−1,…,−1,ba, -1, \\dots, -1, ba,−1,…,−1,b 有 fi,0=(k−2)fi−1,0+fi−1,1f_{i,0} = (k-2)f_{i-1,0}+f_{i-1,1}fi,0​=(k−2)fi−1,0​+fi−1,1​ a,−1,…,−1,aa, -1, \\dots, -1, aa,−1,…,−1,a 有 fi,1=(k−1)fi−1,0f_{i,1} = (k-1)f_{i-1,0}fi,1​=(k−1)fi−1,0​ 特殊的 f0,0=1,f0,1=0f_{0,0} = 1, f_{0,1}=0f0,0​=1,f0,1​=0 最后还要考虑一些特殊情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int p = 998244353;const int N = 201000;#define mod(x) (x) %= 998244353inline int mul(int x, int y) { return ((ll)x * y) % p; }inline int add(int x, int y) { return ((ll)x + y) % p; }int a[N], b[N], cnta, cntb;int k, f[N][2];int ksm(int a, int n) { int ret = 1; while (n) { if (n &amp; 1) ret = mul(ret, a); a = mul(a, a); n &gt;&gt;= 1; } return ret;}int solve(int a[], int n) { if (n == 0) return 1; int l = 0, r = n - 1; int ret; for (; a[l] == -1 &amp;&amp; l &lt; n; l++) ; if (l == n) return mul(k, ksm(k - 1, n - 1)); for (; a[r] == -1; --r) ; ret = mul(ksm(k - 1, l), ksm(k - 1, n - r - 1)); int lst = l; for (l = lst + 1; l &lt;= r; ++l) { if (a[l] == -1) continue; ret = mul(ret, f[l - lst - 1][a[lst] == a[l]]); lst = l; } return ret;}int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n; cin &gt;&gt; n &gt;&gt; k; f[0][0] = 1, f[0][1] = 0; rep(i, 1, n) { f[i][1] = mul(f[i - 1][0], k - 1); f[i][0] = add(mul(k - 2, f[i - 1][0]), f[i - 1][1]); } rep(i, 1, n) { if (i &amp; 1) cin &gt;&gt; a[cnta++]; else cin &gt;&gt; b[cntb++]; } cout &lt;&lt; mul(solve(a, cnta), solve(b, cntb)); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF1140E"},{"title":"Codeforces Round #599 (Div. 1)","text":"sto God Song orz Being teached again ¶ A - Tile Painting 打表找规律 123456789101112131415161718192021222324252627282930int clr[1000000], _n;void dfs(int x){ int n = _n; for(int i = 2; i &lt;= n; ++i){ if (n%i == 0){ if (x-i &gt;= 1 &amp;&amp; !clr[x-i]){ clr[x-i] = clr[x]; dfs(x-i); } if (x+i &lt;= n &amp;&amp; !clr[x+i]){ clr[x+i] = clr[x]; dfs(x+i); } } }}int solve(int n){ std::memset(clr, 0, sizeof(clr)); _n = n; int ret=0; for(int i = 1; i &lt;= n; ++i){ if (!clr[i]){ clr[i] = ++ret; dfs(i); } } // rep(i,1,n) cerr &lt;&lt; clr[i] &lt;&lt; ' '; cerr &lt;&lt;endl; return ret;} n=pk,k∈N∗n=p^k, k\\in\\N^*n=pk,k∈N∗ ，ppp 为素数， ans=pans=pans=p ans=1ans=1ans=1 ¶ B - 0-1 MST pre[x] 是代表 pre[x]...x 的全被遍历到，并且 pre[x] 尽量小 然后 random_shuffle 就过了 我也不知道为什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; const int N = 1e5+10; int clr[N], pre[N];std::vector&lt;int&gt; g[N]; void dfs(int u){ // cerr &lt;&lt; &quot;node &quot; &lt;&lt; u &lt;&lt; endl; std::vector&lt;int&gt; q; for(int i = 1; i &lt; g[u].size(); ++i){ int st = g[u][i-1] + 1, ed = g[u][i]-1; if(pre[ed] &lt; st) continue; else if (pre[ed] == st) ed = st; rep(v, st, ed) pre[v] = pre[st]; rep(v, st, ed) if (!clr[v]){ clr[v] = 1; q.push_back(v); } } std::random_shuffle(q.begin(), q.end()); for(auto x : q) dfs(x);} int main() {// #ifdef LOCAL // freopen(&quot;in3.txt&quot;, &quot;r&quot;, stdin);// #endif std::ios::sync_with_stdio(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; rep(i, 0, n+1) pre[i] = i; rep(i, 1, m){ int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } rep(i, 1, n){ g[i].push_back(0), g[i].push_back(n+1); std::sort(g[i].begin(), g[i].end()); } int ret = 0; rep(i, 1, n){ if (!clr[i]){ // cerr &lt;&lt; &quot;++ &quot; &lt;&lt; i &lt;&lt; endl; clr[i] = 1; ++ret; dfs(i); } } cout &lt;&lt; ret-1; return 0;} ¶ C - Sum Balance kkk 这么小肯定是指数算法 然后 n 太大不会做 考虑一个数被拿出来一定会有另一个数被替换，而另一个数是确定的 把数看成节点，每个节点有一条或没有出边 于是就转换成了一个图论问题 当图上有环的时候，并且这些数属于不同的盒子时，这几个盒子就能一起选上 于是变成了一个内向基环树找环的问题，加上一个人人都会的状压 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define R(i, r) for (int i = 0; i &lt; (r); ++i)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; const int K = 15, N = 5010; int n[K]; ll a[K][N], sig[K];std::map&lt;ll, pii&gt; s;pii g[K][N]; int clr[K][N];int f[1&lt;&lt;K], from[1&lt;&lt;K];pii plan[1&lt;&lt;K]; int origin[1&lt;&lt;K]; pii out[K]; void dfs(int state){ if (origin[state]){ int x = plan[state].first, y = plan[state].second; pii n; do { n = g[x][y]; out[n.first] = {a[n.first][n.second], x}; x = n.first, y = n.second; } while(x != plan[state].first); } else { dfs(from[state]); dfs(state^from[state]); }} int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int k; cin &gt;&gt; k; ll avg = 0; R(i, k){ cin &gt;&gt; n[i]; R(j, n[i]){ cin &gt;&gt; a[i][j]; sig[i] += a[i][j]; s[a[i][j]] = {i,j}; } avg += sig[i]; } if (avg % k != 0){ cout &lt;&lt; &quot;No&quot;; return 0; } avg /= k; R(i, k) R(j, n[i]){ ll x = avg - sig[i] + a[i][j]; if (s.count(x)) g[i][j] = s[x]; else g[i][j].first = -1; } int x, y, state, flag; pii np; int cnt = 0; R(i, k) R(j, n[i]){ if (clr[i][j]) continue; x = i, y = j; clr[x][y] = ++cnt; while(g[x][y].first != -1){ np = g[x][y]; x = np.first, y = np.second; if (clr[x][y] == cnt){ state = 0, flag = 1; int ox = x, oy = y; do { if (state&amp;(1&lt;&lt;x)) { flag = 0; break; } state |= (1&lt;&lt;x); np = g[x][y]; x = np.first, y = np.second; } while(x != ox || y != oy); if (flag) f[state] = origin[state] = 1, plan[state] = {x, y}; break; } else if (clr[x][y] != 0) break; clr[x][y] = cnt; } } f[0] = 1; for(int i = 1; i &lt; (1&lt;&lt;k); ++i){ for(int j = i; j &amp;&amp; !f[i]; j = ((j-1)&amp;i)){ if (f[j] &amp;&amp; f[i^j]){ f[i] = 1; from[i] = j; } } } if(!f[(1&lt;&lt;k)-1]){ cout &lt;&lt; &quot;No&quot;; return 0; } cout &lt;&lt; &quot;Yes\\n&quot;; dfs((1&lt;&lt;k)-1); R(i, k){ cout &lt;&lt; out[i].first &lt;&lt; ' ' &lt;&lt; out[i].second+1 &lt;&lt; endl; } return 0;} 剩下的不会了 QAQ","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF1242"},{"title":"Educational Codeforces Round 75","text":"又被 God Song 教育了 ¶ C 比赛时写了一个假的算法，赛后被教育说直接归并就可以了 1234567891011char s1[300010], s2[300010], s[300010];void solve(){ int pt1 = 0, pt2 = 0; cin &gt;&gt; s; int n = strlen(s); for(int i = 0; i &lt; n; ++i) if ((s[i]-'0')&amp;1) s2[pt2++] = s[i]; else s1[pt1++] = s[i]; std::merge(s1, s1+pt1, s2, s2+pt2, s); cout &lt;&lt; s &lt;&lt; endl;} ¶ D 我以为能直接做 结果是个答案二分 没开 ll 全靠 Codeforces 帮我调试 123456789101112131415161718192021222324252627282930313233typedef pair&lt;ll, ll&gt; pll;const int N = 200010;pll a[N]; int n; ll s;bool ok(ll mid){ int cnt1 = 0, cnt2 = 0, cnt3 = 0; ll ans = 0; std::vector&lt;ll&gt; v; rep(i, 1, n){ if (a[i].second &lt; mid) ++cnt1, ans += a[i].first; else if (a[i].first &gt; mid) ++cnt3, ans += a[i].first; else v.push_back(a[i].first); } if (cnt1 &gt; n/2) return 0; int need = std::max(0, n/2+1-cnt3); ans += need*mid; for(int i = 0; i &lt; v.size() - need; ++i) ans += v[i]; return ans &lt;= s;}void solve(){ cin &gt;&gt; n &gt;&gt; s; ll l = 0, r = s; rep(i, 1, n) cin &gt;&gt; a[i].first &gt;&gt; a[i].second; std::sort(a+1, a+1+n); while(l &lt; r){ ll mid = (l+r+1)/2; if(ok(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl;} ¶ E1 好神的 DP 按 mmm 升序排序 fi,jf_{i, j}fi,j​ 为 1∼i1\\sim i1∼i 个人投，并且 i+1∼ni+1\\sim ni+1∼n 中有 jjj 个人在前 iii 个人之前投 fi,j=min⁡{fi−1,j+1+pifi−1,j if i−1+j≥mi f_{i,j}=\\min\\left\\{ \\begin{aligned} &amp;f_{i-1,j+1} +p_i \\\\ &amp;f_{i-1,j}~~~~\\textbf{if}~~i-1+j\\ge m_i \\end{aligned} \\right. fi,j​=min{​fi−1,j+1​+pi​fi−1,j​ if i−1+j≥mi​​12345678910111213void solve(){ int n; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i].m &gt;&gt; a[i].p; std::sort(a+1, a+1+n, cmp); rep(i, 1, n){ rep(j, 0, n){ f[i][j] = f[i-1][j+1] + a[i].p; if (i-1+j &gt;= a[i].m) f[i][j] = std::min(f[i][j], f[i-1][j]); } } cout &lt;&lt; f[n][0] &lt;&lt; endl;} ¶ E2 按 mmm 降序考虑 考虑所有 mi=xm_i=xmi​=x ，记 mi=xm_i=xmi​=x 的人数为 sss，记 mi&lt;xm_i&lt;xmi​&lt;x 的人数为 ppp 若 p≥xp\\ge xp≥x 可以直接继续考虑 若 p&lt;xp &lt; xp&lt;x 则需要在 mi&gt;xm_i&gt;xmi​&gt;x 中买人，用 multiset 维护一下 按道理说应该要特殊考虑把 mi=xm_i=xmi​=x 一起买下来的特殊情况，但是不考虑也是对的 存疑 设当前正在考虑 mi=xm_i = xmi​=x ，mi=xm_i=xmi​=x 的人数为 sss ，mi&lt;xm_i&lt;xmi​&lt;x 的人数为 ppp 第一个 mi&gt;xm_i&gt;xmi​&gt;x，记 y=miy=m_iy=mi​，必然有 p+s+cnt≥yp+s+cnt\\ge yp+s+cnt≥y 考虑 xxx ， need=x−p−cntneed = x-p-cntneed=x−p−cnt s−need=s−x+p+cnt=y−x&gt;0s-need=s-x+p+cnt=y-x&gt;0s−need=s−x+p+cnt=y−x&gt;0 所以 s&gt;needs&gt;needs&gt;need 所以不用考虑买全部 mi=xm_i=xmi​=x 12345678910111213141516171819202122std::vector&lt;ll&gt; v[N];void solve(){ int n; cin &gt;&gt; n; rep(i, 0, n) v[i].clear(); rep(i, 1, n){ ll m, p; cin &gt;&gt; m &gt;&gt; p; v[m].push_back(p); } std::multiset&lt;ll&gt; s; ll prev = n, cnt = 0, res = 0; per(i, n, 0){ prev -= v[i].size(); int need = i - prev - cnt; for(auto x : v[i]) s.insert(x); for(; need &gt; 0; --need){ ++cnt; res += *s.begin(); s.erase(s.begin()); } } cout &lt;&lt; res &lt;&lt; endl;}","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF1251"},{"title":"Codeforces Round #625","text":"¶ 翻译 ¶ A. Contest for Robots 给出长度为 1≤n≤1001\\le n\\le 1001≤n≤100 的两个序列 r,br,br,b，且满足 ri,bi∈{0,1}r_i, b_i\\in\\{0, 1\\}ri​,bi​∈{0,1}，你需要确定 pip_ipi​（pi≥1p_i\\ge 1pi​≥1）。 满足 ∑i=1nripi&gt;∑i=1nbipi\\sum_{i=1}^n r_ip_i &gt; \\sum_{i=1}^n b_ip_i∑i=1n​ri​pi​&gt;∑i=1n​bi​pi​，并且最小化 max⁡i=1npi\\max_{i=1}^n{p_i}maxi=1n​pi​ 。 如果不可能，输出 −1-1−1 。 ¶ B. Journey Planning 给出长度为 1≤n≤2⋅1051\\le n\\le 2\\cdot 10^51≤n≤2⋅105 的序列 bbb，1≤bi≤4⋅1051\\le b_i\\le 4\\cdot 10^51≤bi​≤4⋅105 称合法序列为，c1,⋯ ,ckc_1,\\cdots,c_kc1​,⋯,ck​，满足 ci&lt;ci+1c_i&lt;c_{i+1}ci​&lt;ci+1​ 和 ci+1−ci=bci+1−bcic_{i+1}-c_i = b_{c_{i+1}}-b_{c_i}ci+1​−ci​=bci+1​​−bci​​（k=1k=1k=1 时也是合法的），定义其美丽值为 ∑i=1kbci\\sum_{i=1}^k b_{c_i}∑i=1k​bci​​ 。 求最大美丽值。 ¶ C. Remove Adjacent 给出字符串 sss，1≤∣s∣≤1001\\le|s|\\le1001≤∣s∣≤100 。 定义一次变换为，选中第 iii 个字符移除，字符串长度减少 111，选中字符需要满足 si−1,si+1s_{i-1},s_{i+1}si−1​,si+1​ 中至少有一个是 sis_isi​ 的前驱。 求最多可进行几次操作。 ¶ D. Navigation System 给出 2≤n≤2⋅1052\\le n\\le2\\cdot 10^52≤n≤2⋅105 个节点，2≤m≤2⋅1052\\le m\\le2\\cdot 10^52≤m≤2⋅105 条边的有向图，路径 p1,⋯ ,pkp_1,\\cdots,p_kp1​,⋯,pk​，路径中没有重复元素，边 (pi,pi+1)(p_i,p_{i+1})(pi​,pi+1​) 总是存在。 定义 s=p1,t=pks=p_1,t=p_ks=p1​,t=pk​ 。 有一个导航系统，若当前在节点 uuu，会构造一条从 uuu 到 ttt 的最短路径（这种路径可能不止一条，但导航系统只会选其中一条），设导航系统规划的下一个节点为 www，实际行走的下一个节点为 vvv 。 w=vw=vw=v 不会触发重构。 w≠vw\\neq vw=v 会触发重构。 实际行走路线为 ppp，求可能的最少重构次数和最多重构次数。 ¶ E. World of Darkraft: Battle for Azathoth 有 nnn 种武器，攻击力和价格分别为 ai,caia_i,ca_iai​,cai​ 。 有 mmm 种盔甲，防御力和价格分别为 bi,cbib_i,cb_ibi​,cbi​ 。 是 caica_icai​ 而不是 c⋅aic\\cdot a_ic⋅ai​ 有 ppp 个敌人，防御力、攻击力和掉落金币数为 xi,yi,zix_i,y_i,z_ixi​,yi​,zi​ 。 求 max⁡i,j{(∑xk&lt;ai,yk&lt;bjzk)−cai−cbj} \\max_{i,j}\\left\\{\\left(\\sum_{x_k&lt;a_i,y_k&lt;b_j} z_k\\right) - ca_i - cb_j\\right\\} i,jmax​⎩⎪⎨⎪⎧​⎝⎛​xk​&lt;ai​,yk​&lt;bj​∑​zk​⎠⎞​−cai​−cbj​⎭⎪⎬⎪⎫​¶ F. Reachable Strings 有零一串 ttt，从 111 编号，t[l…r]t[l\\dots r]t[l…r] 代表 lll 到 rrr 的字串（字串是连续的）。 有两种变换，011-&gt;110 和 110-&gt;011 。若字符串 s1s_1s1​ 可经过若干次（可为 000）变换变成 s2s_2s2​ 则称 s1s_1s1​ 可到达 s2s_2s2​ 。 有 qqq 个询问，给出 l1,l2,lenl_1,l_2,lenl1​,l2​,len，问 t[l1…l1+len−1]t[l_1\\dots l_1+len-1]t[l1​…l1​+len−1] 是否可到达 t[l2⋯l2+len−1]t[l_2\\cdots l_2+len-1]t[l2​⋯l2​+len−1] 。 ¶ 题解 ¶ A. Contest for Robots 对于 ri=bir_i=b_iri​=bi​ 或 ri=0,bi=1r_i=0,b_i=1ri​=0,bi​=1 肯定填 111 若没有 ri=1,bi=0r_i=1,b_i=0ri​=1,bi​=0 则无解， 否则就是让这些 ri=1,bi=0r_i=1,b_i=0ri​=1,bi​=0 凑出来。 ∑ri=1,bi=0pi&gt;∑ri=0,bi=11 \\sum_{r_i=1,b_i=0} p_i &gt; \\sum_{r_i=0,b_i=1} 1 ri​=1,bi​=0∑​pi​&gt;ri​=0,bi​=1∑​11234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl; using std::make_pair; using std::pair;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair&lt;int, int&gt; pii; const int N = 200;int r[N], b[N], p[N];int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; r[i]; rep(i, 1, n) cin &gt;&gt; b[i]; int ge; bool flag = 0; int x = 0, y = 0, z; rep(i, 1, n){ if (r[i] == b[i]) { z++; continue; } if (r[i] == 1) x++; if (b[i] == 1) y++; } if (x == 0){ cout &lt;&lt; -1; } else { if ((y+1)%x == 0) cout &lt;&lt; (y+1)/x; else cout &lt;&lt; (y+1)/x + 1; } return 0;} ¶ B. Journey Planning 移项可得 ci+1−bci+1=ci−bcic_{i+1}-b_{c_{i+1}} = c_i-b_{c_i}ci+1​−bci+1​​=ci​−bci​​ 即对于 iii，定义 di=i−bid_i=i-b_idi​=i−bi​ 合法序列即为满足 dci=⋯=dckd_{c_i}=\\cdots=d_{c_k}dci​​=⋯=dck​​ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl; using std::make_pair; using std::pair;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair&lt;int, int&gt; pii; const int N = 600010;int b[N], a[N];ll sum[N*2];int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n; cin &gt;&gt; n; ll ans = 0; rep(i, 1, n){ cin &gt;&gt; b[i]; a[i] = N+i - b[i]; sum[a[i]] += b[i]; ans = std::max(ans, sum[a[i]]); } cout &lt;&lt; ans; return 0;} ¶ C. Remove Adjacent 举例来说，对于 c，只有 b 对 c 有影响，删除 d, e, f,… 要么不会影响，要么使 b 更加靠近 c，让 c 能被删除。 总的来说，就是进行多次扫描，每一次扫描，删除可删除的最大字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl; using std::make_pair; using std::pair;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair&lt;int, int&gt; pii; const int N = 1000;char s[N], prev[N], next[N];bool tag[N];int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n; cin &gt;&gt; n; cin &gt;&gt; s+1; rep(i, 1, n){ cin &gt;&gt; s[i]; } rep(i, 0, n+1) prev[i] = i-1, next[i] = i+1; int ans = 0; while(1){ int add = 0, targ = 0; rep(i, 1, n){ if (tag[i]) continue; if (s[prev[i]] - s[i] == -1 || s[next[i]] - s[i] == -1){ targ = std::max(targ, int(s[i])); } } rep(i, 1, n){ if (tag[i]) continue; if (s[i] == targ &amp;&amp; (s[prev[i]] - s[i] == -1 || s[next[i]] - s[i] == -1)){ prev[next[i]] = prev[i]; next[prev[i]] = next[i]; add++; tag[i] = 1; } } if (add == 0) break; ans += add; } cout &lt;&lt; ans; return 0;} ¶ D. Navigation System 若当前在节点 uuu，设导航系统可能规划的下一个节点为 w1,⋯ ,wxw_1,\\cdots,w_xw1​,⋯,wx​，实际行走的下一个节点为 vvv 。 设 d(u)d(u)d(u) 为 uuu 到 ttt 距离。 若 d(w)&lt;d(v)d(w)&lt;d(v)d(w)&lt;d(v) 那么一定会重构。 若 d(w)=d(v)d(w)=d(v)d(w)=d(v) 那么可能会重构。 d(u)d(u)d(u) 构建反图求即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl; using std::make_pair; using std::pair;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair&lt;int, int&gt; pii; namespace graph {const int INF = 2147483647;template &lt;int N, int M&gt;struct graph { struct edge { int v, w; edge *nxt; edge() : v(0), w(0), nxt(NULL) {} edge(int _v, int _w, edge *_nxt) : v(_v), w(_w), nxt(_nxt) {} }; edge e[M]; edge *head[N]; int cnt, n; inline void addedge(const int &amp;u, const int &amp;v, const int w) { e[cnt] = edge(v, w, head[u]); head[u] = &amp;e[cnt]; ++cnt; } graph() { std::memset(head, 0, sizeof(head)); cnt = 0; } void dijkstra(int s, int dis[]) { for (int i = 0; i &lt;= n; ++i) { dis[i] = INF; } std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt;&gt; q; dis[s] = 0; q.push(std::make_pair(0, s)); while (!q.empty()) { pii cur = q.top(); q.pop(); if (cur.first &gt; dis[cur.second]) continue; for (edge *i = head[cur.second]; i != NULL; i = i-&gt;nxt) { if (dis[i-&gt;v] &gt; cur.first + i-&gt;w) { dis[i-&gt;v] = cur.first + i-&gt;w; q.push(std::make_pair(dis[i-&gt;v], i-&gt;v)); } } } }};} // namespace graphconst int N = 2e5+100, M = 2e5+100;graph::graph&lt;N, M&gt; f, g;int p[N], dis[N];int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; f.n = g.n = n; rep(i, 1, m){ int u, v; cin &gt;&gt; u &gt;&gt; v; f.addedge(u, v, 1); g.addedge(v, u, 1); } int k; cin &gt;&gt; k; rep(i, 1, k) cin &gt;&gt; p[i]; g.dijkstra(p[k], dis); int min = 0, max = 0; rep(qaq, 1, k-1){ int less = 0, eq = 0; int u = p[qaq]; int s = dis[p[qaq+1]]; for(auto i = f.head[u]; i ; i = i-&gt;nxt){ if (i-&gt;v == p[qaq+1]) continue; if (dis[i-&gt;v] &lt; s) less++; if (dis[i-&gt;v] == s) eq++; } if (less) min++; if (less || eq) max++; } cout &lt;&lt; min &lt;&lt; ' ' &lt;&lt; max; return 0;} ¶ E. World of Darkraft: Battle for Azathoth 是一个简单扫描线。 构造线段树，支持区间加，总体最大。 按武器的攻击力（或者说敌人的防御力）扫描，线段树维护盔甲的防御力（或者说敌人的攻击力），线段树中不是盔甲防御力的值的地方赋成 −∞-\\infin−∞，其余地方赋成 −cb-cb−cb 。 具体看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl; using std::make_pair; using std::pair;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair&lt;int, int&gt; pii; const int N = 1e6+10;ll inf = 0x3f3f3f3f3f3f3f3f;int n, m; ll c;struct Seg{ struct Node{ int l, r; ll sum, tag, max; } T[N*4];#define s T[c]#define ls (c&lt;&lt;1)#define rs ((c&lt;&lt;1)|1)#define ln T[ls]#define rn T[rs] inline void upd(int c){ s.sum = ln.sum + rn.sum; s.max = std::max(ln.max, rn.max); } inline void pushdown(int c){ ln.tag += s.tag, rn.tag += s.tag; ln.sum += (ln.r-ln.l+1)*s.tag, rn.sum += (rn.r-rn.l+1)*s.tag; ln.max += s.tag, rn.max += s.tag; s.tag = 0; } void build(int c, int l, int r){ s.l = l, s.r = r; if (l == r){ s.sum = s.max = -inf; return; } int mid = (l+r)/2; build(ls, l, mid); build(rs, mid+1, r); upd(c); } void init(int n){ build(1, 1, n); } int P, L, R; ll X; void _add(int c){ if (L &lt;= s.l &amp;&amp; s.r &lt;= R){ s.tag += X; s.max += X; s.sum += (s.r-s.l+1)*X; return; } if (s.r &lt; L || R &lt; s.l) return; pushdown(c); _add(ls); _add(rs); upd(c); } void add(int pos, ll x){ L = R = pos, X = x; _add(1); } void add(int l, int r, ll x){ L = l, R = r, X = x; _add(1); } ll _query(int c){ if (L &lt;= s.l &amp;&amp; s.r &lt;= R) return s.sum; if (s.r &lt; L || R &lt; s.l) return 0; pushdown(c); return _query(ls) + _query(rs); } ll _query_max(int c){ if (L &lt;= s.l &amp;&amp; s.r &lt;= R) return s.max; if (s.r &lt; L || R &lt; s.l) return -inf; pushdown(c); return std::max(_query_max(ls), _query_max(rs)); } ll query_max(int l, int r){ L=l, R=r; return _query_max(1); } ll query_sum(int l, int r){ L=l, R=r; return _query(1); } void print(int c){ cerr &lt;&lt; s.l &lt;&lt; ' ' &lt;&lt; s.r &lt;&lt; ' ' &lt;&lt; s.max &lt;&lt; endl; if (s.l == s.r){ return; } pushdown(c); print(ls); print(rs); }#undef s#undef ls#undef rs#undef ln#undef rn} ds;struct W{ int a; ll c; bool operator== (const W&amp; rhs){ return a == rhs.a; }} w[N], a[N];bool cmp(const W&amp;a, const W&amp; b){ return a.a == b.a ? a.c &lt; b.c : a.a &lt; b.a;}struct X{ int x, y, z;} mos[N];bool cmp_x(const X&amp;a, const X&amp;b){ return a.x &lt; b.x;}int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; rep(i, 1, n) cin &gt;&gt; w[i].a &gt;&gt; w[i].c; rep(i, 1, m) cin &gt;&gt; a[i].a &gt;&gt; a[i].c; std::sort(w+1, w+1+n, cmp); n = std::unique(w+1, w+1+n) - (w+1); std::sort(a+1, a+1+m, cmp); m = std::unique(a+1, a+1+m) - (a+1); // cerr &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; endl; rep(i, 1, p) cin &gt;&gt; mos[i].x &gt;&gt; mos[i].y &gt;&gt; mos[i].z; std::sort(mos+1, mos+1+p, cmp_x); int M = 1e6+10; ds.init(M); rep(i, 1, m){ ds.add(a[i].a, inf-a[i].c); } // ds.print(1); ll ans = -inf; int j = 1; rep(i, 1, n){ for(; j &lt;= p &amp;&amp; mos[j].x &lt; w[i].a; ++j) ds.add(mos[j].y+1, M, mos[j].z); ans = std::max(ans, ds.query_max(1, M) - w[i].c); } cout &lt;&lt; ans; return 0;} ¶ F. Reachable Strings","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF1321"},{"title":"「Codeforces 24D」Broken Robot","text":"因为不能向上走，所以可以一行一行考虑 fi,jf_{i,j}fi,j​ 表示从 (i,j)(i,j)(i,j) 走到最后一行的期望步数，fn,j=0f_{n,j}=0fn,j​=0 fi,1=(fi,1+fi,2+fi+1,1)/3+1fi,j=(fi,j−1+fi,j+fi,j+1+fi+1,j)/4+1fi,m=(fi,m+fi,m−1+fi+1,m)/3+1 \\begin{aligned} f_{i, 1}&amp;=(f_{i,1}+f_{i,2}+f_{i+1,1})/3+1\\\\ f_{i,j}&amp;=(f_{i,j-1}+f_{i,j}+f_{i,j+1}+f_{i+1,j})/4+1\\\\ f_{i, m}&amp;=(f_{i,m}+f_{i,m-1}+f_{i+1,m})/3+1\\\\ \\end{aligned} fi,1​fi,j​fi,m​​=(fi,1​+fi,2​+fi+1,1​)/3+1=(fi,j−1​+fi,j​+fi,j+1​+fi+1,j​)/4+1=(fi,m​+fi,m−1​+fi+1,m​)/3+1​矩阵大概是这样的，需要优化求解 [2/3−1/300000−1/43/4−1/400000−1/43/4−1/400000−1/43/4−1/400000−1/43/4−1/400000−1/43/4−1/400000−1/32/3][fi+1,1/3+1fi+1,2/4+1fi+1,3/4+1fi+1,4/4+1fi+1,5/4+1fi+1,6/4+1fi+1,7/3+1] \\begin{bmatrix} 2/3 &amp; -1/3 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ -1/4 &amp; 3/4 &amp; -1/4 &amp;0&amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; -1/4 &amp; 3/4 &amp; -1/4 &amp; 0 &amp; 0 &amp; 0\\\\ 0&amp;0 &amp; -1/4 &amp; 3/4 &amp; -1/4 &amp; 0 &amp; 0 \\\\ 0&amp;0&amp;0&amp;-1/4&amp;3/4&amp;-1/4&amp;0\\\\ 0&amp;0&amp;0&amp;0&amp;-1/4&amp;3/4&amp;-1/4\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;-1/3&amp;2/3\\\\ \\end{bmatrix} \\begin{bmatrix} f_{i+1,1}/3+1\\\\ f_{i+1,2}/4+1\\\\ f_{i+1,3}/4+1\\\\ f_{i+1,4}/4+1\\\\ f_{i+1,5}/4+1\\\\ f_{i+1,6}/4+1\\\\ f_{i+1,7}/3+1 \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​2/3−1/400000​−1/33/4−1/40000​0−1/43/4−1/4000​00−1/43/4−1/400​000−1/43/4−1/40​0000−1/43/4−1/3​00000−1/42/3​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​fi+1,1​/3+1fi+1,2​/4+1fi+1,3​/4+1fi+1,4​/4+1fi+1,5​/4+1fi+1,6​/4+1fi+1,7​/3+1​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 先从上往下弄成这样（xxx只是一个占位符，表示不是 000 没有实际含义） [xx000000xx000000xx000000xx000000xx000000xx000000x] \\begin{bmatrix} x &amp; x &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; x &amp; x &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; x &amp; x &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; x &amp; x &amp; 0 &amp; 0\\\\ 0&amp;0&amp;0&amp;0&amp;x&amp;x&amp;0\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;x&amp;x\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;x\\\\ \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​x000000​xx00000​0xx0000​00xx000​000xx00​0000xx0​00000xx​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​在从下往上弄成这样就好了 [x0000000x0000000x0000000x0000000x0000000x0000000x] \\begin{bmatrix} x &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; x &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; x &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; x &amp; 0 &amp; 0 &amp; 0\\\\ 0&amp;0&amp;0&amp;0&amp;x&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;x&amp;0\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;x\\\\ \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​x000000​0x00000​00x0000​000x000​0000x00​00000x0​000000x​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;int n, m, x, y;const int N = 1009;double f[N][N], a[N][N];const double ot = double(1) / 3;const double tf = double(3) / 4;const double of = double(1) / 4;int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; x &gt;&gt; y; if (m == 1) { cout &lt;&lt; (n - x) * 2; return 0; } per(i, n - 1, x) { a[1][1] = a[m][m] = 2 / 3.0, a[1][m + 1] = 1 + f[i + 1][1] / 3; a[1][2] = a[m][m - 1] = -1 / 3.0, a[m][m + 1] = 1 + f[i + 1][m] / 3; rep(j, 2, m - 1) a[j][j - 1] = a[j][j + 1] = -1 / 4.0, a[j][j] = 3 / 4.0, a[j][m + 1] = 1 + f[i + 1][j] / 4; rep(i, 1, m) { double rate = a[i + 1][i] / a[i][i]; a[i + 1][i] = 0, a[i + 1][i + 1] -= rate * a[i][i + 1], a[i + 1][m + 1] -= rate * a[i][m + 1]; } per(j, m, 1) { double rate = a[j - 1][j] / a[j][j]; a[j - 1][j] = 0, a[j - 1][m + 1] -= a[j][m + 1] * rate; f[i][j] = a[j][m + 1] / a[j][j]; } } cout.setf(std::ios::fixed); // cout &lt;&lt; std::setprecision(4) &lt;&lt; f[x][y]; cout &lt;&lt; f[x][y]; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF24D"},{"title":"「Codeforces 359B」Permutation","text":"观察 ∑i=1n∣a2i−1−a2i∣−∣∑i=1na2i−1−a2i∣=2k \\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\\sum_{i=1}^na_{2i-1}-a_{2i}|=2k i=1∑n​∣a2i−1​−a2i​∣−∣i=1∑n​a2i−1​−a2i​∣=2k发现一个绝对值在外，一个绝对值在里 a≤0,a+c≥0∣a∣+∣c∣=∣a+c∣+2∣a∣ a\\le 0, a+c\\ge0\\\\ |a|+|c|=|a+c|+2|a| a≤0,a+c≥0∣a∣+∣c∣=∣a+c∣+2∣a∣a,c≥0∣a∣+∣c∣=∣a+c∣ a,c\\ge 0\\\\ |a|+|c|=|a+c| a,c≥0∣a∣+∣c∣=∣a+c∣类似的 ∣a1−a2∣+∣a3−a4∣+⋯=2k+∣a1−a2+a3−a4⋯∣ |a_1-a_2|+|a_3-a_4|+\\cdots=2k+|a_1-a_2+a_3-a_4\\cdots| ∣a1​−a2​∣+∣a3​−a4​∣+⋯=2k+∣a1​−a2​+a3​−a4​⋯∣只要令 a1−a2=−k∀ i∈[2,n], a2i−1−a2i&gt;0 a_1-a_2=-k\\\\ \\forall\\ i\\in[2,n],\\ a_{2i-1}-a_{2i}&gt; 0 a1​−a2​=−k∀ i∈[2,n], a2i−1​−a2i​&gt;0就可满足 例如 n=6,k=2n=6,k=2n=6,k=2 时 1 3 12 11 10 9 8 7 6 5 4 2 123456789101112131415161718192021222324#include &lt;iostream&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cin;using std::cout;int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k; if (k == 0) { per(i, 2 * n, 1) cout &lt;&lt; i &lt;&lt; ' '; return 0; } cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; k + 1 &lt;&lt; ' '; per(i, 2 * n, 2) { if (i == k + 1) continue; cout &lt;&lt; i &lt;&lt; ' '; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Codeforces/CF359B"},{"title":"Comet OJ - 模拟赛测试 Day2","text":"感觉题目出得不是很难，部分分给得很足 ¶ A - 收拾房间 reorder std::merge() 秒过 ¶ B - 天天背单词 prefix 长度总和 N=106N=10^6N=106 我都不敢用 sort God Song 教育我用 suffix array，我不会 假设单词总数为 nnn 字符串比较的复杂度为 min⁡(∣s1∣,∣s2∣)\\min(|s_1|,|s_2|)min(∣s1​∣,∣s2​∣) 那么快速排序的复杂度就是 nlog⁡n⋅Nn=Nlog⁡nn\\log n \\cdot \\frac{N}{n}=N\\log nnlogn⋅nN​=Nlogn 不知道这个分析是不是假的 因为不存在某个单词是另一个单词的前缀 就可以用 hash 把单词转成一个序列 就成为了简单题 ¶ C - 养盆栽 monotony r,c≤20r,c\\le20r,c≤20 肯定是状压，考虑状态的设计 基本思想是暴力列，DP 行 暴力枚举 ststst，为保留哪些列 暴力枚举 sss，为哪些列是单调递增 s⊆sts\\subseteq sts⊆st 枚举复杂度为 3c3^c3c 定义 f(s,i)f(s,i)f(s,i) 为以第 iii 行结束，并且至少有两行，列状态为 sss 的切割方案数 f(s,i)=∑j&lt;if(s,j) f(s,i)=\\sum_{j&lt;i} f(s,j) f(s,i)=j&lt;i∑​f(s,j)如上转移即可得到答案，但复杂度过高 实际上，sss 的状态可由两行决定，也就是说其取值方案在 r2r^2r2 级别 于是只需要枚举 ststst，sss 状态的确定和 DP 转移合在一起为 r2r^2r2 故复杂度为 2cr22^cr^22cr2 ¶ Code A 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 1e5+10;int a[N], b[N], res[N], exi[N];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n, m; io.read(n), io.read(m); rep(i, 1, m){ io.read(a[i]); exi[a[i]] = 1; } int pt = 0; rep(i, 1, n) if (exi[i] == 0) b[++pt] = i; std::merge(a+1, a+1+m, b+1, b+1+pt, res+1); rep(i, 1, n) io.write(res[i], '\\n'); return 0;} B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii; typedef pair&lt;int, ll&gt; pil; typedef pair&lt;ll, ll&gt; pll;const int N = 1e6+10, p = 1e9+7, base = 29, mod1=998244353, mod2=1e9+7;ll fac[N], invf[N];ll ksm(ll a, int n){ ll ret = 1; while(n){ if (n&amp;1) (ret*=a)%=p; n&gt;&gt;=1; (a*=a)%=p; } return ret;}void init(){ fac[0] = 1; rep(i, 1, 1000000) fac[i] = fac[i-1] * i % p; invf[1000000] = ksm(fac[1000000], p-2); per(i, 999999, 0) invf[i] = invf[i+1]*(i+1)%p;}std::string s, a[N];ll A(int n, int k){ return fac[n]*invf[n-k]%p; }std::map&lt;pll, int&gt; order;#define lowbit(i) (i&amp;(-i))int c[N];void add(int i, int x){ for(; i&lt;=1000000; i+=lowbit(i)) c[i] += x; }int ask(int i){int ret = 0; for(; i &gt; 0; i-=lowbit(i)) ret += c[i]; return ret; }int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); init(); int n, K; cin &gt;&gt; n &gt;&gt; K; rep(i, 1, n) cin &gt;&gt; a[i]; std::sort(a+1, a+1+n); rep(i, 1, n){ ll ret1 = 0, ret2 = 0; for(int j = 0; j &lt; a[i].size(); ++j){ (ret1 = ret1*base+a[i][j]-'a'+1) %= mod1; (ret2 = ret2*base+a[i][j]-'a'+1) %= mod2; } order[pll(ret1, ret2)] = i; } cin &gt;&gt; s; ll ret = 0, ret1 = 0, ret2 = 0; int cnt = 0; for(int i = 0; i &lt; s.size(); ++i){ (ret1 = ret1*base+s[i]-'a'+1) %= mod1; (ret2 = ret2*base+s[i]-'a'+1) %= mod2; if (order.count(pll(ret1, ret2))){ ++cnt; int rk = order[pll(ret1, ret2)]; add(rk, 1); (ret += (rk-ask(rk))*A(n-cnt, K-cnt)%p ) %= p; ret1 = ret2 = 0; } } ret = (ret+1)%p; cout &lt;&lt; ret &lt;&lt; endl; return 0;} C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;const int R = 20;int a[R][R], f[1&lt;&lt;R][R], s_all[R][R], valid[R];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int r, c; cin &gt;&gt; r &gt;&gt; c; rep(i, 0, r-1) rep(j, 0, c-1) cin &gt;&gt; a[i][j]; ll ret = 0; rep(i, 1, r-1){ rep(j, 0, i-1){ int s = 0; rep(k, 0, c-1) if (a[i][k] &gt; a[j][k]) s |= (1&lt;&lt;k); s_all[j][i] = s; } } for(int chs = 1; chs &lt; (1&lt;&lt;c); ++chs){ rep(i, 0, r-1){ ++ret; valid[i] = 1; int ll = -1, l = -1; rep(j, 0, c-1){ if((1&lt;&lt;j)&amp;chs){ if ( ll != -1 &amp;&amp; !( (ll&lt;l&amp;&amp;l&lt;a[i][j]) || (ll&gt;l&amp;&amp;l&gt;a[i][j]) ) ) { --ret; valid[i] = 0; break; } ll = l, l = a[i][j]; } } } rep(i, 1, r-1){ if (!valid[i]) continue; rep(j, i+1, r-1) if (valid[j]) f[chs&amp;s_all[i][j]][i] = 0; rep(j, 0, i-1){ if (!valid[j]) continue; int s = (chs&amp;s_all[j][i]); f[s][i] += f[s][j] + 1; ret += f[s][j]+1; } } } cout &lt;&lt; ret &lt;&lt; endl; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Comet-OJ/contest-70"},{"title":"「Comet OJ - 2019国庆欢乐赛」两排房子","text":"「Link」 令左边房子为 li,ril_i, r_ili​,ri​ ，正在考虑右边 L,RL,RL,R 房子的答案 求出第一个 iii 满足 ri&gt;Lr_i &gt; Lri​&gt;L 求出第一个 jjj 满足 lj&gt;Rl_j &gt; Rlj​&gt;R j−ij-ij−i 即为贡献 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using std::cin; using std::cout; using std::cerr;const int N = 2000005;int l[N], r[N], L, R, n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; l[i] &gt;&gt; r[i]; long long ans = 0; for (int i = 0; i &lt; m; ++i){ cin &gt;&gt; L &gt;&gt; R; ans += (std::upper_bound(l, l+n, R) - l) - (std::lower_bound(r, r+n, L) - r); } cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Comet-OJ/%E4%B8%A4%E6%8E%92%E6%88%BF%E5%AD%90"},{"title":"「Comet OJ 58D」菜菜种菜","text":"题目链接 第 iii 个点，给定 xi≤i≤yix_i\\le i\\le y_ixi​≤i≤yi​ 和权值 aia_iai​ qqq 个询问，回答 ∑ai[L≤i≤R ∧ xi&lt;L ∧ yi&gt;R] \\sum a_i[L\\le i \\le R\\ \\wedge\\ x_i &lt; L\\ \\wedge \\ y_i&gt;R] ∑ai​[L≤i≤R ∧ xi​&lt;L ∧ yi​&gt;R]n,q≤106n,q\\le 10^6n,q≤106 首先这肯定不是一个图论问题 把所有土地排成一行，从左到右第 iii 个编号为 iii 。容易发现，一块土地 iii 能不能作为家，只跟他能直接到达的土地中，在它左边最靠右的一块（记作 ，xix_ixi​ 不存在则为 000 ）和在它右面最靠左的一块（记作 yiy_iyi​ ，不存在则为 n+1n+1n+1 ） 询问 L,RL, RL,R ，回答 f(L,R)=∑ai[L≤i≤R ∧ xi&lt;L ∧ yi&gt;R] f(L, R) = \\sum a_i[L\\le i \\le R\\ \\wedge\\ x_i &lt; L\\ \\wedge \\ y_i&gt;R] f(L,R)=∑ai​[L≤i≤R ∧ xi​&lt;L ∧ yi​&gt;R]记 s(a,b,c,d,e,f)=∑ai[a≤i≤b ∧ c≤xi≤d ∧ e≤yi≤f] s(a,b,c,d,e,f)=\\sum a_i[a\\le i \\le b\\ \\wedge\\ c\\le x_i \\le d\\ \\wedge\\ e\\le y_i\\le f]\\\\ s(a,b,c,d,e,f)=∑ai​[a≤i≤b ∧ c≤xi​≤d ∧ e≤yi​≤f]f(L,R)=+s(L,R,0,L−1,R+1,n+1)=+s(L,R,0,n+1,0,n+1)−s(L,R,L,n+1,0,n+1)−s(L,R,0,n+1,0,R)+s(L,R,L,n+1,0,R) \\begin{aligned} f(L,R) = &amp;+s(L,R,0,L-1,R+1, n+1)\\\\ = &amp;+s(L,R,0,n+1, 0, n+1)\\\\ &amp;-s(L, R,L,n+1,0,n+1)\\\\ &amp;-s(L,R,0,n+1,0,R)\\\\ &amp;+s(L,R,L,n+1,0,R) \\end{aligned} f(L,R)==​+s(L,R,0,L−1,R+1,n+1)+s(L,R,0,n+1,0,n+1)−s(L,R,L,n+1,0,n+1)−s(L,R,0,n+1,0,R)+s(L,R,L,n+1,0,R)​一个容斥，最后因为 xi≥L,yi≤Rx_i\\ge L, y_i \\le Rxi​≥L,yi​≤R 被减了两次，需要加回来。 由 xi&lt;i&lt;yix_i&lt;i&lt;y_ixi​&lt;i&lt;yi​ 可得 L≤i≤R,xi≥L⇔i≤R,xi≥LL≤i≤R,yi≤R⇔i≥L,yi≤RL≤i≤R,xi≥L,yi≤R⇔xi≥L,yi≤R \\begin{aligned} L\\le i\\le R, x_i\\ge L&amp;\\Leftrightarrow i\\le R,x_i\\ge L\\\\ L\\le i\\le R, y_i\\le R&amp;\\Leftrightarrow i\\ge L,y_i\\le R\\\\ L\\le i\\le R, x_i\\ge L,y_i\\le R&amp;\\Leftrightarrow x_i\\ge L, y_i \\le R \\end{aligned} L≤i≤R,xi​≥LL≤i≤R,yi​≤RL≤i≤R,xi​≥L,yi​≤R​⇔i≤R,xi​≥L⇔i≥L,yi​≤R⇔xi​≥L,yi​≤R​所以问题变成了三个二维数点，用扫描线和树状数组即可解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 1000010;struct Node { ui i, x, y, v;} p[N];struct Q { ui id, l, r; ll ans;} ask[N];bool cmp_l(const Q &amp;a, const Q &amp;b) { return a.l &lt; b.l; }bool cmp_r(const Q &amp;a, const Q &amp;b) { return a.r &lt; b.r; }bool cmp_id(const Q &amp;a, const Q &amp;b) { return a.id &lt; b.id; }bool cmp_y(const Node &amp;a, const Node &amp;b) { return a.y &lt; b.y; }ll pre[N], c[N + 5];// #define debug(x) cerr &lt;&lt; x &lt;&lt; endl#define debug(x)inline int lowbit(int x) { return x &amp; (-x); }void add(int i, ll x) { ++i; for (; i &lt;= N; i += lowbit(i)) { debug(i); c[i] += x; }}ll sum(int i) { ++i; ll ret = 0; for (; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret;}ll query(int l, int r) { return sum(r) - sum(l - 1); }int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n, m, q; io.read(n), io.read(m), io.read(q); rep(i, 1, n) io.read(p[i].v), p[i].x = 0, p[i].y = n + 1, p[i].i = i, pre[i] = pre[i - 1] + p[i].v; while (m--) { ui u, v; io.read(u), io.read(v); if (v &lt; u) p[u].x = std::max(p[u].x, v); else p[u].y = std::min(p[u].y, v); } rep(i, 1, q) io.read(ask[i].l), io.read(ask[i].r), ask[i].ans = pre[ask[i].r] - pre[ask[i].l - 1], ask[i].id = i; debug(&quot;read over&quot;); // i &lt;= R, x_i &gt;= L std::sort(ask + 1, ask + 1 + q, cmp_r); int ptr = 1; rep(i, 1, q) { while (ptr &lt;= n &amp;&amp; p[ptr].i &lt;= ask[i].r) add(p[ptr].x, p[ptr].v), ++ptr; ask[i].ans -= query(ask[i].l, n + 1); } debug(&quot;i &lt;= R, x_i &gt;= L&quot;); // x &gt;= L, y &lt;= R std::memset(c, 0, sizeof(c)); ptr = 1; std::sort(p + 1, p + 1 + n, cmp_y); rep(i, 1, q) { while (ptr &lt;= n &amp;&amp; p[ptr].y &lt;= ask[i].r) add(p[ptr].x, p[ptr].v), ++ptr; ask[i].ans += query(ask[i].l, n + 1); } // y &lt;= R, i &gt;= L std::memset(c, 0, sizeof(c)); ptr = 1; rep(i, 1, q) { while (ptr &lt;= n &amp;&amp; p[ptr].y &lt;= ask[i].r) add(p[ptr].i, p[ptr].v), ++ptr; ask[i].ans -= query(ask[i].l, n + 1); } ll ans = 0; rep(i, 1, q) ans ^= ask[i].id * ask[i].ans; io.write(ans); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Comet-OJ/%E8%8F%9C%E8%8F%9C%E7%A7%8D%E8%8F%9C"},{"title":"「CH 4302」Interval GCD","text":"主要是记一个结论 a0=0gcd⁡i=1nai=gcd⁡i=1nai−ai−1 a_0 = 0\\\\ \\gcd_{i=1}^na_i=\\gcd_{i=1}^n a_i-a_{i-1} a0​=0i=1gcdn​ai​=i=1gcdn​ai​−ai−1​这样，维护区间修改 gcd⁡\\gcdgcd 查询就非常方便 注意 gcd⁡\\gcdgcd 的写法 12345ll gcd(ll x, ll y){ return x &amp;&amp; y ? gcd(y, x%y) : std::max(std::abs(x),std::abs(y));} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;ll gcd(ll x, ll y){ return x&amp;&amp;y?gcd(y, x%y):std::max(std::abs(x),std::abs(y));}const int N = 500000;ll d[N+10], a[N+10];int lowbit(int x){ return x&amp;(-x); }struct SpecialBIT{ ll c[N+10]; void _e(int i, ll x){ for(; i &lt;= N; i+=lowbit(i)) c[i] += x; } ll ask(int i){ ll ret = 0; for(; i &gt; 0; i-=lowbit(i)) ret += c[i]; return ret; } void edit(int l, int r, ll x){ _e(l, x), _e(r+1, -x); }} seg;#define ls (c&lt;&lt;1)#define rs ((c&lt;&lt;1)|1)#define s T[c]struct Node{ int l, r; ll g; } T[N*4];void build(int c, int l, int r){ s.l = l, s.r = r; if (l == r){ s.g = d[l]; return; } int mid = (l+r)&gt;&gt;1; build(ls, l, mid), build(rs, mid+1, r); T[c].g = gcd(T[ls].g, T[rs].g);}int L, R;ll query(int c){ if (s.r &lt; L || R &lt; s.l || L &gt; R) return 0; if (L &lt;= s.l &amp;&amp; s.r &lt;= R) return s.g; return gcd(query(ls), query(rs));}void edit(int P, ll X){ int c = 1; if (P &gt; s.r) return; for (; s.l != s.r; c = (P &lt;= ((s.l+s.r) &gt;&gt; 1))?ls:rs) ; s.g += X; c &gt;&gt;= 1; for (; c != 1; c &gt;&gt;= 1) s.g = gcd(T[ls].g, T[rs].g);}void print(int c){ if (s.l == s.r){ cout &lt;&lt; s.g &lt;&lt; ' '; return ; } print(ls), print(rs);}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; rep(i, 1, n){ cin &gt;&gt; a[i]; seg.edit(i,i,a[i]); d[i] = a[i] - a[i-1]; } build(1, 1, n); while(m--){ char opt; cin &gt;&gt; opt; if (opt == 'C'){ int l, r; ll d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; seg.edit(l, r, d); edit(l, d), edit(r+1, -d); // print(1); cout &lt;&lt; endl; } else { cin &gt;&gt; L &gt;&gt; R; L++; cout &lt;&lt; gcd(seg.ask(L-1), query(1)) &lt;&lt; '\\n'; } } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Contest-Hunter/CH4302"},{"title":"「CH 5302」金字塔","text":"「Link」 一道 trivial 的 DP 定义 fi,jf_{i, j}fi,j​ 为序列为 si…js_{i\\dots j}si…j​ 的树的个数 si≠sjs_i\\neq s_jsi​=sj​ 显然 fi,j=0f_{i,j}=0fi,j​=0 考虑如何处理 fi,jf_{i,j}fi,j​ i=ji=ji=j 就是只有一个节点 有一个或多个子节点，考虑第一个子树是在哪里断 具体来说，考虑所有 sk=si=sj(i&lt;k≤r)s_k=s_i=s_j(i&lt;k\\le r)sk​=si​=sj​(i&lt;k≤r) 钦定 si+1…k−1s_{i+1\\dots k-1}si+1…k−1​ 为一棵子树 其余的丢到以后考虑 fi,j=∑i&lt;k≤j,sk=sifi+1,k−1⋅fk,j f_{i,j}=\\sum_{i&lt;k\\le j,s_k=s_i} f_{i+1, k-1}\\cdot f_{k,j} fi,j​=i&lt;k≤j,sk​=si​∑​fi+1,k−1​⋅fk,j​记忆化搜索 123456789101112131415const int MOD = 1e9;int f[N][N];int calc(int l, int r) { // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; if (f[l][r] != -1) return f[l][r]; if (l == r) return f[l][r] = 1; int ret = 0; rep(k, l + 1, r) { if (s[k] == s[l]) { (ret += (ll)calc(l + 1, k - 1) * calc(k, r) % MOD) %= MOD; } } return f[l][r] = ret;} 递推 12345678rep(i, 1, n) f[i][i] = 1;for (int len = 2; len &lt;= n; len += 2) // 事实证明长度肯定为奇数 rep(i, 1, n - len){ int j = i + len; rep(k, i + 1, j) if (s[i] == s[k]) (f[i][j] += (ll)f[i + 1][k - 1] * f[k][j] % MOD) %= MOD; } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;const int N = 310;char s[N];const int MOD = 1e9;int f[N][N];// int calc(int l, int r) {// // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;// if (f[l][r] != -1) return f[l][r];// if (l == r) return f[l][r] = 1;// int ret = 0;// rep(k, l + 1, r) {// if (s[k] == s[l]) {// (ret += (ll)calc(l + 1, k - 1) * calc(k, r) % MOD) %= MOD;// }// }// return f[l][r] = ret;// }int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); cin &gt;&gt; s + 1; int n = strlen(s + 1); rep(i, 1, n) f[i][i] = 1; for (int len = 2; len &lt;= n; len += 2) { rep(i, 1, n - len) { int j = i + len; rep(k, i + 1, j) { if (s[i] == s[k]) { (f[i][j] += (ll)f[i + 1][k - 1] * f[k][j] % MOD) %= MOD; } } } } cout &lt;&lt; f[1][n]; // std::memset(f, -1, sizeof(f)); // cout &lt;&lt; calc(1, n); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/Contest-Hunter/%E9%87%91%E5%AD%97%E5%A1%94"},{"title":"「NOI 2010」炮兵阵地","text":"「Link」 首先观察炮的攻击范围，左右上下完全对称 也就是说，A 打不到 B 和 B 打不到 A 是等价的，于是就考虑左边和上面 一行一行地考虑，正在考虑第 iii 行 一行内部炮冲突的问题是容易解决的 考虑上几行对第 iii 行，第 jjj 列能不能放的的影响有 (i−1,j)(i-1,j)(i−1,j) 和 (i−2,j)(i-2,j)(i−2,j) 很自然的，可以定义出压缩的状态 000 下一行可以放（当然还要综合地形考虑 ） 111 下一行不可以放 222 下两行不可以放 如果直接暴力枚举会有大量冗余，考虑 dfs 递推 假设当前已处理完 fi,jf_{i,j}fi,j​ iii 为行号，jjj 为状态，kkk 为列号，vvv 表示递推的状态 jk=2→vk=1j_k=2\\rightarrow v_k = 1jk​=2→vk​=1 jk=1→vk=0j_k=1\\rightarrow v_k = 0jk​=1→vk​=0 gi,k=H→vk=0g_{i,k}=H\\rightarrow v_k = 0gi,k​=H→vk​=0 其他情况 vk=0/2v_k=0/2vk​=0/2 行内部的冲突问题，相信各位肯定想想就知道 程序存在大量优化的空间（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;const int p[] = {1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441};const int N = 101, M = 11;int g[N], f[2][531441];std::vector&lt;int&gt; s;int *cur;int n, m, prev, v[M];// #define dbg(...) fprintf(stderr, __VA_ARGS__);#define dbg(...)void dfs(int status, int i, int lst, int cnt) { if (i == m) { dbg(&quot;reach\\n&quot;); cur[status] = std::max(cur[status], cnt + prev); return; } if (v[i] == 1 || v[i] == 0) dfs(status + v[i] * p[i], i + 1, lst, cnt); else if (lst + 2 &lt; i) { dfs(status + 2 * p[i], i + 1, i, cnt + 1); dfs(status, i + 1, lst, cnt); } else { dfs(status, i + 1, lst, cnt); }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; std::memset(f, -1, sizeof(f)); f[0][0] = 0; for (int i = 0; i &lt; p[m]; ++i) { int valid = 1; for (int x = i, j = 0, lst = -5; j &lt; m; ++j, x /= 3) if (x % 3 == 2) { if (lst + 2 &lt; j) lst = j; else { valid = 0; break; } } if (valid) s.push_back(i); } for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; m; ++j) { char c; cin &gt;&gt; c; g[j] = (c == 'H'); } cur = f[(i + 1) &amp; 1]; std::memset(cur, -1, sizeof(f) / 2); for (auto j : s) { if (f[i &amp; 1][j] == -1) continue; prev = f[i &amp; 1][j]; for (int k = 0, x = j; k &lt; m; ++k, x /= 3) { if (x % 3 == 2) v[k] = 1; else if (x % 3 == 1 || g[k]) v[k] = 0; else v[k] = -1; dbg(&quot;%3d&quot;, v[k]); } dbg(&quot;\\n&quot;); dfs(0, 0, -5, 0); } } int ans = -1; for (auto j : s) ans = std::max(ans, f[n &amp; 1][j]); cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/NOI/%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0"},{"title":"「NOIP 2008」传纸条","text":"题目链接 为了方便，坐标先行后列。 设 A=(1,1),B=(m,n)A = (1, 1),B = (m, n)A=(1,1),B=(m,n) 不考虑不能传相同同学 从 A 到 B 再从 B 到 A ∼\\sim∼ 从 A 同时考虑两条路到 B 设 iii为 A 到 B 线路 1 的行号，jjj为 A 到 B 线路 2 的行号，kkk为当前行列之和 对于线路1，(i,k−i)(i, k-i)(i,k−i) 可从 (i−1,k−i)(i-1, k-i)(i−1,k−i) 和 (i,k−i−1)(i, k-i-1)(i,k−i−1) 推得 对于线路2，(j,k−j)(j, k-j)(j,k−j) 可从 (j−1,k−j)(j-1, k-j)(j−1,k−j) 和 (j,k−j−1)(j, k-j-1)(j,k−j−1) 推得 故对于 dp(i,j,k)dp(i, j, k)dp(i,j,k) 有四种情况。 dp(i,j,k)=a[i][k−i]+a[j][k−j]+max⁡{dp(i,j,k−1),dp(i−1,j−1,k−1),dp(i−1,j,k−1),dp(i−1,j−1,k−1)} \\begin{aligned} dp(i, j, k) = a[i][k-i] + a[j][k -j] + \\max\\{ &amp; dp(i, j, k-1), \\\\ &amp; dp(i-1,j-1,k-1), \\\\ &amp; dp(i-1,j,k-1), \\\\ &amp; dp(i-1,j-1,k-1)\\} \\\\ \\end{aligned} dp(i,j,k)=a[i][k−i]+a[j][k−j]+max{​dp(i,j,k−1),dp(i−1,j−1,k−1),dp(i−1,j,k−1),dp(i−1,j−1,k−1)}​ 现在来考虑重合。红绿为两条路线，蓝色为相交部分。 经过变换，可以变成这样。 现在问题主要是解决蓝色格子，由于两条路线规划同时从左上角开始，代码实现时 k-&gt;i-&gt;j 三重循环。 若i=ji=ji=j那么就是有重叠，此时只要把多的一次减掉。 ∵\\because∵ 对于某一条路线来说，走了一个价值为 000 的格子的路线。 又 ∵ai,j≥0\\because a_{i,j} \\ge 0∵ai,j​≥0 ∴\\therefore∴ 必定没有一种不相交的路线规划比起更劣。 ∴\\therefore∴ 此重叠的方案不会是最优方案，必定会在动规中舍弃。 比如绿色路线可以是 (2,1)(3,1)(2,2)(3,3)(4,3)(5,3)(6,3)(6,4)(6,5)(2,1)(3,1) (2,2)(3,3)(4,3)(5,3)(6,3)(6,4)(6,5)(2,1)(3,1)(2,2)(3,3)(4,3)(5,3)(6,3)(6,4)(6,5) 12345678910111213141516171819202122cin &gt;&gt; m &gt;&gt; n;for (register int i = 1; i &lt;= m; ++i){ for (register int j = 1; j &lt;= n; ++j){ cin &gt;&gt; a[i][j]; }}for (register int k = 3; k &lt;= m + n; ++k){ t1 = min(k-1, m); for (register int i = 1; i &lt;= t1; ++i){ t2 = min(k-1, m); for (register int j = 2; j &lt;= t2; ++j){ dp[i][j][k] = max( dp[i-1][j][k-1], dp[i-1][j-1][k-1], dp[i][j-1][k-1], dp[i][j][k-1] ) + a[i][k-i] + a[j][k-j]; if (i == j) dp[i][j][k] -= a[i][k-i]; } }}cout &lt;&lt; dp[m][m][m+n];","link":"/archives/%E9%A2%98%E8%A7%A3/NOIP/%E4%BC%A0%E7%BA%B8%E6%9D%A1%E9%A2%98%E8%A7%A3"},{"title":"「NOIP 2017」列队","text":"首先感受到这是数据结构题 然后发现你需要用数据结构维护序列，支持 删除第 kkk 个数 在末尾加入一个数 考虑用平衡树维护 注意到 n=m=q=3×105n=m=q=3\\times 10^5n=m=q=3×105 ，肯定不能把点一个一个开出来，所以一个节点就表示一个区间 [l,r][l, r][l,r] ，用 prefix 表示 lll 的编号 发现 FHQ-Treap 可以比较自然地维护 因为我只会写无旋 Treap 新增一种操作 unfold(u, x) ，调用时保证 u-&gt;l &lt;= x &lt;= u-&gt;r 表示将 uuu 分裂成 [l,x−1] [x,x] [x+1,r][l,x-1]~~[x, x]~~[x+1, r][l,x−1] [x,x] [x+1,r] 三部分，且 [x,x][x,x][x,x] 为子树的根 并且保证分裂后 u-&gt;l == u-&gt;r == x 123456789101112131415161718192021222324252627void unfold(Node *&amp;u, int k) { // 必须保证 u 为根 assert(u-&gt;l != u-&gt;r); assert(u-&gt;l &lt;= k &amp;&amp; k &lt;= u-&gt;r); if (u-&gt;l == k) { Node *t = gen(k + 1, u-&gt;r, u-&gt;prefix + 1); t-&gt;rs = u-&gt;rs; u-&gt;rs = t; u-&gt;r = k; u-&gt;rs-&gt;upd(), u-&gt;upd(); } else if (u-&gt;r == k) { Node *t = gen(u-&gt;l, u-&gt;r - 1, u-&gt;prefix); t-&gt;ls = u-&gt;ls; u-&gt;ls = t; u-&gt;prefix += +u-&gt;r - u-&gt;l; u-&gt;l = u-&gt;r; u-&gt;ls-&gt;upd(), u-&gt;upd(); } else { Node *t1 = gen(u-&gt;l, k - 1, u-&gt;prefix), *t2 = gen(k + 1, u-&gt;r, u-&gt;prefix + k + 1 - u-&gt;l); t1-&gt;ls = u-&gt;ls; t2-&gt;rs = u-&gt;rs; u-&gt;ls = t1, u-&gt;rs = t2; u-&gt;prefix += k - u-&gt;l; u-&gt;l = u-&gt;r = k; u-&gt;ls-&gt;upd(), u-&gt;rs-&gt;upd(), u-&gt;upd(); }} 发现还需要支持删除第 kkk 个数，考虑用 split_rank 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297#define NDEBUG#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)#ifdef NDEBUG#define dbg(x)#else#define dbg(x) cerr &lt;&lt; x &lt;&lt; endl;#endifusing std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), pp(pbuf), p2(buf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;inline int rnd() { static int seed = 703; return seed = int(seed * 48271LL % 2147483647);}const int N = 300100;struct Node { int l, r, pri, siz; ll prefix; Node *ls, *rs; void upd() { siz = (ls ? ls-&gt;siz : 0) + (rs ? rs-&gt;siz : 0) + r - l + 1; } int rank() { return (ls ? ls-&gt;siz : 0) + 1; }} T[9000000];void print(Node *u) {#ifdef NDEBUG return;#else if (u == nullptr) return; print(u-&gt;ls); dbg(u-&gt;l &lt;&lt; ' ' &lt;&lt; u-&gt;r &lt;&lt; ' ' &lt;&lt; u-&gt;prefix); print(u-&gt;rs);#endif}int cnt = 0;Node *gen(int l, int r, ll prefix) { T[cnt].l = l, T[cnt].r = r, T[cnt].prefix = prefix, T[cnt].ls = T[cnt].rs = nullptr, T[cnt].siz = r - l + 1, T[cnt].pri = rnd(); return &amp;T[cnt++];}Node *gen(int x, ll prefix) { T[cnt].l = T[cnt].r = x, T[cnt].prefix = prefix, T[cnt].ls = T[cnt].rs = nullptr, T[cnt].siz = 1, T[cnt].pri = rnd(); return &amp;T[cnt++];}int num[N], lstc;Node *rt[N], *lst;typedef std::pair&lt;Node *, Node *&gt; pnn;Node *merge(Node *u, Node *v) { if (u == nullptr) return v; if (v == nullptr) return u; if (u-&gt;pri &gt; v-&gt;pri) { u-&gt;rs = merge(u-&gt;rs, v); u-&gt;upd(); return u; } else { v-&gt;ls = merge(u, v-&gt;ls); v-&gt;upd(); return v; }}void unfold(Node *&amp;u, int k) { // 必须保证 u 为根 assert(u-&gt;l != u-&gt;r); assert(u-&gt;l &lt;= k &amp;&amp; k &lt;= u-&gt;r); if (u-&gt;l == k) { Node *t = gen(k + 1, u-&gt;r, u-&gt;prefix + 1); t-&gt;rs = u-&gt;rs; u-&gt;rs = t; u-&gt;r = k; u-&gt;rs-&gt;upd(), u-&gt;upd(); } else if (u-&gt;r == k) { Node *t = gen(u-&gt;l, u-&gt;r - 1, u-&gt;prefix); t-&gt;ls = u-&gt;ls; u-&gt;ls = t; u-&gt;prefix += +u-&gt;r - u-&gt;l; u-&gt;l = u-&gt;r; u-&gt;ls-&gt;upd(), u-&gt;upd(); } else { Node *t1 = gen(u-&gt;l, k - 1, u-&gt;prefix), *t2 = gen(k + 1, u-&gt;r, u-&gt;prefix + k + 1 - u-&gt;l); t1-&gt;ls = u-&gt;ls; t2-&gt;rs = u-&gt;rs; u-&gt;ls = t1; u-&gt;rs = t2; u-&gt;prefix += k - u-&gt;l; u-&gt;l = u-&gt;r = k; u-&gt;ls-&gt;upd(), u-&gt;rs-&gt;upd(), u-&gt;upd(); }}pnn split_rank(Node *u, int k) { if (u == nullptr) return {nullptr, nullptr}; if (u-&gt;l != u-&gt;r &amp;&amp; u-&gt;rank() &lt;= k &amp;&amp; k &lt;= u-&gt;rank() + u-&gt;r - u-&gt;l) { unfold(u, u-&gt;l + k - u-&gt;rank()); } if (u-&gt;rank() &lt;= k) { pnn o = split_rank(u-&gt;rs, k - (u-&gt;rank() + u-&gt;r - u-&gt;l)); u-&gt;rs = o.first; u-&gt;upd(); return {u, o.second}; } else { pnn o = split_rank(u-&gt;ls, k); u-&gt;ls = o.second; u-&gt;upd(); return {o.first, u}; }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n, m, q; io.read(n), io.read(m), io.read(q); rep(i, 1, n) { num[i] = m - 1; rt[i] = gen(1, m - 1, (ll)(i - 1) * m + 1); } rep(i, 1, n) { lst = merge(lst, gen(i, (ll)i * m)); } lstc = n; rep(stp, 1, q) { int x, y; io.read(x), io.read(y); if (y == m) { pnn o1, o2; o2 = split_rank(lst, x); o1 = split_rank(o2.first, x - 1); io.write(o1.second-&gt;prefix, '\\n'); o1.second-&gt;siz = 1, o1.second-&gt;ls = o1.second-&gt;rs = nullptr, o1.second-&gt;l = o1.second-&gt;r = ++lstc; lst = merge(merge(o1.first, o2.second), o1.second); } else { pnn t1, t2, o1, o2; print(rt[x]); t2 = split_rank(rt[x], y); t1 = split_rank(t2.first, y - 1); o2 = split_rank(lst, x); o1 = split_rank(o2.first, x - 1); io.write(t1.second-&gt;prefix, '\\n'); o1.second-&gt;siz = 1, o1.second-&gt;ls = o1.second-&gt;rs = nullptr, o1.second-&gt;l = o1.second-&gt;r = ++num[x]; t1.second-&gt;siz = 1, t1.second-&gt;ls = t1.second-&gt;rs = nullptr, t1.second-&gt;l = t1.second-&gt;r = ++lstc; rt[x] = merge(merge(t1.first, t2.second), o1.second); lst = merge(merge(o1.first, o2.second), t1.second); } } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/NOIP/%E5%88%97%E9%98%9F"},{"title":"「NOIP 2004」合唱队形","text":"记忆化搜索 定义一个 solve(x, lim, dir) x 表示处理完的层数，所有x == n是就return lim 是限制条件 dir 表示方向，true为向上，false向下 当 dir == true 时，显然有以下情况 若 height[x+1] &gt; lim 选 solve(x+1, height[x+1], true) 不选 solve(x+1, lim, true) 若 height[x+1] &lt; lim 不选 solve(x+1, lim, true) 选，并改方向 solve(x+1, lim, false) 若 height[x+1] == lim 只能跳 solve(x+1, lim, false) 当 dir == false时，不能再换方向，显然有以下情况 若 height[x+1] &gt; lim 不选 solve(x+1, lim, false) 若 height[x+1] &lt; lim 选 solve(x+1, height[x+1], false) 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;using std::endl;int t[101], dp[101][231][2], n, ans=200;int solve(int x, int max,bool dir){ if (x == n){ return 0; } if (dp[x][max][dir]!=-1) return dp[x][max][dir]; int&amp; ans = dp[x][max][dir]; if (dir){ if (t[x+1] &lt; max) return ans = std::min(solve(x+1,max,true)+1,solve(x+1,t[x+1],false)); if (t[x+1] &gt; max) return ans = std::min(std::min(solve(x+1,t[x+1],true),solve(x+1,max,true)+1), solve(x+1,t[x+1],false)); return ans = solve(x+1,max,true)+1; }else{ if (t[x+1] &lt; max) return ans = std::min(solve(x+1,t[x+1],false),solve(x+1,max,false)+1); if (t[x+1] &gt;= max) return ans = solve(x+1,max,false)+1; }}int main(){ std::memset(dp, -1, sizeof(dp)); int i; cin &gt;&gt; n; for (i=1;i&lt;=n;++i) cin &gt;&gt; t[i]; cout &lt;&lt; solve(0,0,true); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/NOIP/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2%E9%A2%98%E8%A7%A3"},{"title":"「NOIP 2009」最优贸易","text":"题目概述 LOJ #2590. 「NOIP2009」最优贸易 C 国有 nnn 个大城市和 mmm 条道路，每条道路连接这 nnn 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 mmm 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 111 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 nnn 个城市的标号从 1∼n1\\sim n1∼n，阿龙决定从 111 号城市出发，并最终在 nnn 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 nnn 个城市。 阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 C 国有 555 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 111 ~ nnn 号城市的水晶球价格分别为 4,3,5,6,14,3,5,6,14,3,5,6,1 。 阿龙可以选择如下一条线路：1→2→3→51\\to 2\\to 3\\to 51→2→3→5，并在 222 号城市以 333 的价格买入水晶球，在 333 号城市以 555 的价格卖出水晶球，赚取的旅费数为 222 。 阿龙也可以选择如下一条线路 1→4→5→4→51\\to 4\\to 5\\to 4\\to 51→4→5→4→5，并在第 111 次到达 555 号城市时以 111 的价格买入水晶球，在第 222 次到达 444 号城市时以 666 的价格卖出水晶球，赚取的旅费数为 555 。 现在给出 nnn 个城市的水晶球价格， mmm 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 ¶ 解法一 Tarjan 缩点， 重构图 + 判可达性（某一个强连通分量能否到达终点，若不能，则不能更新 ans ） + 跑 DAG 上的 DP 用了一个结论：Tarjan 逆序即为拓扑序 具体看代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 100005;std::vector&lt;int&gt; g[N], ng[N], fg[N];int price[N];int min[N], max[N], dfn[N], ins[N], low[N], color[N], dp[N];std::stack&lt;int&gt; s;int cnt = 0;int T = 0;void tarjan(int u) { dfn[u] = low[u] = ++T, ins[u] = 1; s.push(u); for (auto v : g[u]) { if (!dfn[v]) { tarjan(v); low[u] = std::min(low[u], low[v]); } else if (ins[v]) { low[u] = std::min(low[u], low[v]); } } if (dfn[u] == low[u]) { int x; cnt++; // cerr &lt;&lt; &quot;cnt&quot; &lt;&lt; cnt &lt;&lt; &quot;:\\n&quot;; do { x = s.top(); s.pop(); // cerr &lt;&lt; x &lt;&lt; ' '; color[x] = cnt, ins[x] = 0; min[cnt] = std::min(min[cnt], price[x]); max[cnt] = std::max(max[cnt], price[x]); } while (x != u); // cerr &lt;&lt; endl; }}int coutable[N];void dfs(int u) { if (coutable[u]) return; coutable[u] = 1; for (auto v : fg[u]) dfs(v);}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::memset(min, 0x3f, sizeof(min)); std::ios::sync_with_stdio(false); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; rep(i, 1, n) cin &gt;&gt; price[i]; rep(i, 1, m) { int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; g[x].push_back(y); if (z - 1) g[y].push_back(x); } // tarjan tarjan(1); // rebuild rep(u, 1, n) { for (auto v : g[u]) if (color[u] != color[v]) ng[color[u]].push_back(color[v]); } // connectable rep(u, 1, cnt) for (auto v : ng[u]) fg[v].push_back(u); dfs(color[n]); // topo + dp int ans = 0; std::memset(dp, 0x3f, sizeof(dp)); per(u, cnt, 1) { dp[u] = std::min(dp[u], min[u]); if (coutable[u]) ans = std::max(ans, max[u] - dp[u]); for (auto v : ng[u]) { dp[v] = std::min(dp[v], dp[u]); } } cout &lt;&lt; ans; return 0;} ¶ 解法二 正图反图跑 SPFA转移方程定义为 dv=min⁡(min⁡u→v{du},pricev) d_{v} = \\min\\Big(\\min_{u\\rightarrow v}\\{d_u\\}, price_v\\Big) dv​=min(u→vmin​{du​},pricev​)最后减一下 ¶ 解法三 引用一下 构造分层图，具体看上面","link":"/archives/%E9%A2%98%E8%A7%A3/NOIP/%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93"},{"title":"「NOIP 2017」逛公园","text":"乱七八糟 我好弱啊 这一题只想到递推 DP 又没有想出正解 到现在还是这么菜 NOIP 2019 如何 500+ 首先发现 kkk 很小，自然地想到 DP 令 ddd 表示最短路 fu,xf_{u, x}fu,x​ 代表从 sss 到 uuu 路径长为 du+xd_u + xdu​+x 的方案数量 如何转移？ 用记忆化搜索比较自然，而且也容易判 000 环（DFS 的性质比较好） 假设当前在求 fu,xf_{u, x}fu,x​，vvv 为有 v→uv\\rightarrow uv→u 边的点，www 为边权 fu,x=∑fv,x+du−w−dv f_{u,x} = \\sum f_{v, x+d_u-w-d_v} fu,x​=∑fv,x+du​−w−dv​​环判定就 woc 这题我 Dijkstra 还写挂了 具体看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int BUF = 50000000;struct IOStream { char ibuf[BUF], *s; char obuf[BUF], *oh; IOStream() : s(ibuf), oh(obuf) { ibuf[fread(ibuf, 1, BUF, stdin)] = '\\0'; } ~IOStream() { fwrite(obuf, 1, oh - obuf, stdout); } template &lt;typename T&gt; inline IOStream &amp;operator&gt;&gt;(T &amp;x) { while (!isdigit(*s)) s++; for (x = 0; isdigit(*s); s++) x = x * 10 + (*s ^ '0'); return *this; }} cin;using std::cout;const int N = 100010;const int M = 200010;int P, n, m, k;struct Graph { struct Edge { int v, w; Edge *nxt; } e[M]; int cnt = 0; Edge *p[N]; void clear() { std::memset(p, 0, sizeof(p)); cnt = 0; } void addedge(int u, int v, int w) { e[cnt].v = v, e[cnt].w = w, e[cnt].nxt = p[u], p[u] = &amp;e[cnt++]; }} g, fg;int dis[N], flg[N];std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt; &gt; q;void dijkstra(int s) { std::memset(dis, -1, sizeof(dis)); std::memset(flg, 0, sizeof(flg)); dis[s] = 0; q.push({0, s}); while (q.size()) { pii cur = q.top(); q.pop(); if (flg[cur.second]) continue; flg[cur.second] = 1; for (Graph::Edge *i = g.p[cur.second]; i != nullptr; i = i-&gt;nxt) { if (!flg[i-&gt;v] &amp;&amp; (dis[i-&gt;v] == -1 || dis[i-&gt;v] &gt; cur.first + i-&gt;w)) { dis[i-&gt;v] = cur.first + i-&gt;w; q.push({dis[i-&gt;v], i-&gt;v}); } } }}int f[N][52], vis[N][52];int now = 0;bool zp = 0; // 环判定int work(int u, int lk) { if (zp) return 0; if (f[u][lk] != -1) return f[u][lk]; vis[u][lk] = 1; f[u][lk] = 0; for (Graph::Edge *i = fg.p[u]; i != NULL &amp;&amp; !zp; i = i-&gt;nxt) { int nk = lk + dis[u] - i-&gt;w - dis[i-&gt;v]; if (nk &gt; k || nk &lt; 0 || dis[i-&gt;v] == -1) continue; if (vis[i-&gt;v][nk]) { zp = 1; return 0; } f[u][lk] = (f[u][lk] + work(i-&gt;v, nk)) % P; } vis[u][lk] = 0; return f[u][lk];}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int T; cin &gt;&gt; T; while (T--) { g.clear(), fg.clear(); std::memset(f, -1, sizeof(f)); std::memset(vis, 0, sizeof(vis)); zp = 0; int t_t = clock(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; P; rep(i, 1, m) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g.addedge(u, v, w), fg.addedge(v, u, w); } g.addedge(0, 1, 0), fg.addedge(1, 0, 0); dijkstra(0); // 特别的，这里采取加入虚点 0 来防止环由 1 号点构成而判不出来 // 就是你样例过不去的意思 233 cerr &lt;&lt; &quot;dij &quot; &lt;&lt; ((double)clock() - t_t) / CLOCKS_PER_SEC &lt;&lt; endl; t_t = clock(); int ans = 0; f[0][0] = 1; rep(i, 0, k) { now = i; ans = (ans + work(n, i)) % P; } if (zp) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ans); cerr &lt;&lt; &quot;work &quot; &lt;&lt; ((double)clock() - t_t) / CLOCKS_PER_SEC &lt;&lt; endl; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/NOIP/%E9%80%9B%E5%85%AC%E5%9B%AD"},{"title":"「POJ 2311」Cutting Game","text":"w×hw\\times hw×h 的纸张，每次能沿横或纵切一刀，最先切出 1×11\\times11×1 的人赢 2≤w,h≤2002\\le w,h\\le 2002≤w,h≤200 需要注意的是这时候判胜负不是“能不能进行下一次操作”，而是“最先切出 1×11\\times 11×1 ”，需要稍作转换 发现所有 1×n1\\times n1×n 都是必胜的 即转移到 1×n1\\times n1×n 是不行的 12345678910111213int sg[210][210];int calc(int x, int y) { if (x &gt; y) std::swap(x, y); if (sg[x][y] != -1) return sg[x][y]; std::set&lt;int&gt; s; rep(i, 2, x - 2) // 不能切出 1*n s.insert(calc(i, y) ^ calc(x - i, y)); rep(i, 2, y - 2) // 不能切出 n*1 s.insert(calc(x, i) ^ calc(x, y - i)); int lst = 0; while (s.count(lst)) lst++; return sg[x][y] = lst;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;int sg[210][210];int calc(int x, int y) { if (x &gt; y) std::swap(x, y); if (sg[x][y] != -1) return sg[x][y]; std::set&lt;int&gt; s; rep(i, 2, x - 2) s.insert(calc(i, y) ^ calc(x - i, y)); rep(i, 2, y - 2) s.insert(calc(x, i) ^ calc(x, y - i)); int lst = 0; while (s.count(lst)) lst++; return sg[x][y] = lst;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); std::memset(sg, -1, sizeof(sg)); sg[1][1] = 0; int x, y; while (cin &gt;&gt; x &gt;&gt; y) { cout &lt;&lt; (calc(x, y) ? &quot;WIN&quot; : &quot;LOSE&quot;) &lt;&lt; endl; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/POJ/CuttingGame"},{"title":"「POJ 1151」Atlantis","text":"求多个矩形的面积并 沿 xxx 轴扫描，用数据结构维护 yyy 这题用到的数据结构很有意思 维护长度为 nnn 的序列，支持 区间加法 求序列中大于 000 的数的个数 但是这道题目存在一个特殊的性质：每个数不会减到负，所以问题就简单了 下面是线段树节点合并 12345// s 是当前节点s.sum = s.t ? raw[s.r] - raw[s.l-1] : (s.l == s.r ? 0 : T[ls].sum + T[rs].sum); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#define NDEBUG#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;std::map&lt;double, int&gt; ord;const int N = 220;double x[N], y[N], ans, raw[N];struct P { double x, y1, y2; int p = 0; bool operator&lt;(const P&amp; rhs) const { return x &lt; rhs.x; }} p[N];struct Node { int l, r, t; double sum;}T[N*16];#define s T[c]#define ls (c&lt;&lt;1)#define rs ((c&lt;&lt;1)|1)void build(int c, int l, int r){ s.l = l, s.r = r, s.t = 0; if (l == r) return; int mid = (l+r)&gt;&gt;1; build(ls, l, mid), build(rs, mid+1, r);}void edit(int c, int l, int r, int p){ assert(l&lt;=r); assert(p == 1 || p == -1); if (r &lt; s.l || s.r &lt; l) return; if (l &lt;= s.l &amp;&amp; s.r &lt;= r) { s.t += p; s.sum = s.t ? raw[s.r] - raw[s.l-1] : (s.l == s.r ? 0 : T[ls].sum + T[rs].sum); return; } edit(ls, l, r, p), edit(rs, l, r, p); s.sum = s.t ? raw[s.r] - raw[s.l-1] : (s.l == s.r ? 0 : T[ls].sum + T[rs].sum);}void print(int c){ cerr &lt;&lt; s.l &lt;&lt; ' ' &lt;&lt; s.r &lt;&lt; ' ' &lt;&lt; s.sum &lt;&lt; ' ' &lt;&lt; s.t &lt;&lt; endl; if (s.l == s.r) return; print(ls), print(rs);}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int n, num = 0; cout.setf(std::ios::fixed); while(cin &gt;&gt; n &amp;&amp; n != 0){ ++num, ans = 0; int tot = 0; double x1, x2, y1, y2; rep(i, 1, n) { cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; p[i].p = 1, p[i].x = x1, p[i+n].p = -1, p[i+n].x = x2, raw[tot++] = p[i].y1 = p[i+n].y1 = y1, raw[tot++] = p[i].y2 = p[i+n].y2 = y2; } std::sort(p+1, p+1+n+n); std::sort(raw, raw+tot), tot = std::unique(raw, raw+tot) - raw; build(1, 0, tot); ord.clear(); for(int i = 0; i &lt; tot; ++i) ord[raw[i]] = i; rep(i, 1, 2*n){ // cerr &lt;&lt; p[i].x - p[i-1].x &lt;&lt; ' ' &lt;&lt; T[1].sum &lt;&lt; endl; ans += (p[i].x - p[i-1].x) * T[1].sum; // cerr &lt;&lt; &quot;edit &quot; &lt;&lt; ord[p[i].y1] &lt;&lt; ' ' &lt;&lt; ord[p[i].y2] &lt;&lt; ' ' &lt;&lt; p[i].p &lt;&lt; endl; assert(ord.count(p[i].y1) &amp; ord.count(p[i].y2)); edit(1, ord[p[i].y1]+1, ord[p[i].y2], p[i].p); // print(1); } cout &lt;&lt; &quot;Test case #&quot; &lt;&lt; std::setprecision(2) &lt;&lt; num &lt;&lt; endl &lt;&lt; &quot;Total explored area: &quot; &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/POJ/POJ-1151"},{"title":"「USACO 2007 Dec. Gold」Sightseeing Cows","text":"给定一张 n≤1000n\\le1000n≤1000 个点、m≤5000m\\le5000m≤5000 条边的有向图 每个点都有一个权值 fif_ifi​ ，每条边都有一个权值 tit_iti​ 求图中的一个环，使“环上各点的权值之和”除以“环上各边的权值之和”最大 对答案进行二分，二分的值为 midmidmid ∃ ∑f∑t&gt;mid⇔∃ ∑f−mid×t&gt;0⇔∃ ∑mid×t−f&lt;0 \\begin{aligned} &amp;\\exist\\ \\frac{\\sum f}{\\sum t}&gt;mid\\\\ \\Leftrightarrow &amp;\\exist\\ \\sum f-mid\\times t&gt;0\\\\ \\Leftrightarrow &amp;\\exist\\ \\sum mid\\times t- f&lt;0 \\end{aligned} ⇔⇔​∃ ∑t∑f​&gt;mid∃ ∑f−mid×t&gt;0∃ ∑mid×t−f&lt;0​不能推到第二行式子就开始判 因为负环判定实际上是判是否存在负环 而不是所有环都是负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;const int N = 1010, M = 5050;struct Edge{ int t, v; double w;} e[M];std::vector&lt;Edge*&gt; p[N];int n, f[N], c[N];double d[N];bool inq[N];// negative_loop =&gt; 1int spfa(){ std::queue&lt;int&gt; q; std::memset(c, 0, sizeof(c)); std::memset(d, 0, sizeof(d)); rep(i, 1, n) q.push(i), inq[i] = 1; while(q.size()){ int u = q.front(); q.pop(); inq[u] = 0; for(auto i : p[u]){ if (d[i-&gt;v] &gt; d[u] + i-&gt;w){ if ((c[i-&gt;v]=c[u]+1) &gt;= n) return 1; d[i-&gt;v] = d[u] + i-&gt;w; if (!inq[i-&gt;v]) q.push(i-&gt;v), inq[i-&gt;v] = 1; } } } return 0;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int m; cin &gt;&gt; n &gt;&gt; m; rep(i, 1, n) cin &gt;&gt; f[i]; rep(i, 1, m){ int u; cin &gt;&gt; u &gt;&gt; e[i].v &gt;&gt; e[i].t; p[u].push_back(&amp;e[i]); } double l = 0, r = 1000; rep(ndacljk, 1, 20){ double mid = (l+r)/2; rep(i, 1, m) e[i].w = mid * e[i].t - f[e[i].v]; if (spfa()){ l = mid; } else { r = mid; } } std::cout.setf(std::ios::fixed); cout &lt;&lt; std::setprecision(2) &lt;&lt; l &lt;&lt; endl; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/USACO/sightseeing-cows"},{"title":"「USACO 2011 Jan. Gold」道路和航线","text":"题目概述 LOJ #10081. 「一本通 3.2 练习 7」道路和航线 原题来自：USACO 2011 Jan. Gold Farmer John 正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到 TTT 个城镇 ，编号为 111 到 TTT。这些城镇之间通过 RRR 条道路（编号为 111 到 RRR）和 PPP 条航线（编号为 111 到 PPP）连接。每条道路 iii 或者航线 iii 连接城镇 AiA_iAi​ 到 BiB_iBi​，花费为 CiC_iCi​。 对于道路，0≤Ci≤1040 \\le C_i \\le 10^40≤Ci​≤104，然而航线的花费很神奇，花费 CiC_iCi​ 可能是负数。道路是双向的，可以从 AiA_iAi​ 到 BiB_iBi​，也可以从 BiB_iBi​ 到 AiA_iAi​，花费都是 CiC_iCi​。然而航线与之不同，只可以从 AiA_iAi​ 到 BiB_iBi​。 事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从 AiA_iAi​ 到 BiB_iBi​，那么保证不可能通过一些道路和航线从 BiB_iBi​ 回到 AiA_iAi​。由于 FJ 的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇 SSS 把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。 如果去掉航线可以发现原图变成了许多连通块 若把一个连通块看成一个节点,则发现连通块和航线组成 DAG 考虑 Topo sort 结合 Dijkstra 称连通块和航线组成的图为 GGG，连通块 AAA 内部节点和道路的图为 gAg_AgA​ 假设 sss 所在的连通块为 SSS，对所有在 GGG 中可从 SSS 到达的连通块进行拓扑排序（否则算 deg 的时候会算多），一边拓扑一边 Dijkstra 大致是这个样子 123456789101112131415161718q &lt;- Topo_Queue;while(q not empty): clr = q.front(); q.pop(); heap &lt;- Dijkstra_Priority_Queue; for (u 为 clr 节点) if (dis[u] != INF) heap.push(dis[u], u); while(heap not empty): u = heap.top(); heap.pop(); for 从 u 出发道路: // 普通 Dijkstra 写法，略 for 从 u 出发的航线(u, v, w): A 为 v 所在的连通块; if (A 不可从 S 出发到达) continue; deg[A]--; if (deg[A] == 0) q.push(A); dis[v] = min(dis[v], dis[u] + w) 然后代码稍微长了一些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 25030, inf = 0x3f3f3f3f;std::vector&lt;pii&gt; g[N];std::vector&lt;pii&gt; ng[N];std::vector&lt;int&gt; gg[N];std::vector&lt;int&gt; block[N];int color[N], cnt = 0, deg[N], able[N], dis[N], vis[N];void dfs(int u) { block[color[u]].push_back(u); for (auto i : g[u]) { int v = i.first; if (!color[v]) color[v] = color[u], dfs(v); }}void dfs_gg(int u) { able[u] = 1; for (auto v : gg[u]) { if (!able[v]) dfs_gg(v); }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::memset(dis, 0x3f, sizeof(dis)); std::ios::sync_with_stdio(false); cout.tie(0); int n, r, p, s; cin &gt;&gt; n &gt;&gt; r &gt;&gt; p &gt;&gt; s; rep(i, 1, r) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(pii(v, w)); g[v].push_back(pii(u, w)); } rep(i, 1, n) if (!color[i]) color[i] = ++cnt, dfs(i); // 连通块划分 rep(i, 1, p) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; ng[u].push_back(pii(v, w)); gg[color[u]].push_back(color[v]); } int ss = color[s]; dfs_gg(ss); // cerr &lt;&lt; &quot;connectable divided&quot; &lt;&lt; endl; rep(u, 1, cnt) { if (!able[u]) continue; for (auto v : gg[u]) deg[v]++; } // cerr &lt;&lt; &quot;degree calced&quot; &lt;&lt; endl; dis[s] = 0; std::queue&lt;int&gt; q; q.push(ss); std::priority_queue&lt;pii, std::vector&lt;pii&gt;, std::greater&lt;pii&gt;&gt; heap; while (q.size()) { int block_id = q.front(); q.pop(); for (auto i : block[block_id]) if (dis[i] &lt; inf) heap.push(pii(dis[i], i)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = 1; for (auto i : g[u]) { int v = i.first, w = i.second; if (dis[v] &gt; dis[u] + w) dis[v] = dis[u] + w, heap.push(pii(dis[v], v)); } for (auto i : ng[u]) { int v = i.first, w = i.second; if (!able[color[v]]) continue; deg[color[v]]--; if (deg[color[v]] == 0) q.push(color[v]); dis[v] = std::min(dis[v], dis[u] + w); } } } rep(i, 1, n) { if (dis[i] == inf) cout &lt;&lt; &quot;NO PATH&quot; &lt;&lt; endl; else cout &lt;&lt; dis[i] &lt;&lt; endl; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/USACO/%E9%81%93%E8%B7%AF%E5%92%8C%E8%88%AA%E7%BA%BF"},{"title":"「牛客 1103B」路径计数机","text":"是道好题 可惜卡常数 思路：暴力枚举 (a,b)(a,b)(a,b)，快速统计 (c,d)(c,d)(c,d) 定义 f(u)f(u)f(u) 为以 uuu 为 LCA⁡\\operatorname{LCA}LCA 的 (c,d)(c,d)(c,d) 个数 tsf(u)=∑f(v)tsf(u)=\\sum f(v)tsf(u)=∑f(v)，vvv 在子树 uuu 中 csf(u)csf(u)csf(u) 111 到 uuu 路径上所有点的 ∑f\\sum f∑f (c,d)(c,d)(c,d) 总数量记为 sqsqsq 经过 uuu 到 uuu 的父节点点对 (c,d)(c,d)(c,d) 数量为 vq(u)vq(u)vq(u)，可用树上差分求出 考虑对于点对 (a,b)(a,b)(a,b)，记 l=LCA⁡(a,b)l=\\operatorname{LCA}(a,b)l=LCA(a,b) LCA⁡(c,d)\\operatorname{LCA}(c,d)LCA(c,d) 在子树 lll 中，数量为 tsf(l)−(csf(a)−csf(l))−(csf(b)−csf(l))−f(l) tsf(l)-(csf(a)-csf(l))-(csf(b)-csf(l))-f(l) tsf(l)−(csf(a)−csf(l))−(csf(b)−csf(l))−f(l)LCA⁡(c,d)\\operatorname{LCA}(c,d)LCA(c,d) 不在子树 lll 中，数量为 sq−tsf(l)−vq(l) sq-tsf(l)-vq(l) sq−tsf(l)−vq(l)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(&quot;O3&quot;)#pragma GCC optimize(&quot;Ofast,no-stack-protector&quot;)#pragma GCC optimize(&quot;inline&quot;,&quot;fast-math&quot;,&quot;unroll-loops&quot;,&quot;no-stack-protector&quot;)#define rep(i, l, r) for (register int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (register int i = (l); i &gt;= (r); --i)using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 3010;int n, p, q, lc[N][N];std::vector&lt;int&gt; g[N];int dep[N], fa[13][N];void dfs_lca(int u){ dep[u] = dep[fa[0][u]] + 1; for(auto v : g[u]){ if (v == fa[0][u]) continue; fa[0][v] = u; dfs_lca(v); }}int lca(int u, int v){ if (dep[u] &lt; dep[v]) std::swap(u, v); int delta = dep[u] - dep[v]; rep(k, 0, 12) if (delta&amp;(1&lt;&lt;k)) u = fa[k][u]; if (u == v) return u; per(k, 12, 0) if (fa[k][u] != fa[k][v]) u = fa[k][u], v = fa[k][v]; return fa[0][u];}ll f[N], tsf[N], csf[N], dq[N], vq[N];void calc(int u){ csf[u] = csf[fa[0][u]] + f[u]; vq[u] = dq[u]; tsf[u] = f[u]; for(auto v : g[u]){ if (v == fa[0][u]) continue; calc(v); tsf[u] += tsf[v]; vq[u] += vq[v]; }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif io.read(n), io.read(p), io.read(q); int u, v; rep(i, 2, n){ io.read(u), io.read(v); g[u].push_back(v), g[v].push_back(u); } dfs_lca(1); rep(k, 1, 12) rep(i, 1, n) fa[k][i] = fa[k-1][fa[k-1][i]]; ll sq = 0; rep(i, 1, n){ rep(j, 1, n){ int l = lca(i, j); lc[i][j] = l; int d = dep[i] + dep[j] - dep[l] * 2; if (d == q){ sq++; f[l]++; dq[i]++, dq[j]++, dq[l] -= 2; } } } calc(1); ll ans = 0; rep(i, 1, n){ rep(j, 1, n){ int l = lc[i][j]; int d = dep[i] + dep[j] - dep[l] * 2; if (d == p){ ans += tsf[l]-(csf[i]-csf[l])-(csf[j]-csf[l])-f[l]; ans += sq - tsf[l] - vq[l]; } } } io.write(ans); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/nowcoder/1103B"},{"title":"牛客 CSP-S 提高组赛前集训营 1 题解","text":"体验还是比较好的 230 只有 100 名差评，没有享受到大样例x ¶ 比赛实录 6:30：看 T1，这个博弈我好像推不出来SG，这是 ICG 吗？ 滚去看 T2，理解题意 5min ，这个乘积怎么维护啊。。。 DP式子推推搞搞搞 宋神 A T1 了 继续搞搞搞 过样例了 跑一组大数据 woc 忘记取模了 修修修 怎么还是负数x %= 写成 % 了 终于得到一个看起来还不错的结果 宋神也写完 T2 了 传过去，对拍ing 过了.jpg 宋神 T1 代码传我 搞 T3 这个数据结构我不会啊。。 诶，这好像是图论 边连一连搞搞环行不行啊 这不就是正解吗 QAQ 好像不行x 拿个网络流板子写个 30pt 要下课了第四个数据不写了x 回寝室，10:03看榜，竟然没挂分，怎么只有 100 名 QAQ ¶ 题解 ¶ 仓鼠的石子游戏 先讨论一堆 石子数为 111 时先手赢， 否则后手赢 可以想成 &gt;1&gt;1&gt;1 时，先手作出了操作，后手一定有方案应对，最后肯定是先手不能放 扩展到 nnn 堆 123for(int i = 1; i &lt;= n; ++i) s ^= (a[i] == 1);cout &lt;&lt; (s?&quot;rabbit\\n&quot;:&quot;hamster\\n&quot;); ¶ 乃爱与城市拥挤程度 fu,if_{u,i}fu,i​ 为 uuu 的子树中，k=ik=ik=i 时有多少座城市中的人会认为乃爱天下第一（第一行答案） hu,ih_{u,i}hu,i​ 为 uuu 的子树中，k=ik=ik=i 时受到影响城市的拥挤程度的乘积（第二行答案） fu,i=1+∑u→vfv,i−1 f_{u,i}=1+\\sum_{u\\rightarrow v} f_{v,i-1} fu,i​=1+u→v∑​fv,i−1​hu,i=fu,i⋅∏u→vhv,i−1 h_{u,i}=f_{u,i}\\cdot \\prod_{u\\rightarrow v} h_{v,i-1} hu,i​=fu,i​⋅u→v∏​hv,i−1​我写的是换根，不会 up and down QAQ topfutopf_utopfu​ 表示除去子树 uuu 后，把 uuu 的父节点作为根得到的 fff，tophtophtoph 同理 topfv,i=fu,i+topfu,i−1−fv,i−1 topf_{v,i}=f_{u,i}+topf_{u,i-1}-f_{v,i-1} topfv,i​=fu,i​+topfu,i−1​−fv,i−1​tophv,i=tophu,i−1hu,ihv,i−1⋅topfu,i−1+fu,i−fv,i−1fu,i toph_{v,i}=\\frac{toph_{u,i-1}h_{u,i}}{h_{v,i-1}}\\cdot \\frac{topf_{u,i-1}+f_{u,i}-f_{v,i-1}}{f_{u,i}} tophv,i​=hv,i−1​tophu,i−1​hu,i​​⋅fu,i​topfu,i−1​+fu,i​−fv,i−1​​¶ 小w的魔术扑克 将数字看作节点，牌看作无向边 考虑一个有 nnn 个点，mmm 条边的连通块 当 m≥nm\\ge nm≥n 时，连通块的点都可以选中 当 m=n−1m=n-1m=n−1 时，必有一个点不能被选中 由于询问的是连续值域，所以只要记录每个连通块的最大值和最小值 若存在一个连通块的最大值和最小值都在询问区间中，就是 No，否则是 Yes 对于这种询问可以离线询问，把询问和连通块按照右端点排序，只要维护 maxlmaxlmaxl 即可 ¶ Code A 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;const int N = 1e3 + 10;int a[N];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int T; cin &gt;&gt; T; while(T--){ int n; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i]; int s = 0; rep(i, 1, n) s ^= (a[i] == 1); cout &lt;&lt; (s?&quot;rabbit\\n&quot;:&quot;hamster\\n&quot;); } return 0;} B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 1e5 + 10, p = 1e9+7;int n, K;std::vector&lt;int&gt; g[N];int f[N][12];ll h[N][12];int inv(ll a){ ll ret = 1; int n = p - 2; while(n){ if (n&amp;1) (ret *= a) %= p; (a *= a) %= p; n &gt;&gt;= 1; } return ret;}void dfs1(int u, int fa){ // cerr &lt;&lt; u &lt;&lt; endl; rep(k, 0, K) f[u][k] = h[u][k] = 1; if (g[u].size() == 1 &amp;&amp; fa != 0) return; for (auto v : g[u]){ if (v == fa) continue; dfs1(v, u); rep(k, 1, K){ f[u][k] += f[v][k-1], (h[u][k] *= h[v][k-1])%=p; } } rep(k, 0, K) (h[u][k] *= f[u][k])%=p;}int ans1[N]; ll ans2[N];int topf[N][12], tmpf[12];ll toph[N][12];void calc(int u, int fa){ ans1[u] = topf[u][K-1] + f[u][K]; ans2[u] = h[u][K] * toph[u][K-1] % p * ans1[u] % p * inv(f[u][K]) % p; tmpf[0] = 1; for(auto v : g[u]){ if (v == fa) continue; topf[v][0] = 1; rep(k, 1, K) topf[v][k] = f[u][k] + topf[u][k-1] - f[v][k-1]; toph[v][0] = 1; rep(k, 1, K){ toph[v][k] = toph[u][k-1] * h[u][k] % p * (topf[u][k-1] + f[u][k] - f[v][k-1]) % p * inv(h[v][k-1]) % p * inv(f[u][k]) % p; } } for(auto v : g[u]){ if (v == fa) continue; calc(v, u); }}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); // cin &gt;&gt; n &gt;&gt; K; io.read(n), io.read(K); rep(i, 2, n){ int u, v; io.read(u), io.read(v); g[u].push_back(v), g[v].push_back(u); } dfs1(1, 0); // rep(k, 0, K){ // rep(i, 1, n) // cerr &lt;&lt; f[i][k] &lt;&lt; ' '; cerr &lt;&lt; endl; // } // rep(k, 0, K){ // rep(i, 1, n) // cerr &lt;&lt; h[i][k] &lt;&lt; ' '; cerr &lt;&lt; endl; // } rep(k, 0, K) toph[1][k] = 1; calc(1, 0); // rep(k, 0, K) cerr &lt;&lt; toph[2][k] &lt;&lt; ' '; cerr &lt;&lt; endl; rep(i, 1, n) // cout &lt;&lt; ans1[i] &lt;&lt; ' '; io.write(ans1[i], ' '); // cout &lt;&lt; endl; io.push('\\n'); rep(i, 1, n) io.write(ans2[i], ' '); // cout &lt;&lt; ans2[i] &lt;&lt; ' '; // cout &lt;&lt; endl; io.push('\\n'); return 0;} C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl;using std::make_pair; using std::pair; typedef pair&lt;int, int&gt; pii;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull;const int N = 1e5 + 10;int fa[N];int getf(int x){ return (x == fa[x])?x:(fa[x]=getf(fa[x])); }std::vector&lt;int&gt; g[N];int tag[N], min, max;void dfs(int u){ min = std::min(min, u); max = std::max(max, u); tag[u] = 1; for(auto v : g[u]) if (!tag[v]) dfs(v);}struct A{ int l, r, id; A(){ l = r = id = 0; } A(int l, int r, int id){ this-&gt;l = l, this-&gt;r = r, this-&gt;id = id; }};int ans[N];bool cmp_r_A(const A&amp; a, const A&amp; b){ return a.r &lt; b.r; }bool cmp_r_pii(const pii&amp; a, const pii&amp; b){ return a.second &lt; b.second; }int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(0); cout.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k; rep(i, 1, n) fa[i] = i; std::vector&lt;int&gt; loop; rep(i, 1, k){ int u, v; cin &gt;&gt; u &gt;&gt; v; if (getf(u) == getf(v)){ loop.push_back(u); } else { fa[getf(u)] = getf(v); g[u].push_back(v), g[v].push_back(u); } } for(auto u : loop) if (!tag[u]) dfs(u); std::vector&lt;pii&gt; seg; rep(u, 1, n){ if (!tag[u]) { min = n + 1, max = 0; dfs(u); assert(min &lt;= n); assert(max &gt; 0); seg.push_back({min, max}); } } int q; cin &gt;&gt; q; std::vector&lt;A&gt; ask; rep(i, 1, q){ int u, v; cin &gt;&gt; u &gt;&gt; v; if (u &gt; v) std::swap(u, v); ask.push_back(A(u, v, i)); } std::sort(seg.begin(), seg.end(), cmp_r_pii); std::sort(ask.begin(), ask.end(), cmp_r_A); for(int i = 0, j = 0, maxl = 0; i &lt; ask.size(); ++i){ for(; j &lt; seg.size() &amp;&amp; seg[j].second &lt;= ask[i].r; ++j) maxl = std::max(maxl, seg[j].first); if (maxl &gt;= ask[i].l) ans[ask[i].id] = 1; } rep(i, 1, q) cout &lt;&lt; (ans[i]?&quot;No\\n&quot;:&quot;Yes\\n&quot;); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/nowcoder/csp-s-1"},{"title":"「一本通 1.1 练习 4」家庭作业 题解","text":"题目概述 LOJ #10008. 「一本通 1.1 练习 4」家庭作业 老师在开学第一天就把所有作业都布置了，每个作业如果在规定的时间内交上来的话才有学分。每个作业的截止日期和学分可能是不同的。例如如果一个作业学分为 101010，要求在 666 天内交，那么要想拿到这 101010 学分，就必须在第 666 天结束前交。 每个作业的完成时间都是只有一天。例如，假设有 7 次作业的学分和完成时间如下： 作业号 期限 学分 111 111 666 222 111 777 333 333 222 444 333 111 555 222 444 666 222 555 777 666 111 最多可以获得 151515 学分，其中一个完成作业的次序为 2,6,3,1,7,5,42,6,3,1,7,5,42,6,3,1,7,5,4，注意可能还有其他方法。 你的任务就是找到一个完成作业的顺序获得最大学分。 显然的贪心，先按学分 sss 从大到小，再按期限 ddd 从后到前 考虑要安排一个作业，显然是越晚越好，故用一个二分区间，用一个数据结构查询、修改 这里选择二分套树状数组 123456789101112131415161718int l = 1, r = a[i].d;// st 为树状数组if (st.sum(r) == 0) // 无法插入 continue;else { ans += a[i].s; while (l &lt;= r) { if (l == r) { st.add(l, -1); break; } int mid = (l + r) / 2; if (st.query(mid + 1, r) &gt; 0) l = mid + 1; else r = mid; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int T = 7.5 * 1e5;struct BIT { ui c[T], n = 7 * 1e5; int lowbit(int x) { return x &amp; -x; } void add(int pos, ui x) { for (int i = pos; i &lt;= n; i += lowbit(i)) c[i] += x; } ui sum(int n) { ui ret = 0; for (int i = n; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; } ui query(int l, int r) { return sum(r) - sum(l - 1); }} st;struct Node { int s, d; bool operator&lt;(const Node&amp; b) const { return (s == b.s ? d &gt; b.d : s &gt; b.s); }} a[1000010];int main() { std::ios::sync_with_stdio(false); cout.tie(0); int n, ans = 0; cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i].d &gt;&gt; a[i].s, st.add(i, 1); std::sort(a + 1, a + 1 + n); rep(i, 1, n) { int l = 1, r = a[i].d; if (st.sum(r) == 0) continue; else { ans += a[i].s; while (l &lt;= r) { if (l == r) { st.add(l, -1); // cerr &lt;&lt; l &lt;&lt; endl; break; } int mid = (l + r) / 2; if (st.query(mid + 1, r) &gt; 0) l = mid + 1; else r = mid; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E4%B8%80%E6%9C%AC%E9%80%9A/%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A"},{"title":"「洛谷 P1631」序列合并","text":"给定两个长度为 nnn 的序列 a,ba,ba,b ，定义 ci,j=ai+bjc_{i,j} = a_i+b_jci,j​=ai​+bj​ ，输出 ccc 的 n×nn\\times nn×n 个元素中前 kkk 小 n≤105n\\le10^5n≤105 核心代码 1234567891011121314struct S { int i, j; bool operator&lt;(const S &amp;rhs) const { return a[i] + b[j] &gt; a[rhs.i] + b[rhs.j]; }};std::priority_queue&lt;S&gt; q;rep(i, 1, n) q.push({i, 1}); // c[i][1]rep(cnt, 1, n) { // pop c[i][j], push c[i][j+1] int i = q.top().i, j = q.top().j; q.pop(); io.write(a[i] + b[j], ' '); ++j; if (j &lt;= n) q.push({i, j});} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 100100;int a[N], b[N];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n; io.read(n); rep(i, 1, n) io.read(a[i]); rep(j, 1, n) io.read(b[j]); struct S { int i, j; bool operator&lt;(const S &amp;rhs) const { return a[i] + b[j] &gt; a[rhs.i] + b[rhs.j]; } }; std::priority_queue&lt;S&gt; q; rep(i, 1, n) q.push({i, 1}); rep(cnt, 1, n) { int i = q.top().i, j = q.top().j; q.pop(); io.write(a[i] + b[j], ' '); ++j; if (j &lt;= n) q.push({i, j}); } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/P1631"},{"title":"「洛谷 P1290」欧几里德的游戏","text":"局面 (x,y) x,y≥0(x,y)~~~x,y\\geq0(x,y) x,y≥0 操作 (x,y)→(x−λy,y) (x−λy,y≥0)(x,y)\\rightarrow(x-\\lambda y, y)~~(x-\\lambda y,y\\geq0)(x,y)→(x−λy,y) (x−λy,y≥0) (x,0)(x,0)(x,0) 是败 给出 (x,y)(x,y)(x,y) 求是否为先手必胜 为了书写方便 SG⁡\\operatorname{SG}SG 记为 fff 首先 f(x,0)=0f(x,y)=f(y,x) \\begin{aligned} f(x,0)&amp;=0\\\\ f(x,y)&amp;=f(y,x) \\end{aligned} f(x,0)f(x,y)​=0=f(y,x)​接下来考虑 (x,y) x&gt;y(x,y)~~x&gt;y(x,y) x&gt;y f(x,y)=mex⁡{f(x−y,y),f(x−2y,y),⋯ ,f(y,x mod y)} f(x,y)=\\operatorname{mex}\\{f(x-y,y),f(x-2y,y),\\cdots,f(y, x \\bmod y)\\} f(x,y)=mex{f(x−y,y),f(x−2y,y),⋯,f(y,xmody)}发现 f(x−y,y)=mex⁡{f(x−2y,y),⋯ ,f(y,x mod y)} f(x-y,y)=\\operatorname{mex}\\{f(x-2y,y),\\cdots,f(y, x \\bmod y)\\} f(x−y,y)=mex{f(x−2y,y),⋯,f(y,xmody)}也就是说 f(x,y)f(x,y)f(x,y) 的状态由 f(y,x mod y)f(y, x\\bmod y)f(y,xmody) 决定 若 f(y,x mod y)=0f(y,x\\bmod y)=0f(y,xmody)=0 则 f(x mod y+y,y)=1f(x\\bmod y +y, y)=1f(xmody+y,y)=1 更进一步 f(x mod y+λy,y)&gt;0f(x\\bmod y+\\lambda y, y) &gt; 0f(xmody+λy,y)&gt;0 若 f(y,x mod y)&gt;1f(y, x\\bmod y)&gt;1f(y,xmody)&gt;1 则 f(x mod y+y,y)=0f(x\\bmod y+y,y)=0f(xmody+y,y)=0 但是 f(x mod λy,y)&gt;,λ≥2f(x\\bmod \\lambda y, y)&gt;,\\lambda\\geq 2f(xmodλy,y)&gt;,λ≥2 综上 x≥x mod y+2y⇔⌊xy⌋≥2x\\ge x\\bmod y+2y\\Leftrightarrow \\lfloor \\frac{x}{y}\\rfloor\\geq2x≥xmody+2y⇔⌊yx​⌋≥2 时 f(x,y)&gt;0f(x,y)&gt;0f(x,y)&gt;0 ⌊xy⌋=1\\lfloor \\frac{x}{y}\\rfloor=1⌊yx​⌋=1 时 f(x,y)=mex⁡{f(x mod λy,y)}f(x,y)=\\operatorname{mex}\\{f(x\\bmod \\lambda y,y)\\}f(x,y)=mex{f(xmodλy,y)} 从胜负关系考虑 f(x,y)={f(y,x)x&lt;y1⌊xy⌋≥20y=0¬f(y,x mod x)⌊xy⌋=1 f(x,y)=\\left\\{ \\begin{aligned} &amp;f(y,x)&amp;x&lt;y\\\\ &amp;1&amp;\\lfloor \\frac{x}{y}\\rfloor\\geq2\\\\ &amp;0&amp;y=0\\\\ &amp;\\neg f(y,x\\bmod x)&amp;\\lfloor \\frac{x}{y}\\rfloor=1 \\end{aligned} \\right. f(x,y)=⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​​f(y,x)10¬f(y,xmodx)​x&lt;y⌊yx​⌋≥2y=0⌊yx​⌋=1​1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;bool gcd(ll a, ll b) { if (a &lt; b) return gcd(b, a); if (b == 0) return 0; if (a / b == 1) return !gcd(b, a % b); return 1;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int T; cin &gt;&gt; T; ll a, b; while (cin &gt;&gt; a &gt;&gt; b) cout &lt;&lt; (gcd(a, b) ? &quot;Stan wins\\n&quot; : &quot;Ollie wins\\n&quot;); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%9A%84%E6%B8%B8%E6%88%8F"},{"title":"「洛谷 P1603」斯诺登的密码","text":"这题其实没有什么好说的，暴力打表，然后注意一下 若输出的是一位数需补零 若输出的是零不用补成 00 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;std::map&lt;std::string, int&gt; map;int main(){ using std::cin; using std::cout; using std::endl; std::string s; long long i, ans=0; map.insert(std::make_pair(&quot;one&quot;, 1)); map.insert(std::make_pair(&quot;two&quot;, 4)); map.insert(std::make_pair(&quot;three&quot;, 9)); map.insert(std::make_pair(&quot;four&quot;, 16)); map.insert(std::make_pair(&quot;five&quot;, 25)); map.insert(std::make_pair(&quot;six&quot;, 36)); map.insert(std::make_pair(&quot;seven&quot;, 49)); map.insert(std::make_pair(&quot;eight&quot;, 64)); map.insert(std::make_pair(&quot;nine&quot;, 81)); map.insert(std::make_pair(&quot;ten&quot;, 0)); map.insert(std::make_pair(&quot;eleven&quot;, 21)); map.insert(std::make_pair(&quot;twelve&quot;, 44)); map.insert(std::make_pair(&quot;thirteen&quot;, 69)); map.insert(std::make_pair(&quot;fourteen&quot;, 96)); map.insert(std::make_pair(&quot;fifteen&quot;, 25)); map.insert(std::make_pair(&quot;sixteen&quot;, 56)); map.insert(std::make_pair(&quot;seventeen&quot;, 89)); map.insert(std::make_pair(&quot;eighteen&quot;, 89)); map.insert(std::make_pair(&quot;nineteen&quot;, 61)); map.insert(std::make_pair(&quot;twenty&quot;, 0)); map.insert(std::make_pair(&quot;a&quot;, 1)); map.insert(std::make_pair(&quot;both&quot;, 4)); map.insert(std::make_pair(&quot;third&quot;, 9)); map.insert(std::make_pair(&quot;second&quot;, 4)); map.insert(std::make_pair(&quot;first&quot;, 1)); map.insert(std::make_pair(&quot;another&quot;, 1)); for (i=0;i&lt;6;i++){ cin &gt;&gt; s; if (map.count(s) != 0) ans = ans*100 + map[s]; } if (ans &lt; 10 &amp;&amp; ans != 0) cout &lt;&lt; '0'; cout &lt;&lt; ans; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/%E6%B4%9B%E8%B0%B7P1603%E9%A2%98%E8%A7%A3"},{"title":"「洛谷 P4275」萃香的请柬","text":"给定一个只含 B, L 的字符串序列 定义一次变换为：B 扩展为 BL，L 变成 B，例如 BBLBL -&gt; BLBLBBLB 求经过无数次变换后，∑i=lr[si=B]\\sum_{i=l}^r [s_i=\\text{B}]∑i=lr​[si​=B] ( l≤r≤263)(~l\\le r\\le 2^{63})( l≤r≤263) 这是一道很有意思的题 首先无数次变换表示只需考虑从单字符 B 开始的变换 123456a[1] = Ba[2] = BLa[3] = BLBa[4] = BLBBLa[5] = BLBBLBLBa[6] = BLBBLBLBBLBBL 发现变换非常相似 123456BLBBLBLB 看成 a[5] = a[4] + a[3]a[4] -&gt; a[5]a[3] -&gt; a[4]a[5] -&gt; a[5] + a[4] = a[6] 发现 a 的长度、a 中 B 的数量和斐波那契 不可告人的 关系，具体请您自行打表发现 可以保证 s1⋯ns_{1\\cdots n}s1⋯n​ 一定由若干个 a 由长到短依次拼接而成（归纳可证），例如 12BLBBLBLBBLBBBLBBLBLB | BLB | B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 94;ull fib[100];int get(ll n) { return (std::upper_bound(fib, fib + 1 + N, n) - 1 - fib); }ll s(ll n) { if (n &lt;= 0) return 0; ll ret = 0; while (n) { int x = get(n); ret += fib[x - 1]; n -= fib[x]; } return ret;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif char c; io.read(c); int q; io.read(q); fib[0] = 0, fib[1] = 1; rep(i, 2, 93) fib[i] = fib[i - 1] + fib[i - 2]; fib[94] = (1ULL &lt;&lt; 63); while (q--) { ll l, r; io.read(l), io.read(r); io.write(s(r) - s(l - 1), '\\n'); } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/%E8%90%83%E9%A6%99%E7%9A%84%E8%AF%B7%E6%9F%AC"},{"title":"「洛谷 P2575」高手过招","text":"一行棋盘，若干个棋子，初始状态给出，每次可将棋子移到右侧第一个空格（棋子与空格不一定相邻 如：1101-&gt;1011/0111），不能移者输。 暴力好像是可以的，毕竟 2202^{20}220 挺小的 发现一块棋子 123456011110-&gt;011101011011010111001111 Vexalwig_Goodwcoffin 首先，我们在整个序列前面加上一个空格（设此时空格个数为 C+1C+1C+1 ），然后从右到左将所有空格编号为 000 至 CCC 。令第 iii 级阶梯上的棋子数为编号为ii的空格右边的连续棋子个数。 以下用■表示棋子，□表示空格。则对于这个场景： (□)□■□□□□□□□□□□□□□□□□■■ 有第 000 至 171717 级阶梯（容易数出有 181818 个空格）棋子个数分别是 {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}\\{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0\\}{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0} 。 将一个棋子移至右边第一个空格时，相当于将其与其右边相邻的所有棋子移到下一级阶梯。如这样： (□)□■□□□□□□□□□□□□□□□□■■变成 (□)□□■□□□□□□□□□□□□□□□■■时相当于 {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}\\{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0\\}{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0} 变成 {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}\\{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0\\}{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}（第1616层一颗棋子下移一级阶梯），又如： (□)■■■□□■变成 (□)■□■■□■时相当于 {1,0,3}\\{1,0,3\\}{1,0,3} 变成 {1,2,1}\\{1,2,1\\}{1,2,1}（第 222 层两颗棋子下移一级阶梯）。 我们发现，当所有棋子都在第 000 级阶梯时，先手无法操作，必败。 转化为阶梯博弈模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int T; cin &gt;&gt; T; std::bitset&lt;25&gt; a; while (T--) { int n; cin &gt;&gt; n; int ans = 0; rep(i, 1, n) { a = 0; int m; cin &gt;&gt; m; rep(i, 1, m) { int x; cin &gt;&gt; x; a[x] = 1; } int cnt = 0, tot = 0, ans1 = 0; per(i, 20, 0) { if (a[i] == 0) { if (cnt &amp; 1) ans1 ^= tot; cnt++, tot = 0; } else tot++; } ans ^= ans1; } cout &lt;&lt; (ans ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E6%B4%9B%E8%B0%B7/%E9%AB%98%E6%89%8B%E8%BF%87%E6%8B%9B"},{"title":"「SDOI 2009」E&amp;D","text":"局面 (x,y) x,y&gt;0(x,y)~~~ x,y&gt;0(x,y) x,y&gt;0 操作 (x,y)→(a,b) a+b=x(x,y)\\rightarrow(a,b)~~~a+b=x(x,y)→(a,b) a+b=x 或 a+b=ya+b=ya+b=y x,y≤2×109x,y\\le 2\\times 10^9x,y≤2×109 先手必败还是必胜？ 首先打个表，朴素算 sg⁡\\operatorname{sg}sg 12345678910111213141516std::map&lt;pii, int&gt; sg;int calc(pii c) { if (sg.count(c)) return sg[c]; std::vector&lt;int&gt; s; rep(i, 1, c.first - 1) s.push_back(calc({i, c.first - i})); rep(i, 1, c.second - 1) s.push_back(calc({i, c.second - i})); std::sort(s.begin(), s.end()); s.erase(std::unique(s.begin(), s.end()), s.end()); int lst = -1; for (auto i : s) { if (i != lst + 1) return sg[c] = lst + 1; lst = i; } return sg[c] = lst + 1;} 然后输到 Excel 非常的有规律 1234567#define c(x, p) (x % p ? x % p : p) // 0 % p = pint sg(ui x, ui y) { for (ui i = 0, p = 2; i &lt; 31; i++, p *= 2) { if ((c(x, p) &lt;= p / 2) &amp;&amp; (c(y, p) &lt;= p / 2)) return i; } return 31;} iii 从小到大考虑， if 中的条件意思是在正方形的左上角 1/41/41/4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;typedef unsigned long long ull;#define c(x, p) (x % p ? x % p : p)int sg(ui x, ui y) { for (ui i = 0, p = 2; i &lt; 31; i++, p *= 2) { if ((c(x, p) &lt;= p / 2) &amp;&amp; (c(y, p) &lt;= p / 2)) return i; } return 31;}int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); int T; cin &gt;&gt; T; while (T--) { cerr &lt;&lt; &quot;doing &quot; &lt;&lt; T &lt;&lt; endl; int n; cin &gt;&gt; n; n /= 2; int ans = 0; rep(i, 1, n) { int x, y; cin &gt;&gt; x &gt;&gt; y; // cerr &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; ans ^= sg(x, y); } cout &lt;&lt; (ans ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; std::endl; } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/E-D"},{"title":"「SDOI 2009」HH的项链","text":"称贝壳的种类为颜色 考虑离线做法，将询问按照 rrr 升序排序 发现只需要维护每个颜色的目前最右出现位置（ ≤r\\le r≤r ） 每个颜色只在最后出现的地方进行统计，显然可以保证最优（因为离线） 举个例子 12345678910111213颜色序列为1 3 1 2 1扫到 1 （位置）1 0 0 0 0扫到 21 1 0 0 0扫到 30 1 1 0 0扫到 40 1 1 1 0扫到 50 1 0 1 1 0/1 序列用树状数组维护即可，答案即是 0/1 序列 sum(l,r)sum(l, r)sum(l,r) 在线做法，用可持久化线段树即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int N = 500100;struct Q { int id, l, r, ans;} q[N];int a[N], c[N], lst[1000100], n;bool cmp_r(const Q&amp; x, const Q&amp; y) { return x.r &lt; y.r; }bool cmp_id(const Q&amp; x, const Q&amp; y) { return x.id &lt; y.id; }inline int lowbit(int i) { return i &amp; (-i); }void add(int i, int x) { for (; i &lt;= n; i += lowbit(i)) c[i] += x;}int s(int i) { int ret = 0; for (; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret;}int ask(int l, int r) { return s(r) - s(l - 1); }int main() {#ifdef LOCAL freopen(&quot;/tmp/1878/1878/1.in&quot;, &quot;r&quot;, stdin);#endif std::ios::sync_with_stdio(false); cout.tie(0); cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; a[i]; int m; cin &gt;&gt; m; rep(i, 1, m) { q[i].id = i; cin &gt;&gt; q[i].l &gt;&gt; q[i].r; } std::sort(q + 1, q + 1 + m, cmp_r); int idx = 1; rep(i, 1, m) { for (; idx &lt;= q[i].r; ++idx) { if (lst[a[idx]]) add(lst[a[idx]], -1); add(idx, 1); lst[a[idx]] = idx; } q[i].ans = ask(q[i].l, q[i].r); } std::sort(q + 1, q + 1 + m, cmp_id); rep(i, 1, m) cout &lt;&lt; q[i].ans &lt;&lt; endl; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/HH%E7%9A%84%E9%A1%B9%E9%93%BE"},{"title":"「ZJOI2019」线段树","text":"偷一张图 定义 fuf_ufu​ 为：tagu=1\\mathrm{tag}_u = 1tagu​=1 的概率。 定义 gug_ugu​ 为：uuu 的祖先存在 tag=1\\mathrm{tag} = 1tag=1 的概率。 白色： g=g/2,f=f/2g=g/2,f=f/2g=g/2,f=f/2 橙色： f=(g+f)/2f=(g+f)/2f=(g+f)/2 深灰： g=(1+g)/2,f=(1+f)/2g=(1+g)/2,f=(1+f)/2g=(1+g)/2,f=(1+f)/2 浅灰： g=(1+g)/2g=(1+g)/2g=(1+g)/2 黄色：（啥都不用干 由线段树性质得，白色橙色深灰节点个数为 log⁡n\\log nlogn 级别。 为了修改浅灰，定义 tgutg_utgu​ 为 uuu 的子节点需要经过 tgutg_utgu​ 次 g=(1+g)/2g=(1+g)/2g=(1+g)/2 的变换。 下放想必是简单的… 对了，为了查询和，还需要维护 sfusf_usfu​ 代表 uuu 的子节点和自身 fff 的和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr; using std::cin; using std::cout; using std::endl; using std::make_pair; using std::pair;typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair&lt;int, int&gt; pii; const int N = 100010, p = 998244353, i2 = 499122177; // i2*2 = 1int inv2[N], pow2[N];inline int add(int x, int y){ x += y; return x&gt;=p ? x-p : x; }inline int sub(int x, int y){ x -= y; return x&gt;=0 ? x : x+p;}inline int mul(int x, int y){ return int((ll)x*y%p); }struct Node { int g, sf, f, tg;} T[N*4];#define s T[idx]#define lc (idx*2)#define rc (idx*2+1)#define sl T[idx*2]#define sr T[idx*2+1]int L, R;void pushdown(int idx){ if (s.tg &gt; 0){ sl.tg += s.tg, sl.g = add(mul(sl.g, inv2[s.tg]), sub(1, inv2[s.tg])); sr.tg += s.tg, sr.g = add(mul(sr.g, inv2[s.tg]), sub(1, inv2[s.tg])); s.tg = 0; }}void pushup(int idx){ s.sf = add(add(s.f, sl.sf), sr.sf); }int c = 0;void modify(int idx, int l, int r){ if (L &lt;= l &amp;&amp; r &lt;= R){ // 3 s.g = mul(1+s.g, i2); s.sf = sub(s.sf, s.f); s.f = mul(1+s.f, i2); s.sf = add(s.sf, s.f); s.tg++; // 4 return; } if (r &lt; L || R &lt; l){ // 2 s.sf = sub(s.sf, s.f); s.f = mul(add(s.g, s.f), i2); s.sf = add(s.sf, s.f); return; } // 1 pushdown(idx); s.g = mul(s.g, i2); s.f = mul(s.f, i2); int mid = (l + r)/2; modify(lc, l, mid); modify(rc, mid+1, r); pushup(idx);}int main() { std::ios::sync_with_stdio(false); cout.tie(0); inv2[0] = 1, inv2[1] = 499122177; rep(i, 2, 100000) inv2[i] = mul(inv2[i-1], inv2[1]); pow2[0] = 1; rep(i, 1, 100000) pow2[i] = add(pow2[i-1], pow2[i-1]); int n, m; cin &gt;&gt; n &gt;&gt; m; while(m--){ int opt; cin &gt;&gt; opt; if (opt == 1){ cin &gt;&gt; L &gt;&gt; R; c++; modify(1, 1, n); } else { cout &lt;&lt; sub( mul(T[1].sf, pow2[c]), 0 ) &lt;&lt; '\\n'; } } return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/ZJOI2019"},{"title":"「AHOI 2009」中国象棋","text":"给定 n×mn\\times mn×m 棋盘，每格只能放 111 个棋子，每行每列最多放 222 个棋子，问方案数量 我好菜啊，又不会做 fi,j,k,lf_{i, j, k, l}fi,j,k,l​ 表示当前处理到第 iii 行，有 jjj 列放的数量为 111 ，有 kkk 列放的数量为 222 ，有 lll 列放的数量为 000 考虑 j+k+l=mj+k+l = mj+k+l=m 可以压掉一维 转移 12345678910111213141516171819// C(n) = C(n, 2) = n * (n - 1) / 2;// 0f[i + 1][j][k] += f[i][j][k];// 1// l-&gt;jif (l &gt;= 1) (f[i + 1][j + 1][k] += f[i][j][k] * l) %= p;// j-&gt;kif (j &gt;= 1) (f[i + 1][j - 1][k + 1] += f[i][j][k] * j) %= p;// 2// l-&gt;j l-&gt;jif (l &gt;= 2) (f[i + 1][j + 2][k] += f[i][j][k] * C(l)) %= p;// l-&gt;j j-&gt;kif (l &gt;= 1 &amp;&amp; j &gt;= 1) (f[i + 1][j][k + 1] += f[i][j][k] * l * j) %= p;// j-&gt;k j-&gt;kif (j &gt;= 2) (f[i + 1][j - 2][k + 2] += f[i][j][k] * C(j)) %= p; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;int n, m;ll f[105][105][105], ans;const int p = 9999973;inline ll C(int n) { return n * (n - 1) / 2; }int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif io.read(n), io.read(m); f[0][0][0] = 1; rep(i, 0, n - 1) { rep(j, 0, m) { rep(k, 0, m) { if (j + k &gt; m) break; int l = m - j - k; // l-&gt;0 // j-&gt;1 // k-&gt;2 // 0 f[i + 1][j][k] += f[i][j][k]; // 1 // l-&gt;j if (l &gt;= 1) (f[i + 1][j + 1][k] += f[i][j][k] * l) %= p; // j-&gt;k if (j &gt;= 1) (f[i + 1][j - 1][k + 1] += f[i][j][k] * j) %= p; // 2 // l-&gt;j l-&gt;j if (l &gt;= 2) (f[i + 1][j + 2][k] += f[i][j][k] * C(l)) %= p; // l-&gt;j j-&gt;k if (l &gt;= 1 &amp;&amp; j &gt;= 1) (f[i + 1][j][k + 1] += f[i][j][k] * l * j) %= p; // j-&gt;k j-&gt;k if (j &gt;= 2) (f[i + 1][j - 2][k + 2] += f[i][j][k] * C(j)) %= p; } } } int ans = 0; rep(j, 0, m) rep(k, 0, m)(ans += f[n][j][k]) %= p; io.write(ans); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B"},{"title":"「SDOI 2010」地精部落","text":"我们称一个排列是合法的，当且仅当每一个数都满足这个数比它相邻的数都要大或都要小。 求长度为 NNN 的合法排列数量。 我好弱啊，又不会做 ¶ Sol 1 首先一个长度为 nnn 的合法排列，可以分为两种，开头为山谷，开头为山峰 易知，这两种情况方案数相同 定义 fnf_nfn​ 为长度为 nnn 时，第一个为山峰的方案数量（同样也是山谷的方案数量）。 考虑已知 f0∼fn−1f_0 \\sim f_{n-1}f0​∼fn−1​ ，如何转移到 fnf_nfn​ ？ 考虑枚举 nnn 在 jjj 处当山峰，jjj 为奇数 那么去掉 nnn 后， 1∼n−11\\sim n-11∼n−1 需要分成两堆，大小为 j−1,n−jj-1, n-jj−1,n−j，选的方案总数为 (j−1n−1){j-1 \\choose n-1}(n−1j−1​)。然后想像成离散化。 fn=∑fj−1fn−j(j−1n−1)[j mod 2=1] f_n = \\sum f_{j-1} f_{n-j} {j-1 \\choose n-1}[j\\bmod 2 = 1] fn​=∑fj−1​fn−j​(n−1j−1​)[jmod2=1]Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;const int N = 5000;ll f[N], c[2][N];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n, p; io.read(n), io.read(p); c[0][0] = 1; c[1][0] = c[1][1] = 1; f[0] = 1, f[1] = 1; rep(i, 2, n) { int pre = (i &amp; 1) ^ 1, cur = i &amp; 1; rep(j, 1, i)(c[cur][j] = c[pre][j - 1] + c[pre][j]) %= p; c[cur][0] = 1; for (int j = 1; j &lt;= i; j += 2) (f[i] += f[j - 1] * f[i - j] % p * c[pre][j - 1]) %= p; } io.write(f[n] * 2 % p); return 0;} ¶ Sol 2 待补","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD"},{"title":"「HAOI 2007」理想的正方形","text":"给定 n×mn\\times mn×m 整数矩阵，选取 k×kk\\times kk×k 正方形区域，使其中「最大值减最小值」最小 首先是一个很数据结构的做法，维护一个二维 ST 表即可 其次是一个有趣的做法 令 ci,j=max⁡j−k&lt;l≤jai,lc_{i,j} = \\max_{j - k &lt; l \\le j} a_{i, l}ci,j​=maxj−k&lt;l≤j​ai,l​ 处理出长度为 kkk 的行最大 然后在 ci,jc_{i,j}ci,j​ 的基础上求列最大 形式化地讲 di,j=max⁡i−k&lt;l≤icl,jd_{i,j} = \\max_{i-k&lt;l\\le i} c_{l, j}di,j​=maxi−k&lt;l≤i​cl,j​ 然后 di,jd_{i,j}di,j​ 就是右下角在 (i,j)(i,j)(i,j) 的 k×kk\\times kk×k 正方形的最大值，即 max⁡i−k&lt;p≤i,j−l&lt;q≤jap,q\\max_{i-k&lt;p\\le i, j-l&lt;q\\le j}a_{p, q}maxi−k&lt;p≤i,j−l&lt;q≤j​ap,q​ 最小值同理 维护定长区间最值可以用单调队列 deque 真的好慢啊 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;// #pragma GCC optimize(&quot;Ofast&quot;)// #pragma GCC optimize(&quot;inline&quot;)// #pragma GCC optimize(&quot;-fgcse&quot;)// #pragma GCC optimize(&quot;-fgcse-lm&quot;)// #pragma GCC optimize(&quot;-fipa-sra&quot;)// #pragma GCC optimize(&quot;-ftree-pre&quot;)// #pragma GCC optimize(&quot;-ftree-vrp&quot;)// #pragma GCC optimize(&quot;-fpeephole2&quot;)// #pragma GCC optimize(&quot;-ffast-math&quot;)// #pragma GCC optimize(&quot;-fsched-spec&quot;)// #pragma GCC optimize(&quot;unroll-loops&quot;)// #pragma GCC optimize(&quot;-falign-jumps&quot;)// #pragma GCC optimize(&quot;-falign-loops&quot;)// #pragma GCC optimize(&quot;-falign-labels&quot;)// #pragma GCC optimize(&quot;-fdevirtualize&quot;)// #pragma GCC optimize(&quot;-fcaller-saves&quot;)// #pragma GCC optimize(&quot;-fcrossjumping&quot;)// #pragma GCC optimize(&quot;-fthread-jumps&quot;)// #pragma GCC optimize(&quot;-funroll-loops&quot;)// #pragma GCC optimize(&quot;-fwhole-program&quot;)// #pragma GCC optimize(&quot;-freorder-blocks&quot;)// #pragma GCC optimize(&quot;-fschedule-insns&quot;)// #pragma GCC optimize(&quot;inline-functions&quot;)// #pragma GCC optimize(&quot;-ftree-tail-merge&quot;)// #pragma GCC optimize(&quot;-fschedule-insns2&quot;)// #pragma GCC optimize(&quot;-fstrict-aliasing&quot;)// #pragma GCC optimize(&quot;-fstrict-overflow&quot;)// #pragma GCC optimize(&quot;-falign-functions&quot;)// #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;)// #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;)// #pragma GCC optimize(&quot;-fsched-interblock&quot;)// #pragma GCC optimize(&quot;-fpartial-inlining&quot;)// #pragma GCC optimize(&quot;no-stack-protector&quot;)// #pragma GCC optimize(&quot;-freorder-functions&quot;)// #pragma GCC optimize(&quot;-findirect-inlining&quot;)// #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;)// #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;)// #pragma GCC optimize(&quot;inline-small-functions&quot;)// #pragma GCC optimize(&quot;-finline-small-functions&quot;)// #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;)// #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;)// #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;)// #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;)// #pragma GCC optimize(&quot;inline-functions-called-once&quot;)// #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;)#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;// #define DEBUG 1 //调试开关struct IO {#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }#endif inline char gc() {#if DEBUG //调试，可显示字符 return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? -1 : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) {#if DEBUG //调试，可显示字符 putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push('-'); // 负数输出 static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } inline void write(const char *s) { while (*s != '\\0') push(*(s++)); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); }} io;int a[1010][1010], c1[1010][1010], c2[1010][1010], d1[1010][1010], d2[1010][1010];int main() {#ifdef LOCAL freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif int n, m, k; io.read(n), io.read(m), io.read(k); std::deque&lt;pii&gt; mx, mn; // first-&gt;time, second-&gt;value rep(i, 1, n) { mx.clear(), mn.clear(); rep(j, 1, m) { io.read(a[i][j]); while (mx.size() &amp;&amp; mx.front().first &lt;= j - k) mx.pop_front(); while (mn.size() &amp;&amp; mn.front().first &lt;= j - k) mn.pop_front(); while (mx.size() &amp;&amp; mx.back().second &lt;= a[i][j]) mx.pop_back(); while (mn.size() &amp;&amp; mn.back().second &gt;= a[i][j]) mn.pop_back(); mx.push_back({j, a[i][j]}); mn.push_back({j, a[i][j]}); c1[i][j] = mx.front().second; c2[i][j] = mn.front().second; } } rep(j, 1, m) { mx.clear(), mn.clear(); rep(i, 1, n) { while (mx.size() &amp;&amp; mx.front().first &lt;= i - k) mx.pop_front(); while (mn.size() &amp;&amp; mn.front().first &lt;= i - k) mn.pop_front(); while (mx.size() &amp;&amp; mx.back().second &lt;= c1[i][j]) mx.pop_back(); while (mn.size() &amp;&amp; mn.back().second &gt;= c2[i][j]) mn.pop_back(); mx.push_back({i, c1[i][j]}); mn.push_back({i, c2[i][j]}); d1[i][j] = mx.front().second; d2[i][j] = mn.front().second; } } int ans = 2147483647; rep(i, k, n) rep(j, k, m) ans = std::min(ans, d1[i][j] - d2[i][j]); io.write(ans); return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2"},{"title":"「SCOI 2007」降雨量","text":"我写这一题是因为 BZOJ 的讨论 线段树（动态开点）裸题，讨论有点烦 因为 yi∈[−109,109]y_i\\in [-10^9, 10^9]yi​∈[−109,109] 所以需要离散化或者动态开点 规定未定义的节点降雨量为 000 我觉得动态开点好写 实现以下操作： 单点查询 get(pos) 区间 [l,r][l,r][l,r] 最小 qmin(l, r) 区间 [l,r][l,r][l,r] 最大 qmax(l, r) 线段树节点的编号不能是负数 否则会导致无穷递归 于是我们对于每一个 yyy 都加上 FIX=109+1\\mathrm{FIX}=10^9+1FIX=109+1 int mid = (l + r) / 2 会溢出 须使用 int mid = l + (r - l) / 2 解决了数据结构 开始讨论 12345678910111213141516171819s = get(l), e = get(r);max = qmax(l+1, r-1), min = qmin(l+1, r-1);if (l+1 == r) if (s == 0 || e == 0) cout &lt;&lt; &quot;maybe\\n&quot;; else if (s &lt; e) cout &lt;&lt; &quot;false\\n&quot;; else cout &lt;&lt; &quot;true\\n&quot;;else if (s == 0) if (e == 0) cout &lt;&lt; &quot;maybe\\n&quot;; else if (max &gt;= e) cout &lt;&lt; &quot;false\\n&quot;; else cout &lt;&lt; &quot;maybe\\n&quot;; else if (e == 0) if (max &gt;= s) cout &lt;&lt; &quot;false\\n&quot;; else cout &lt;&lt; &quot;maybe\\n&quot;; else if (s &lt; e || max &gt;= e) cout &lt;&lt; &quot;false\\n&quot;; else if (min == 0) cout &lt;&lt; &quot;maybe\\n&quot;; else cout &lt;&lt; &quot;true\\n&quot;; 然后… 就没有然后了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define rep(i, l, r) for (int i = (l); i &lt;= (r); ++i)#define per(i, l, r) for (int i = (l); i &gt;= (r); --i)using std::cerr;using std::cin;using std::cout;using std::endl;using std::make_pair;using std::pair;typedef pair&lt;int, int&gt; pii;typedef long long ll;typedef unsigned int ui;const int FIX = 1000000001;const int N = 5000000;const int INF = 1000000001;struct SegmentTree { struct node { int max, min; node *ls, *rs; // node(const ) } pool[N], *rt; int L, R, X, V, MAX, MIN; int cnt = 0; node* nn() { return &amp;pool[cnt++]; } inline void pushup(node* cur) { assert(cur != nullptr); // assert(cur-&gt;ls != nullptr); // assert(cur-&gt;rs != nullptr); cur-&gt;max = std::max(cur-&gt;ls != nullptr ? cur-&gt;ls-&gt;max : 0, cur-&gt;rs != nullptr ? cur-&gt;rs-&gt;max : 0); cur-&gt;min = std::min(cur-&gt;ls != nullptr ? cur-&gt;ls-&gt;min : 0, cur-&gt;rs != nullptr ? cur-&gt;rs-&gt;min : 0); } node* _insert(node* cur, int l, int r) { if (X &lt; l || r &lt; X) return cur; if (cur == nullptr) { // cerr &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; cur = nn(); } if (l == r) { cur-&gt;max = cur-&gt;min = V; return cur; } // int mid = (l + r) / 2; int mid = l + (r - l) / 2; cur-&gt;ls = _insert(cur-&gt;ls, l, mid); cur-&gt;rs = _insert(cur-&gt;rs, mid + 1, r); pushup(cur); return cur; } int _qmin(node* cur, int l, int r) { if (R &lt; l || r &lt; L) return INF; if (cur == nullptr) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cur-&gt;min; // int mid = (l + r) / 2; int mid = l + (r - l) / 2; return std::min(_qmin(cur-&gt;ls, l, mid), _qmin(cur-&gt;rs, mid + 1, r)); } int _qmax(node* cur, int l, int r) { if (cur == nullptr || R &lt; l || r &lt; L) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return cur-&gt;max; // int mid = (l + r) / 2; int mid = l + (r - l) / 2; return std::max(_qmax(cur-&gt;ls, l, mid), _qmax(cur-&gt;rs, mid + 1, r)); } void init(int l, int r) { cnt = 0; rt = nn(); MIN = l; MAX = r; // cerr &lt;&lt; MIN &lt;&lt; ' ' &lt;&lt; MAX &lt;&lt; endl; } void insert(int pos, int val) { X = pos; V = val; _insert(rt, MIN, MAX); } int qmin(int l, int r) { L = l, R = r; return _qmin(rt, MIN, MAX); } int qmax(int l, int r) { L = l, R = r; return _qmax(rt, MIN, MAX); } int get(int pos) { return qmin(pos, pos); }} T;void init() { T.init(-1000000000 + FIX, 1000000000 + FIX); int n; int y, r; cin &gt;&gt; n; while (n--) { cin &gt;&gt; y &gt;&gt; r; y += FIX; T.insert(y, r); }}void solve() { int l, r; cin &gt;&gt; l &gt;&gt; r; l += FIX; r += FIX; int s = T.get(l), e = T.get(r); if (l + 1 == r) if (s == 0 || e == 0) cout &lt;&lt; &quot;maybe\\n&quot;; else if (s &lt; e) cout &lt;&lt; &quot;false\\n&quot;; else cout &lt;&lt; &quot;true\\n&quot;; else { int max = T.qmax(l + 1, r - 1), min = T.qmin(l + 1, r - 1); if (s == 0) if (e == 0) cout &lt;&lt; &quot;maybe\\n&quot;; else if (max &gt;= e) cout &lt;&lt; &quot;false\\n&quot;; else cout &lt;&lt; &quot;maybe\\n&quot;; else if (e == 0) if (max &gt;= s) cout &lt;&lt; &quot;false\\n&quot;; else cout &lt;&lt; &quot;maybe\\n&quot;; else if (s &lt; e || max &gt;= e) cout &lt;&lt; &quot;false\\n&quot;; else if (min == 0) cout &lt;&lt; &quot;maybe\\n&quot;; else cout &lt;&lt; &quot;true\\n&quot;; }}int main() { // freopen(&quot;input&quot;, &quot;r&quot;, stdin); std::ios::sync_with_stdio(false); cout.tie(0); init(); int q; cin &gt;&gt; q; while (q--) { solve(); } // cerr &lt;&lt; T.cnt; return 0;}","link":"/archives/%E9%A2%98%E8%A7%A3/%E7%9C%81%E9%80%89/%E9%99%8D%E9%9B%A8%E9%87%8F"}],"tags":[{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"初赛","slug":"初赛","link":"/tags/%E5%88%9D%E8%B5%9B/"},{"name":"乱七八糟","slug":"乱七八糟","link":"/tags/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"无旋 Treap","slug":"无旋-Treap","link":"/tags/%E6%97%A0%E6%97%8B-Treap/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"解析几何","slug":"解析几何","link":"/tags/%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/"},{"name":"整理","slug":"整理","link":"/tags/%E6%95%B4%E7%90%86/"},{"name":"简谐运动","slug":"简谐运动","link":"/tags/%E7%AE%80%E8%B0%90%E8%BF%90%E5%8A%A8/"},{"name":"电磁感应","slug":"电磁感应","link":"/tags/%E7%94%B5%E7%A3%81%E6%84%9F%E5%BA%94/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"素数","slug":"素数","link":"/tags/%E7%B4%A0%E6%95%B0/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"尺取法","slug":"尺取法","link":"/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"众数","slug":"众数","link":"/tags/%E4%BC%97%E6%95%B0/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"POJ","slug":"POJ","link":"/tags/POJ/"},{"name":"USACO","slug":"USACO","link":"/tags/USACO/"},{"name":"基环树","slug":"基环树","link":"/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"势能分析","slug":"势能分析","link":"/tags/%E5%8A%BF%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"找规律","slug":"找规律","link":"/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"分类讨论","slug":"分类讨论","link":"/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"矩阵乘法","slug":"矩阵乘法","link":"/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"虚树","slug":"虚树","link":"/tags/%E8%99%9A%E6%A0%91/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"随机算法","slug":"随机算法","link":"/tags/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"粒子群算法","slug":"粒子群算法","link":"/tags/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"},{"name":"随机","slug":"随机","link":"/tags/%E9%9A%8F%E6%9C%BA/"},{"name":"APIO","slug":"APIO","link":"/tags/APIO/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"高斯消元","slug":"高斯消元","link":"/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"Comet OJ","slug":"Comet-OJ","link":"/tags/Comet-OJ/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"容斥","slug":"容斥","link":"/tags/%E5%AE%B9%E6%96%A5/"},{"name":"Contest Hunter","slug":"Contest-Hunter","link":"/tags/Contest-Hunter/"},{"name":"更相减损术","slug":"更相减损术","link":"/tags/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF/"},{"name":"NOI","slug":"NOI","link":"/tags/NOI/"},{"name":"NOIP","slug":"NOIP","link":"/tags/NOIP/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"DAG","slug":"DAG","link":"/tags/DAG/"},{"name":"分层图","slug":"分层图","link":"/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"},{"name":"强连通分量","slug":"强连通分量","link":"/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"扫描线","slug":"扫描线","link":"/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"负环","slug":"负环","link":"/tags/%E8%B4%9F%E7%8E%AF/"},{"name":"0&#x2F;1 分数规划","slug":"0-1-分数规划","link":"/tags/0-1-%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"牛客","slug":"牛客","link":"/tags/%E7%89%9B%E5%AE%A2/"},{"name":"树上差分","slug":"树上差分","link":"/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"},{"name":"一本通","slug":"一本通","link":"/tags/%E4%B8%80%E6%9C%AC%E9%80%9A/"},{"name":"洛谷","slug":"洛谷","link":"/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"斐波那契数列","slug":"斐波那契数列","link":"/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"阶梯博弈","slug":"阶梯博弈","link":"/tags/%E9%98%B6%E6%A2%AF%E5%8D%9A%E5%BC%88/"},{"name":"SDOI","slug":"SDOI","link":"/tags/SDOI/"},{"name":"分形","slug":"分形","link":"/tags/%E5%88%86%E5%BD%A2/"},{"name":"省选","slug":"省选","link":"/tags/%E7%9C%81%E9%80%89/"},{"name":"可持久化","slug":"可持久化","link":"/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"ZJOI","slug":"ZJOI","link":"/tags/ZJOI/"},{"name":"概率","slug":"概率","link":"/tags/%E6%A6%82%E7%8E%87/"},{"name":"AHOI","slug":"AHOI","link":"/tags/AHOI/"},{"name":"计数","slug":"计数","link":"/tags/%E8%AE%A1%E6%95%B0/"},{"name":"SCOI","slug":"SCOI","link":"/tags/SCOI/"},{"name":"HAOI","slug":"HAOI","link":"/tags/HAOI/"},{"name":"讲课","slug":"讲课","link":"/tags/%E8%AE%B2%E8%AF%BE/"}],"categories":[{"name":"OI","slug":"OI","link":"/categories/OI/"},{"name":"碎碎念","slug":"碎碎念","link":"/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Geek","slug":"Geek","link":"/categories/Geek/"},{"name":"学习笔记","slug":"OI/学习笔记","link":"/categories/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"高中","slug":"高中","link":"/categories/%E9%AB%98%E4%B8%AD/"},{"name":"题解","slug":"OI/题解","link":"/categories/OI/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"高中/数学","link":"/categories/%E9%AB%98%E4%B8%AD/%E6%95%B0%E5%AD%A6/"},{"name":"化学","slug":"高中/化学","link":"/categories/%E9%AB%98%E4%B8%AD/%E5%8C%96%E5%AD%A6/"},{"name":"物理","slug":"高中/物理","link":"/categories/%E9%AB%98%E4%B8%AD/%E7%89%A9%E7%90%86/"}]}